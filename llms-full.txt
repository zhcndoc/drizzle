# Drizzle

> Drizzle is a modern TypeScript ORM developers wanna use in their next project. It is lightweight at only ~7.4kb minified+gzipped, and it's tree shakeable with exactly 0 dependencies. It supports every PostgreSQL, MySQL, SQLite and SingleStore database and is serverless-ready by design.

Source: https://drizzle.zhcndoc.com/docs/arktype

import Npm from '@mdx/Npm.astro';
import Callout from '@mdx/Callout.astro';

# drizzle-arktype

`drizzle-arktype` 是 **[Drizzle ORM](https://github.com/drizzle-team/drizzle-orm)** 的一个插件，允许你从 Drizzle ORM 模式生成 **[Arktype](https://arktype.io/)** 模式。

### 安装依赖

<Npm>
drizzle-arktype
</Npm>

<Callout type="warning">
本文档适用于 `drizzle-arktype@0.1.0` 及更高版本

你还必须安装 Drizzle ORM v0.36.0 或更高版本和 Arktype v2.0.0 或更高版本。
</Callout>

### 选择 schema

定义从数据库查询的数据形状 - 可用于验证 API 返回的数据。

```ts copy
import { pgTable, text, integer } from 'drizzle-orm/pg-core';
import { createSelectSchema } from 'drizzle-arktype';

const users = pgTable('users', {
  id: integer().generatedAlwaysAsIdentity().primaryKey(),
  name: text().notNull(),
  age: integer().notNull()
});

const userSelectSchema = createSelectSchema(users);

const rows = await db.select({ id: users.id, name: users.name }).from(users).limit(1);
const parsed: { id: number; name: string; age: number } = userSelectSchema(rows[0]); // 错误：上述查询未返回 `age`

const rows = await db.select().from(users).limit(1);
const parsed: { id: number; name: string; age: number } = userSelectSchema(rows[0]); // 解析成功
```

视图和枚举类型也支持。

```ts copy
import { pgEnum } from 'drizzle-orm/pg-core';
import { createSelectSchema } from 'drizzle-arktype';

const roles = pgEnum('roles', ['admin', 'basic']);
const rolesSchema = createSelectSchema(roles);
const parsed: 'admin' | 'basic' = rolesSchema(...);

const usersView = pgView('users_view').as((qb) => qb.select().from(users).where(gt(users.age, 18)));
const usersViewSchema = createSelectSchema(usersView);
const parsed: { id: number; name: string; age: number } = usersViewSchema(...);
```

### 插入 schema

定义插入数据库数据的形状 - 可用于验证 API 请求。

```ts copy
import { pgTable, text, integer } from 'drizzle-orm/pg-core';
import { createInsertSchema } from 'drizzle-arktype';

const users = pgTable('users', {
  id: integer().generatedAlwaysAsIdentity().primaryKey(),
  name: text().notNull(),
  age: integer().notNull()
});

const userInsertSchema = createInsertSchema(users);

const user = { name: 'John' };
const parsed: { name: string, age: number } = userInsertSchema(user); // 错误：`age` 未定义

const user = { name: 'Jane', age: 30 };
const parsed: { name: string, age: number } = userInsertSchema(user); // 解析成功
await db.insert(users).values(parsed);
```

### 更新 schema

定义更新数据库数据的形状 - 可用于验证 API 请求。

```ts copy
import { pgTable, text, integer } from 'drizzle-orm/pg-core';
import { createUpdateSchema } from 'drizzle-arktype';
import { parse } from 'arktype';

const users = pgTable('users', {
  id: integer().generatedAlwaysAsIdentity().primaryKey(),
  name: text().notNull(),
  age: integer().notNull()
});

const userUpdateSchema = createUpdateSchema(users);

const user = { id: 5, name: 'John' };
const parsed: { name?: string | undefined, age?: number | undefined } = userUpdateSchema(user); // 错误：`id` 是生成列，不能更新

const user = { age: 35 };
const parsed: { name?: string | undefined, age?: number | undefined } = userUpdateSchema(user); // 解析成功
await db.update(users).set(parsed).where(eq(users.name, 'Jane'));
```

### 精细化定制

每个 create schema 函数都接受一个附加的可选参数，用于扩展、修改或完全覆盖字段的 schema。定义回调函数将扩展或修改 schema，直接提供 arktype schema 会覆盖原有字段。

```ts copy
import { pgTable, text, integer, json } from 'drizzle-orm/pg-core';
import { createSelectSchema } from 'drizzle-arktype';
import { parse, pipe, maxLength, object, string } from 'arktype';

const users = pgTable('users', {
  id: integer().generatedAlwaysAsIdentity().primaryKey(),
  name: text().notNull(),
  bio: text(),
  preferences: json()
});

const userSelectSchema = createSelectSchema(users, {
  name: (schema) => pipe(schema, maxLength(20)), // 扩展 schema
  bio: (schema) => pipe(schema, maxLength(1000)), // 扩展 schema，注意生效前字段可空/可选
  preferences: object({ theme: string() }) // 覆盖字段，包含其可空性
});

const parsed: {
  id: number;
  name: string,
  bio?: string | undefined;
  preferences: {
    theme: string;
  };
} = userSelectSchema(...);
```

### 数据类型参考

```ts
pg.boolean();

mysql.boolean();

sqlite.integer({ mode: 'boolean' });

// Schema
type.boolean;
```

```ts
pg.date({ mode: 'date' });
pg.timestamp({ mode: 'date' });

mysql.date({ mode: 'date' });
mysql.datetime({ mode: 'date' });
mysql.timestamp({ mode: 'date' });

sqlite.integer({ mode: 'timestamp' });
sqlite.integer({ mode: 'timestamp_ms' });

// Schema
type.Date;
```

```ts
pg.date({ mode: 'string' });
pg.timestamp({ mode: 'string' });
pg.cidr();
pg.inet();
pg.interval();
pg.macaddr();
pg.macaddr8();
pg.numeric();
pg.text();
pg.sparsevec();
pg.time();

mysql.binary();
mysql.date({ mode: 'string' });
mysql.datetime({ mode: 'string' });
mysql.decimal();
mysql.time();
mysql.timestamp({ mode: 'string' });
mysql.varbinary();

sqlite.numeric();
sqlite.text({ mode: 'text' });

// Schema
type.string;
```

```ts
pg.bit({ dimensions: ... });

// Schema
type(`/^[01]{${column.dimensions}}$/`);
```

```ts
pg.uuid();

// Schema
type(/^[\da-f]{8}(?:-[\da-f]{4}){3}-[\da-f]{12}$/iu);
```

```ts
pg.char({ length: ... });

mysql.char({ length: ... });

// Schema
type.string.exactlyLength(length);
```

```ts
pg.varchar({ length: ... });

mysql.varchar({ length: ... });

sqlite.text({ mode: 'text', length: ... });

// Schema
type.string.atMostLength(length);
```

```ts
mysql.tinytext();

// Schema
type.string.atMostLength(255); // 无符号 8 位整数范围限制
```

```ts
mysql.text();

// Schema
type.string.atMostLength(65_535); // 无符号 16 位整数范围限制
```

```ts
mysql.mediumtext();

// Schema
type.string.atMostLength(16_777_215); // 无符号 24 位整数范围限制
```

```ts
mysql.longtext();

// Schema
type.string.atMostLength(4_294_967_295); // 无符号 32 位整数范围限制
```

```ts
pg.text({ enum: ... });
pg.char({ enum: ... });
pg.varchar({ enum: ... });

mysql.tinytext({ enum: ... });
mysql.mediumtext({ enum: ... });
mysql.text({ enum: ... });
mysql.longtext({ enum: ... });
mysql.char({ enum: ... });
mysql.varchar({ enum: ... });
mysql.mysqlEnum(..., ...);

sqlite.text({ mode: 'text', enum: ... });

// Schema
type.enumerated(...enum);
```

```ts
mysql.tinyint();

// Schema
type.keywords.number.integer.atLeast(-128).atMost(127); // 8 位有符号整数上下限
```

```ts
mysql.tinyint({ unsigned: true });

// Schema
type.keywords.number.integer.atLeast(0).atMost(255); // 8 位无符号整数上下限
```

```ts
pg.smallint();
pg.smallserial();

mysql.smallint();

// Schema
type.keywords.number.integer.atLeast(-32_768).atMost(32_767); // 16 位有符号整数上下限
```

```ts
mysql.smallint({ unsigned: true });

// Schema
type.keywords.number.integer.atLeast(0).atMost(65_535); // 16 位无符号整数上下限
```

```ts
pg.real();

mysql.float();

// Schema
type.number.atLeast(-8_388_608).atMost(8_388_607); // 24 位整数上下限
```

```ts
mysql.mediumint();

// Schema
type.keywords.number.integer.atLeast(-8_388_608).atMost(8_388_607); // 24 位整数上下限
```

```ts
mysql.float({ unsigned: true });

// Schema
type.number.atLeast(0).atMost(16_777_215); // 24 位无符号整数上下限
```

```ts
mysql.mediumint({ unsigned: true });

// Schema
type.keywords.number.integer.atLeast(0).atMost(16_777_215); // 24 位无符号整数上下限
```

```ts
pg.integer();
pg.serial();

mysql.int();

// Schema
type.keywords.number.integer.atLeast(-2_147_483_648).atMost(2_147_483_647); // 32 位整数上下限
```

```ts
mysql.int({ unsigned: true });

// Schema
type.keywords.number.integer.atLeast(0).atMost(4_294_967_295); // 32 位无符号整数上下限
```

```ts
pg.doublePrecision();

mysql.double();
mysql.real();

sqlite.real();

// Schema
type.number.atLeast(-140_737_488_355_328).atMost(140_737_488_355_327); // 48 位整数上下限
```

```ts
mysql.double({ unsigned: true });

// Schema
type.number.atLeast(0).atMost(281_474_976_710_655); // 48 位无符号整数上下限
```

```ts
pg.bigint({ mode: 'number' });
pg.bigserial({ mode: 'number' });

mysql.bigint({ mode: 'number' });
mysql.bigserial({ mode: 'number' });

sqlite.integer({ mode: 'number' });

// Schema
type.keywords.number.integer.atLeast(-9_007_199_254_740_991).atMost(9_007_199_254_740_991); // JavaScript 最小最大安全整数
```

```ts
mysql.serial();

// Schema
type.keywords.number.integer.atLeast(0).atMost(9_007_199_254_740_991); // JavaScript 最大安全整数
```

```ts
pg.bigint({ mode: 'bigint' });
pg.bigserial({ mode: 'bigint' });

mysql.bigint({ mode: 'bigint' });

sqlite.blob({ mode: 'bigint' });

// Schema
type.bigint.narrow(
  (value, ctx) => value < -9_223_372_036_854_775_808n ? ctx.mustBe('greater than') : value > 9_223_372_036_854_775_807n ? ctx.mustBe('less than') : true
); // 64 位整数上下限
```

```ts
mysql.bigint({ mode: 'bigint', unsigned: true });

// Schema
type.bigint.narrow(
  (value, ctx) => value < 0n ? ctx.mustBe('greater than') : value > 18_446_744_073_709_551_615n ? ctx.mustBe('less than') : true
); // 64 位无符号整数上下限
```

```ts
mysql.year();

// Schema
type.keywords.number.integer.atLeast(1_901).atMost(2_155);
```

```ts
pg.geometry({ type: 'point', mode: 'tuple' });
pg.point({ mode: 'tuple' });

// Schema
type([type.number, type.number]);
```

```ts
pg.geometry({ type: 'point', mode: 'xy' });
pg.point({ mode: 'xy' });

// Schema
type({ x: type.number, y: type.number });
```

```ts
pg.halfvec({ dimensions: ... });
pg.vector({ dimensions: ... });

// Schema
type.number.array().exactlyLength(dimensions);
```

```ts
pg.line({ mode: 'abc' });

// Schema
type({ a: type.number, b: type.number, c: type.number });
```

```ts
pg.line({ mode: 'tuple' });

// Schema
type([type.number, type.number, type.number]);
```

```ts
pg.json();
pg.jsonb();

mysql.json();

sqlite.blob({ mode: 'json' });
sqlite.text({ mode: 'json' });

// Schema
type('string | number | boolean | null').or(type('unknown.any[] | Record<string, unknown.any>'));
```

```ts
sqlite.blob({ mode: 'buffer' });

// Schema
type.instanceOf(Buffer);
```

```ts
pg.dataType().array(...);

// Schema
baseDataTypeSchema.array().exactlyLength(size);
```

Source: https://drizzle.zhcndoc.com/docs/batch-api

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';

# 批量 API

**LibSQL 批量 API 解释**：
_[来源](https://docs.turso.tech/sdk/ts/reference#batch-transactions)_

> 使用 libSQL 客户端库，批量是一个或多个 SQL 语句在隐式事务中按顺序执行。 
事务由 libSQL 后端控制。如果所有语句都成功， 
事务将被提交。如果任何语句失败，则整个事务将回滚，且不会进行任何更改。

**D1 批量 API 解释**：
_[来源](https://developers.cloudflare.com/d1/worker-api/d1-database/#batch)_

> 批量处理会将多个 SQL 语句发送到数据库中的单个调用。 
这可以显著提高性能，因为它减少了与 D1 之间的网络往返延迟。 
D1 在自动提交模式下运行。我们的实现保证列表中的每个语句将按顺序执行和提交，
而且不会并发执行。
批量语句是 SQL 事务。如果序列中的某个语句失败， 
则会返回该特定语句的错误，并会中止或回滚整个序列。

Drizzle ORM 提供了用于 `LibSQL`、`Neon` 和 `D1` 的批量运行 SQL 语句的 API：
```ts
const batchResponse: BatchResponse = await db.batch([
	db.insert(usersTable).values({ id: 1, name: 'John' }).returning({ id: usersTable.id }),
	db.update(usersTable).set({ name: 'Dan' }).where(eq(usersTable.id, 1)),
	db.query.usersTable.findMany({}),
	db.select().from(usersTable).where(eq(usersTable.id, 1)),
	db.select({ id: usersTable.id, invitedBy: usersTable.invitedBy }).from(usersTable),
]);
```
这个例子中的 `batchResponse` 类型将是：
<Tabs items={["libSQL", "Neon", "D1"]}>
<Tab>
```ts
type BatchResponse = [
	{
		id: number;
	}[],
	ResultSet,
	{
		id: number;
		name: string;
		verified: number;
		invitedBy: number | null;
	}[],
	{
		id: number;
		name: string;
		verified: number;
		invitedBy: number | null;
	}[],
	{
		id: number;
		invitedBy: number | null;
	}[],
]
```
</Tab>
<Tab>
```ts
type BatchResponse = [
	{
		id: number;
	}[],
	NeonHttpQueryResult,
	{
		id: number;
		name: string;
		verified: number;
		invitedBy: number | null;
	}[],
	{
		id: number;
		name: string;
		verified: number;
		invitedBy: number | null;
	}[],
	{
		id: number;
		invitedBy: number | null;
	}[],
]
```
</Tab>
<Tab>
```ts
type BatchResponse = [
  {
    id: number;
  }[],
  D1Result,
  {
    id: number;
    name: string;
    verified: number;
    invitedBy: number | null;
  }[],
  {
    id: number;
    name: string;
    verified: number;
    invitedBy: number | null;
  }[],
  {
    id: number;
    invitedBy: number | null;
  }[],
]
```
</Tab>
</Tabs>

可以在 `db.batch` 内使用的所有可能的构建器：
```ts
db.all(),
db.get(),
db.values(),
db.run(),
db.execute(),
db.query.<table>.findMany(),
db.query.<table>.findFirst(),
db.select()...,
db.update()...,
db.delete()...,
db.insert()...,
```


Source: https://drizzle.zhcndoc.com/docs/cache

import Callout from '@mdx/Callout.astro';
import Npm from '@mdx/Npm.astro';

# 缓存

Drizzle 默认将每个查询直接发送到你的数据库。没有隐藏的操作，没有自动缓存或失效 - 你将始终看到确切的执行内容。如果你需要缓存，必须手动选择。

默认情况下，Drizzle 使用 `explicit` 缓存策略（即 `global: false`），因此除非你请求，否则不会缓存任何内容。这防止了在你的应用中出现惊讶或隐藏的性能陷阱。或者，你可以启用 `all` 缓存（`global: true`），这样每个选择都将首先查看缓存。

## 快速开始

### Upstash 集成

Drizzle 提供一个开箱即用的 `upstashCache()` 辅助函数。默认情况下，如果设置了环境变量，它使用 Upstash Redis 进行自动配置。

```ts
import { upstashCache } from "drizzle-orm/cache/upstash";
import { drizzle } from "drizzle-orm/...";

const db = drizzle(process.env.DB_URL!, {
  cache: upstashCache(),
});
```

你还可以显式定义你的 Upstash 凭证，默认启用所有查询的全局缓存或传递自定义缓存选项：

```ts
import { upstashCache } from "drizzle-orm/cache/upstash";
import { drizzle } from "drizzle-orm/...";

const db = drizzle(process.env.DB_URL!, {
  cache: upstashCache({
    // 👇 Redis 凭证（可选 — 也可以从环境变量中提取）
    url: '<UPSTASH_URL>',
    token: '<UPSTASH_TOKEN>',

    // 👇 默认启用所有查询的缓存（可选）
    global: true,

    // 👇 默认缓存行为（可选）
    config: { ex: 60 }
  })
});
```

## 缓存配置参考

Drizzle 支持以下 Upstash 缓存配置选项：

```ts
export type CacheConfig = {
  /**
   * 过期时间（以秒为单位的正整数）
   */
  ex?: number;
  /**
   * 在给定哈希键的一个或多个字段上设置过期（TTL 或生存时间）。
   * 用于 HEXPIRE 命令
   */
  hexOptions?: "NX" | "nx" | "XX" | "xx" | "GT" | "gt" | "LT" | "lt";
};
```

## 缓存使用示例

一旦你配置了缓存，下面是缓存的行为：

**案例1：Drizzle 使用 `global: false`（默认，选择性缓存）**

```ts
import { upstashCache } from "drizzle-orm/cache/upstash";
import { drizzle } from "drizzle-orm/...";

const db = drizzle(process.env.DB_URL!, {
  // 👇 没有传入 `global: true`，默认是 false
  cache: upstashCache({ url: "", token: "" }),
});
```

在这种情况下，以下查询不会从缓存读取

```ts
const res = await db.select().from(users);

// 任何变更操作仍将触发缓存的 onMutate 处理器
// 尝试使任何涉及受影响表的缓存查询失效
await db.insert(users).value({ email: "cacheman@upstash.com" });
```

要使此查询从缓存读取，调用 `.$withCache()`

```ts
const res = await db.select().from(users).$withCache();
```

`.$withCache` 有一组可供你使用的选项，以管理和配置此特定查询策略

```ts
// 为此特定查询重写配置
.$withCache({ config: {} })

// 给此查询一个自定义缓存键（而不是在后台哈希查询+参数）
.$withCache({ tag: 'custom_key' })

// 关闭此查询的自动失效
// 注意：这会导致最终一致性（如下所述）
.$withCache({ autoInvalidate: false })
```

<Callout>
**最终一致性示例**

此示例仅在你手动设置 `autoInvalidate: false` 时相关。默认情况下，启用 `autoInvalidate`。

如果你想关闭 `autoInvalidate`，你可能会在以下情况下：
- 你的数据不经常更改，并且可以接受轻微的过时（例如产品列表、博客文章）
- 你手动处理缓存失效

在这些情况下，关闭它可以减少不必要的缓存失效。然而，在大多数情况下，我们建议保留默认启用。

示例：假设你在 `usersTable` 上缓存以下查询，过期时间为 3 秒：

``` ts
const recent = await db
  .select().from(usersTable)
  .$withCache({ config: { ex: 3 }, autoInvalidate: false });
```

如果有人运行 `db.insert(usersTable)...`，缓存不会立即失效。在最多 3 秒内，你将继续看到旧数据，直到它最终变得一致。
</Callout>

**案例2：Drizzle 使用 `global: true` 选项**

```ts
import { upstashCache } from "drizzle-orm/cache/upstash";
import { drizzle } from "drizzle-orm/...";

const db = drizzle(process.env.DB_URL!, {
  cache: upstashCache({ url: "", token: "", global: true }),
});
```

在这种情况下，以下查询将从缓存读取

```ts
const res = await db.select().from(users);
```

如果你想禁用此特定查询的缓存，调用 `.$withCache(false)`

```ts
// 禁用此查询的缓存
const res = await db.select().from(users).$withCache(false);
```

你还可以使用来自 `db` 的缓存实例来使特定表或标签失效。

```ts
// 使所有使用 `users` 表的查询失效。你可以用 Drizzle 实例做到这一点。
await db.$cache.invalidate({ tables: users });
// 或
await db.$cache.invalidate({ tables: [users, posts] });

// 使所有使用 `usersTable` 的查询失效。你可以使用表名称来做到这一点。
await db.$cache.invalidate({ tables: "usersTable" });
// 或
await db.$cache.invalidate({ tables: ["usersTable", "postsTable"] });

// 你还可以使在任何之前执行的选择查询中定义的自定义标签失效。
await db.$cache.invalidate({ tags: "custom_key" });
// 或
await db.$cache.invalidate({ tags: ["custom_key", "custom_key1"] });
```

## 自定义缓存

此示例展示如何在 Drizzle 中插入自定义 `cache`：你提供函数从缓存中获取数据、将结果存储回缓存，并在每次执行变更时使条目失效。

缓存扩展提供此配置选项集
```ts
export type CacheConfig = {
  /** 过期时间，以秒为单位 */
  ex?: number;
  /** 过期时间，以毫秒为单位 */
  px?: number;
  /** 键将在 Unix 时间（秒）到期 */
  exat?: number;
  /** 键将在 Unix 时间（毫秒）到期 */
  pxat?: number;
  /** 更新键时保留现有的 TTL */
  keepTtl?: boolean;
  /** HEXPIRE（哈希字段 TTL）的选项 */
  hexOptions?: 'NX' | 'XX' | 'GT' | 'LT' | 'nx' | 'xx' | 'gt' | 'lt';
};
```

```ts
const db = drizzle(process.env.DB_URL!, { cache: new TestGlobalCache() });
```

```ts
import Keyv from "keyv";

export class TestGlobalCache extends Cache {
  private globalTtl: number = 1000;
  // 此对象将用于存储特定表使用的查询键，
  // 以便我们以后可以用于失效处理。
  private usedTablesPerKey: Record<string, string[]> = {};

  constructor(private kv: Keyv = new Keyv()) {
    super();
  }

  // 对于策略，我们有两个选项：
  // - 'explicit': 仅当对查询添加了 .$withCache() 时使用缓存。
  // - 'all': 所有查询被全局缓存。
  // 默认行为是 'explicit'。
  override strategy(): "explicit" | "all" {
    return "all";
  }

  // 此函数接受查询和参数，缓存到键参数中，
  // 允许你从缓存中检索此查询的响应值。
  override async get(key: string): Promise<any[] | undefined> {
    const res = (await this.kv.get(key)) ?? undefined;
    return res;
  }

  // 此函数接受多个选项以定义缓存数据将如何存储：
  // - 'key': 哈希查询和参数。
  // - 'response': Drizzle 从数据库返回的值数组。
  // - 'tables': 参与选择查询的表数组。这些信息对于缓存失效是必需的。
  //
  // 例如，如果某个查询使用了 "users" 和 "posts" 表，你可以存储这些信息。稍后，当应用程序执行
  // 在这些表上的任何变更语句时，可以从缓存中删除相应的键。
  // 如果你对查询的最终一致性感到满意，可以跳过此选项。
  override async put(
    key: string,
    response: any,
    tables: string[],
    config?: CacheConfig,
  ): Promise<void> {
    const ttl = config?.px ?? (config?.ex ? config.ex * 1000 : this.globalTtl);

    await this.kv.set(key, response, ttl);

    for (const table of tables) {
      const keys = this.usedTablesPerKey[table];
      if (keys === undefined) {
        this.usedTablesPerKey[table] = [key];
      } else {
        keys.push(key);
      }
    }
  }

  // 当执行插入、更新或删除语句时调用此函数。
  // 你可以选择跳过此步骤或使使用受影响表的查询失效。
  //
  // 该函数接收一个包含两个键的对象：
  // - 'tags': 用于标记为特定标签的查询，允许按该标签失效。
  // - 'tables': 由插入、更新或删除语句影响的实际表，
  //   帮助你跟踪自上次缓存更新以来哪些表已更改。
  override async onMutate(params: {
    tags: string | string[];
    tables: string | string[] | Table<any> | Table<any>[];
  }): Promise<void> {
    const tagsArray = params.tags
      ? Array.isArray(params.tags)
        ? params.tags
        : [params.tags]
      : [];
    const tablesArray = params.tables
      ? Array.isArray(params.tables)
        ? params.tables
        : [params.tables]
      : [];

    const keysToDelete = new Set<string>();

    for (const table of tablesArray) {
      const tableName = is(table, Table)
        ? getTableName(table)
        : (table as string);
      const keys = this.usedTablesPerKey[tableName] ?? [];
      for (const key of keys) keysToDelete.add(key);
    }

    if (keysToDelete.size > 0 || tagsArray.length > 0) {
      for (const tag of tagsArray) {
        await this.kv.delete(tag);
      }

      for (const key of keysToDelete) {
        await this.kv.delete(key);
        for (const table of tablesArray) {
          const tableName = is(table, Table)
            ? getTableName(table)
            : (table as string);
          this.usedTablesPerKey[tableName] = [];
        }
      }
    }
  }
}
```

## 限制

#### 不会被 `cache` 扩展处理的查询：

- 使用原始查询使用缓存，例如：

```ts
db.execute(sql`select 1`);
```

- 在 `d1` 和 `libsql` 中使用 `batch` 功能时使用缓存

```ts
db.batch([
    db.insert(users).values(...),
    db.update(users).set(...).where()
])
```

- 在事务中使用缓存
```ts
await db.transaction(async (tx) => {
  await tx.update(accounts).set(...).where(...);
  await tx.update...
});
```

#### 目前是临时限制，稍后将处理：

- 使用 Drizzle 关系查询时使用缓存
```ts
await db.query.users.findMany();
```

- 与 `better-sqlite3`、`Durable Objects`、`expo sqlite` 一起使用缓存
- 与 AWS 数据 API 驱动程序一起使用缓存
- 与视图一起使用缓存

Source: https://drizzle.zhcndoc.com/docs/column-types/mysql

import Section from '@mdx/Section.astro';
import Callout from '@mdx/Callout.astro';

我们对所有这些类型提供原生支持，如果这还不足以满足你的需求，请随意创建 **[自定义类型](/docs/custom-types)**。

<Callout title='important' type='warning'>
本部分文档中的所有示例不使用数据库列名别名，列名是根据 TypeScript 键生成的。

如果你想，可以在列名中使用数据库别名，也可以使用 `casing` 参数为 Drizzle 定义映射策略。

你可以在 [这里](/docs/sql-schema-declaration#shape-your-data-schema) 阅读更多信息。
</Callout>

### 整数

一个有符号整数，存储在 `0`、`1`、`2`、`3`、`4`、`6` 或 `8` 字节中，具体取决于值的大小。

<Section>
```typescript
import { int, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	int: int()
});
```

```sql
CREATE TABLE `table` (
	`int` int
);
```
</Section>

### tinyint

<Section>
```typescript
import { tinyint, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	tinyint: tinyint()
});
```

```sql
CREATE TABLE `table` (
	`tinyint` tinyint
);
```
</Section>

### smallint

<Section>
```typescript
import { smallint, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	smallint: smallint()
});
```

```sql
CREATE TABLE `table` (
	`smallint` smallint
);
```
</Section>

### mediumint

<Section>
```typescript
import { mediumint, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	mediumint: mediumint()
});
```

```sql
CREATE TABLE `table` (
	`mediumint` mediumint
);
```
</Section>

### bigint

<Section>
```typescript
import { bigint, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	bigint: bigint({ mode: 'number' })
	bigintUnsigned: bigint({ mode: 'number', unsigned: true })
});

bigint('...', { mode: 'number' | 'bigint' });

// 你还可以为 bigint 指定 unsigned 选项
bigint('...', { mode: 'number' | 'bigint', unsigned: true })
```

```sql
CREATE TABLE `table` (
	`bigint` bigint,
	`bigintUnsigned` bigint unsigned
);
```
</Section>

我们省略了 `bigint(M)` 中的 `M` 配置，因为它表示数字类型的显示宽度。

## ---

### real

<Section>
```typescript
import { real, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	real: real()
});
```

```sql
CREATE TABLE `table` (
	`real` real
);
```
</Section>

<Section>
```typescript
import { real, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	realPrecision: real({ precision: 1,}),
	realPrecisionScale: real({ precision: 1, scale: 1,}),
});
```

```sql
CREATE TABLE `table` (
	`realPrecision` real(1),
	`realPrecisionScale` real(1, 1)
);
```
</Section>

### decimal

<Section>
```typescript
import { decimal, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	decimal: decimal(),
	decimalNum: decimal({ scale: 30, mode: 'number' }),
	decimalBig: decimal({ scale: 30, mode: 'bigint' }),
});
```

```sql
CREATE TABLE `table` (
	`decimal` decimal,
	`decimalNum` decimal(30),
	`decimalBig` decimal(30)
);
```
</Section>

<Section>
```typescript
import { decimal, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	decimalPrecision: decimal({ precision: 1,}),
	decimalPrecisionScale: decimal({ precision: 1, scale: 1,}),
});
```

```sql
CREATE TABLE `table` (
	`decimalPrecision` decimal(1),
	`decimalPrecisionScale` decimal(1, 1)
);
```
</Section>

### double

<Section>
```typescript
import { double, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	double: double('double')
});
```

```sql
CREATE TABLE `table` (
	`double` double
);
```
</Section>

<Section>
```typescript
import { double, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	doublePrecision: double({ precision: 1,}),
	doublePrecisionScale: double({ precision: 1, scale: 1,}),
});
```

```sql
CREATE TABLE `table` (
	`doublePrecision` double(1),
	`doublePrecisionScale` double(1, 1)
);
```
</Section>

### float

<Section>
```typescript
import { float, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	float: float()
});
```

```sql
CREATE TABLE `table` (
	`float` float
);
```
</Section>

## ---

### serial

<Section>

`SERIAL` 是 `BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE` 的别名。

```typescript
import { serial, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	serial: serial()
});
```

```sql
CREATE TABLE `table` (
	`serial` serial AUTO_INCREMENT
);
```
</Section>

## ---

### binary
`BINARY(M)` stores a fixed-length byte string of exactly M bytes.  
On insert, shorter values are right-padded with `0x00` bytes to reach M bytes; on retrieval, no padding is stripped.
All bytes—including trailing `0x00`—are significant in comparisons, `ORDER BY`, and `DISTINCT`
<Section>
```typescript
import { binary, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	binary: binary()
});
```

```sql
CREATE TABLE `table` (
	`binary` binary
);
```
</Section>

### varbinary
`VARBINARY(M)` stores a variable-length byte string of exactly M bytes.  
On insert, shorter values are right-padded with `0x00` bytes to reach M bytes; on retrieval, no padding is stripped.
All bytes—including trailing `0x00`—are significant in comparisons, `ORDER BY`, and `DISTINCT`
<Section>
```typescript
import { varbinary, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	varbinary: varbinary({ length: 2}),
});
```

```sql
CREATE TABLE `table` (
	`varbinary` varbinary(2)
);
```
</Section>

## ---

### char

<Section>
```typescript
import { char, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	char: char(),
});
```

```sql
CREATE TABLE `table` (
	`char` char
);
```
</Section>

### varchar
你可以定义 `{ enum: ["value1", "value2"] }` 配置来推断 `insert` 和 `select` 类型，但它 **不会** 检查运行时的值。
<Section>
```typescript
import { varchar, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	varchar: varchar({ length: 2 }),
});

// 将推断为文本: "value1" | "value2" | null
varchar: varchar({ length: 6, enum: ["value1", "value2"] })
```

```sql
CREATE TABLE `table` (
	`varchar` varchar(2)
);
```
</Section>

### text

你可以定义 `{ enum: ["value1", "value2"] }` 配置来推断 `insert` 和 `select` 类型，但它 **不会** 检查运行时的值。

<Section>
```typescript
import { text, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	text: text(),
});

// 将推断为文本: "value1" | "value2" | null
text: text({ enum: ["value1", "value2"] });
```

```sql
CREATE TABLE `table` (
	`text` text
);
```
</Section>

## ---

### boolean

<Section>
```typescript
import { boolean, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	boolean: boolean(),
});
```

```sql
CREATE TABLE `table` (
	`boolean` boolean
);
```
</Section>

## ---

### date

<Section>
```typescript
import { boolean, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	date: date(),
});
```

```sql
CREATE TABLE `table` (
	`date` date
);
```
</Section>

### datetime

<Section>
```typescript
import { datetime, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	datetime: datetime(),
});

datetime('...', { mode: 'date' | "string"}),
datetime('...', { fsp : 0..6}),
```

```sql
CREATE TABLE `table` (
	`datetime` datetime
);
```
</Section>

<Section>
```typescript
import { datetime, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	datetime: datetime({ mode: 'date', fsp: 6 }),
});
```

```sql
CREATE TABLE `table` (
	`datetime` datetime(6)
);
```
</Section>

### time 

<Section>
```typescript
import { time, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	time: time(),
	timefsp: time({ fsp: 6 }),
});
	
time('...', { fsp: 0..6 }),
```

```sql
CREATE TABLE `table` (
	`time` time,
	`timefsp` time(6)
);
```
</Section>

### year

<Section>
```typescript
import { year, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	year: year(),
});
```

```sql
CREATE TABLE `table` (
	`year` year
);
```
</Section>

### timestamp

<Section>
```typescript
import { timestamp, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	timestamp: timestamp(),
});

timestamp('...', { mode: 'date' | "string"}),
timestamp('...', { fsp : 0..6}),
```

```sql
CREATE TABLE `table` (
	`timestamp` timestamp
);
```
</Section>

<Section>
```typescript
import { timestamp, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	timestamp: timestamp({ mode: 'date', fsp: 6 }),
});
```

```sql
CREATE TABLE `table` (
	`timestamp` timestamp(6)
);
```
</Section>

<Section>
```typescript
import { timestamp, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	timestamp: timestamp().defaultNow(),
});
```

```sql
CREATE TABLE `table` (
	`timestamp` timestamp DEFAULT (now())
);
```
</Section>

## ---

### json

<Section>
```typescript
import { json, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	json: json(),
});

```

```sql
CREATE TABLE `table` (
	`json` json
);
```
</Section>

你可以指定 `.$type<..>()` 进行 json 对象推断，它 **不会** 检查运行时值。
它在编译时提供默认值、插入和选择模式的保护。
```typescript
// 将推断为 { foo: string }
json: json().$type<{ foo: string }>();

// 将推断为 string[]
json: json().$type<string[]>();

// 将无法编译
json: json().$type<string[]>().default({});
```

## ---

### enum

<Section>
```typescript
import { mysqlEnum, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	popularity: mysqlEnum(['unknown', 'known', 'popular']),
});
```

```sql
CREATE TABLE `table` (
	`popularity` enum('unknown','known','popular')
);
```
</Section>

## ---

### 自定义数据类型

每个列构建器都有一个 `.$type()` 方法，允许你自定义列的数据类型。这在处理未知或品牌类型时非常有用。

```ts
type UserId = number & { __brand: 'user_id' };
type Data = {
	foo: string;
	bar: number;
};

const users = mysqlTable('users', {
  id: int().$type<UserId>().primaryKey(),
  jsonField: json().$type<Data>(),
});
```

### 非空
`NOT NULL` 约束规定相关联的列不能包含 `NULL` 值。

<Section>
```typescript
import { int, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	int: int().notNull(),
});
```

```sql
CREATE TABLE `table` (
	`int` int NOT NULL
);
```
</Section>

### 默认值

`DEFAULT` 子句指定在用户进行
`INSERT` 时如果不显式提供值，则使用的列的默认值。
如果没有显式的 `DEFAULT` 子句附加到列定义，
则列的默认值为 `NULL`。

一个显式的 `DEFAULT` 子句可以指定默认值为 `NULL`、
字符串常量、blob 常量、有符号数字或任何用括号括起来的常量表达式。

<Section>
```typescript
import { int, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	int: int().default(3),
});
```

```sql
CREATE TABLE `table` (
	`int` int DEFAULT 3
);
```
</Section>

使用 `$default()` 或 `$defaultFn()` 时，它们只是同一函数的不同别名，
你可以在运行时生成默认值，并在所有插入查询中使用这些值。
这些函数可以帮助你利用各种实现，例如 `uuid`、`cuid`、`cuid2` 等等。

<Callout type="info" emoji="ℹ️">
	注意：该值不会影响 `drizzle-kit` 行为，仅在 `drizzle-orm` 的运行时使用。
</Callout>

```ts
import { varchar, mysqlTable } from "drizzle-orm/mysql-core";
import { createId } from '@paralleldrive/cuid2';

const table = mysqlTable('table', {
	id: varchar({ length: 128 }).$defaultFn(() => createId()),
});
```

使用 `$onUpdate()` 或 `$onUpdateFn()` 时，它们也是同一函数的不同别名，
你可以在运行时生成默认值，并在所有更新查询中使用这些值。

向列添加动态更新值。当更新行时将调用该函数，
如果没有提供值，则返回的值将用作列值。
如果未提供默认值（或 $defaultFn），则在插入行时也将调用该函数，
并且返回的值将用作列值。

<Callout type="info" emoji="ℹ️">
	注意：该值不会影响 `drizzle-kit` 行为，仅在 `drizzle-orm` 的运行时使用。
</Callout>

```ts
import { text, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
    alwaysNull: text().$type<string | null>().$onUpdate(() => null),
});
```

### 主键 

<Section>
```typescript
import { int, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	int: int().primaryKey(),
});
```

```sql
CREATE TABLE `table` (
	`int` int PRIMARY KEY NOT NULL
);
```
</Section>

### 自增

<Section>
```typescript
import { int, mysqlTable } from "drizzle-orm/mysql-core";

const table = mysqlTable('table', {
	int: int().autoincrement(),
});
```

```sql
CREATE TABLE `table` (
	`int` int AUTO_INCREMENT
);
```
</Section>


Source: https://drizzle.zhcndoc.com/docs/column-types/pg


import Section from '@mdx/Section.astro';
import Callout from '@mdx/Callout.astro';

我们对所有这些都提供原生支持，如果这些不够满足您的需求，欢迎创建 **[自定义类型](/docs/custom-types)**。

<Callout title='important' type='warning'>
本部分文档中的所有示例都不使用数据库列名别名，列名是从 TypeScript 键生成的。

如果需要，您可以在列名中使用数据库别名，并且您也可以使用 `casing` 参数定义 Drizzle 的映射策略。

您可以在 [这里](/docs/sql-schema-declaration#shape-your-data-schema) 阅读更多相关信息。
</Callout>

### 整数
`integer` `int` `int4`  
带符号的 4 字节整数

如果您需要 `integer 自增`，请参考 **[serial.](#serial)**

<Section>
```typescript
import { integer, pgTable } from "drizzle-orm/pg-core";

export const table = pgTable('table', {
    int: integer()
});

```

```sql
CREATE TABLE IF NOT EXISTS "table" (
    "int" integer
);
```
</Section>

<Section>
```typescript
import { sql } from "drizzle-orm";
import { integer, pgTable } from "drizzle-orm/pg-core";

export const table = pgTable('table', {
	int1: integer().default(10),
    int2: integer().default(sql`'10'::int`)
});

```

```sql
CREATE TABLE IF NOT EXISTS "table" (
	"int1" integer DEFAULT 10,
    "int2" integer DEFAULT '10'::int
);
```
</Section>

### 小整数
`smallint` `int2`  
小范围带符号的 2 字节整数

如果您需要 `smallint 自增`，请参考 **[smallserial.](#smallserial)**
<Section>
```typescript
import { smallint, pgTable } from "drizzle-orm/pg-core";

export const table = pgTable('table', {
    smallint: smallint()
});
```

```sql
CREATE TABLE IF NOT EXISTS "table" (
    "smallint" smallint
);
```
</Section>

<Section>
```typescript
import { sql } from "drizzle-orm";
import { smallint, pgTable } from "drizzle-orm/pg-core";

export const table = pgTable('table', {
	smallint1: smallint().default(10),
    smallint2: smallint().default(sql`'10'::smallint`)
});
```

```sql
CREATE TABLE IF NOT EXISTS "table" (
	"smallint1" smallint DEFAULT 10,
    "smallint2" smallint DEFAULT '10'::smallint
);
```
</Section>

### 大整数
`bigint` `int8`  
带符号的 8 字节整数

如果您需要 `bigint 自增`，请参考 **[bigserial.](#bigserial)**

如果您预期的值在 2^31 以上但低于 2^53，可以利用 `mode: 'number'` 并处理 JavaScript 数字而不是 bigint。
<Section>
```typescript
import { bigint, pgTable } from "drizzle-orm/pg-core";

export const table = pgTable('table', {
    bigint: bigint({ mode: 'number' })
});

// 将推导为 `number`
bigint: bigint({ mode: 'number' })

// 将推导为 `bigint`
bigint: bigint({ mode: 'bigint' })
```

```sql
CREATE TABLE IF NOT EXISTS "table" (
    "bigint" bigint
);
```
</Section>

<Section>
```typescript
import { sql } from "drizzle-orm";
import { bigint, pgTable } from "drizzle-orm/pg-core";

export const table = pgTable('table', {
	bigint1: bigint().default(10),
    bigint2: bigint().default(sql`'10'::bigint`)
});
```

```sql
CREATE TABLE IF NOT EXISTS "table" (
	"bigint1" bigint DEFAULT 10,
    "bigint2" bigint DEFAULT '10'::bigint
);
```
</Section>

## ---

### 自增整数
`serial` `serial4`  
自动递增的 4 字节整数，为创建唯一标识符列提供书面方便（类似于一些其他数据库支持的 `AUTO_INCREMENT` 属性）。

有关更多信息，请参阅官方 PostgreSQL **[文档.](https://www.postgresql.org/docs/current/datatype-numeric.html#DATATYPE-SERIAL)**
<Section>
```typescript
import { serial, pgTable } from "drizzle-orm/pg-core";

export const table = pgTable('table', {
  serial: serial(),
});
```

```sql
CREATE TABLE IF NOT EXISTS "table" (
    "serial" serial NOT NULL
);
```
</Section>

### 小自增整数
`smallserial` `serial2`  
自动递增的 2 字节整数，为创建唯一标识符列提供书面方便（类似于一些其他数据库支持的 `AUTO_INCREMENT` 属性）。

有关更多信息，请参阅官方 PostgreSQL **[文档.](https://www.postgresql.org/docs/current/datatype-numeric.html#DATATYPE-SERIAL)**
<Section>
```typescript
import { smallserial, pgTable } from "drizzle-orm/pg-core";

export const table = pgTable('table', {
  smallserial: smallserial(),
});
```

```sql
CREATE TABLE IF NOT EXISTS "table" (
    "smallserial" smallserial NOT NULL
);
```
</Section>

### 大自增整数
`bigserial` `serial8`  
自动递增的 8 字节整数，为创建唯一标识符列提供书面方便（类似于一些其他数据库支持的 `AUTO_INCREMENT` 属性）。

有关更多信息，请参阅官方 PostgreSQL **[文档.](https://www.postgresql.org/docs/current/datatype-numeric.html#DATATYPE-SERIAL)**

如果您预期的值在 2^31 以上但低于 2^53，您可以利用 `mode: 'number'` 并处理 JavaScript 数字而不是 bigint。
<Section>
```typescript
import { bigserial, pgTable } from "drizzle-orm/pg-core";

export const table = pgTable('table', {
  bigserial: bigserial({ mode: 'number' }),
});
```

```sql
CREATE TABLE IF NOT EXISTS "table" (
    "bigserial" bigserial NOT NULL
);
```
</Section>

### ---

### 布尔值
PostgreSQL 提供标准 SQL 类型布尔值。

有关更多信息，请参阅官方 PostgreSQL **[文档.](https://www.postgresql.org/docs/current/datatype-boolean.html)**

<Section>
```typescript
import { boolean, pgTable } from "drizzle-orm/pg-core";

export const table = pgTable('table', {
    boolean: boolean()
});

```

```sql
CREATE TABLE IF NOT EXISTS "table" (
    "boolean" boolean
);
```
</Section>

## ---

### 文本
`text`  
可变长度（无限制）字符字符串。

有关更多信息，请参阅官方 PostgreSQL **[文档.](https://www.postgresql.org/docs/current/datatype-character.html)**

您可以定义 `{ enum: ["value1", "value2"] }` 配置以推导 `insert` 和 `select` 类型，但它 **不会** 检查运行时值。
<Section>
```typescript
import { text, pgTable } from "drizzle-orm/pg-core";

export const table = pgTable('table', {
  text: text()
});

// 将推导为 text: "value1" | "value2" | null
text: text({ enum: ["value1", "value2"] })
```

```sql
CREATE TABLE IF NOT EXISTS "table" (
    "text" text
);
```
</Section>

### 可变字符
`character varying(n)` `varchar(n)`  
可变长度字符字符串，可以存储最多 **`n`** 个字符（不是字节）。

有关更多信息，请参阅官方 PostgreSQL **[文档.](https://www.postgresql.org/docs/current/datatype-character.html)**

您可以定义 `{ enum: ["value1", "value2"] }` 配置以推导 `insert` 和 `select` 类型，但它 **不会** 检查运行时值。

根据 PostgreSQL 文档，`length` 参数是可选的。
<Section>
```typescript
import { varchar, pgTable } from "drizzle-orm/pg-core";

export const table = pgTable('table', {
  varchar1: varchar(),
  varchar2: varchar({ length: 256 }),
});

// 将推导为 text: "value1" | "value2" | null
varchar: varchar({ enum: ["value1", "value2"] }),
```

```sql
CREATE TABLE IF NOT EXISTS "table" (
    "varchar1" varchar,
    "varchar2" varchar(256)
);
```
</Section>

### 固定字符
`character(n)` `char(n)`  
固定长度，带空格填充的字符字符串，可以存储最多 **`n`** 个字符（不是字节）。

有关更多信息，请参阅官方 PostgreSQL **[文档.](https://www.postgresql.org/docs/current/datatype-character.html)**

您可以定义 `{ enum: ["value1", "value2"] }` 配置以推导 `insert` 和 `select` 类型，但它 **不会** 检查运行时值。

根据 PostgreSQL 文档，`length` 参数是可选的。
<Section>
```typescript
import { char, pgTable } from "drizzle-orm/pg-core";

export const table = pgTable('table', {
  char1: char(),
  char2: char({ length: 256 }),
});

// 将推导为 text: "value1" | "value2" | null
char: char({ enum: ["value1", "value2"] }),
```

```sql
CREATE TABLE IF NOT EXISTS "table" (
    "char1" char,
    "char2" char(256)
);
```
</Section>

## ---

### 数值
`numeric` `decimal`  
可选精度的精确数值。可以存储具有非常大数字的数字，在小数点前最多可达 131072 位，后最多可达 16383 位。

有关更多信息，请参阅官方 PostgreSQL **[文档.](https://www.postgresql.org/docs/current/datatype-numeric.html#DATATYPE-NUMERIC-DECIMAL)**

<Section>
```typescript
import { numeric, pgTable } from "drizzle-orm/pg-core";

export const table = pgTable('table', {
  numeric1: numeric(),
  numeric2: numeric({ precision: 100 }),
  numeric3: numeric({ precision: 100, scale: 20 }),
  numericNum: numeric({ mode: 'number' }),
  numericBig: numeric({ mode: 'bigint' }),
});
```

```sql
CREATE TABLE IF NOT EXISTS "table" (
    "numeric1" numeric,
    "numeric2" numeric(100),
    "numeric3" numeric(100, 20),
	"numericNum" numeric,
	"numericBig" numeric
);
```
</Section>

### 十进制
**[numeric.](#numeric)** 的别名

### 实数
`real` `float4`  
单精度浮点数（4 字节）

有关更多信息，请参阅官方 PostgreSQL **[文档.](https://www.postgresql.org/docs/current/datatype-numeric.html)**  

<Section>
```typescript
import { sql } from "drizzle-orm";
import { real, pgTable } from "drizzle-orm/pg-core";  

const table = pgTable('table', {
    real1: real(),
    real2: real().default(10.10),
	real3: real().default(sql`'10.10'::real`),
});
```

```sql
CREATE TABLE IF NOT EXISTS "table" (
    "real1" real,
    "real2" real default 10.10,
	"real3" real default '10.10'::real
);
```
</Section>

### 双精度
`double precision` `float8`  
双精度浮点数（8 字节）

有关更多信息，请参阅官方 PostgreSQL **[文档.](https://www.postgresql.org/docs/current/datatype-numeric.html)**  

<Section>
```typescript
import { sql } from "drizzle-orm";
import { doublePrecision, pgTable } from "drizzle-orm/pg-core";

const table = pgTable('table', {
    double1: doublePrecision(),
    double2: doublePrecision().default(10.10),
    double3: doublePrecision().default(sql`'10.10'::double precision`),
});
```

```sql
CREATE TABLE IF NOT EXISTS "table" (
    "double1" double precision,
    "double2" double precision default 10.10,
    "double3" double precision default '10.10'::double precision
);
```
</Section>

## ---


### JSON
`json`  
文本 JSON 数据，如 **[RFC 7159.](https://tools.ietf.org/html/rfc7159)** 中所规定。

有关更多信息，请参阅官方 PostgreSQL **[文档.](https://www.postgresql.org/docs/current/datatype-json.html)**
<Section>
```typescript
import { sql } from "drizzle-orm";
import { json, pgTable } from "drizzle-orm/pg-core";

const table = pgTable('table', {
    json1: json(),
    json2: json().default({ foo: "bar" }),
    json3: json().default(sql`'{foo: "bar"}'::json`),
});
```

```sql
CREATE TABLE IF NOT EXISTS "table" (
    "json1" json,
    "json2" json default '{"foo": "bar"}'::json,
    "json3" json default '{"foo": "bar"}'::json
);
```
</Section>
  
您可以指定 `.$type<..>()` 进行 JSON 对象推导，它 **不会** 检查运行时值。 
它为默认值、插入和选择 схем提供编译时保护。
```typescript
// 将推导为 { foo: string }
json: json().$type<{ foo: string }>();

// 将推导为 string[]
json: json().$type<string[]>();

// 不会编译
json: json().$type<string[]>().default({});
```

### JSONB
`jsonb`  
二进制 JSON 数据，已解构。

有关更多信息，请参阅官方 PostgreSQL **[文档.](https://www.postgresql.org/docs/current/datatype-json.html)**
<Section>
```typescript
import { jsonb, pgTable } from "drizzle-orm/pg-core";

const table = pgTable('table', {
    jsonb1: jsonb(),
    jsonb2: jsonb().default({ foo: "bar" }),
    jsonb3: jsonb().default(sql`'{foo: "bar"}'::jsonb`),
});
```
```sql
CREATE TABLE IF NOT EXISTS "table" (
    "jsonb1" jsonb,
    "jsonb2" jsonb default '{"foo": "bar"}'::jsonb,
    "jsonb3" jsonb default '{"foo": "bar"}'::jsonb
);
```
</Section>

您可以指定 `.$type<..>()` 进行 JSON 对象推导，它 **不会** 检查运行时值。 
它为默认值、插入和选择 схем提供编译时保护。

```typescript
// 将推导为 { foo: string }
jsonb: jsonb().$type<{ foo: string }>();

// 将推导为 string[]
jsonb: jsonb().$type<string[]>();

// 不会编译
jsonb: jsonb().$type<string[]>().default({});
```

## ---

### 时间
`time` `timetz` `带时区的时间` `不带时区的时间`  
一天中的时间，可以带时区或不带时区。

有关更多信息，请参阅官方 PostgreSQL **[文档.](https://www.postgresql.org/docs/current/datatype-datetime.html)**

<Section>
```typescript
import { time, pgTable } from "drizzle-orm/pg-core";

const table = pgTable('table', {
  time1: time(),
  time2: time({ withTimezone: true }),
  time3: time({ precision: 6 }),
  time4: time({ precision: 6, withTimezone: true })
});
```

```sql
CREATE TABLE IF NOT EXISTS "table" (
    "time1" time,
    "time2" time with timezone,
    "time3" time(6),
    "time4" time(6) with timezone
);
```
</Section>

### 时间戳
`timestamp` `timestamptz` `带时区的时间戳` `不带时区的时间戳`  
带时区或不带时区的日期和时间。

有关更多信息，请参阅官方 PostgreSQL **[文档.](https://www.postgresql.org/docs/current/datatype-datetime.html)**
<Section>
```typescript
import { sql } from "drizzle-orm";
import { timestamp, pgTable } from "drizzle-orm/pg-core";

const table = pgTable('table', {
    timestamp1: timestamp(),
    timestamp2: timestamp({ precision: 6, withTimezone: true }),
    timestamp3: timestamp().defaultNow(),
    timestamp4: timestamp().default(sql`now()`),
});
```
```sql
CREATE TABLE IF NOT EXISTS "table" (
	"timestamp1" timestamp,
	"timestamp2" timestamp (6) with time zone,
	"timestamp3" timestamp default now(),
	"timestamp4" timestamp default now()
);
```
</Section>

您可以指定 `date` 或 `string` 推导模式：
```typescript
// 将推导为 date
timestamp: timestamp({ mode: "date" }),

// 将推导为 string
timestamp: timestamp({ mode: "string" }),
```

> `string` 模式并不会为您执行任何映射。
此模式是为了让开发者能够根据其需求自己处理日期和日期映射而添加给 Drizzle ORM 的。
Drizzle 将原样传递原始日期作为字符串，`to` 和 `from` 数据库，
因此其行为应尽可能可预测，且与数据库行为 100% 一致。

> `date` 模式是处理日期的常规方式。Drizzle 将处理数据库和 JS Date 对象之间的所有映射。

<Callout type='info' emoji='ℹ️'>
 如何映射 `timestamp` 和 `带时区的时间戳` 的方式：

 正如 PostgreSQL 文档所述：
 > 在被确定为不带时区的时间戳的字面量中，PostgreSQL 将静默忽略任何时区指示。
 > 也就是说，结果值是根据输入值中的日期/时间字段得出的，并且未根据时区进行调整。
 >
 > 对于带时区的时间戳来说，内部存储的值始终为 UTC（协调世界时间，传统上称为格林威治标准时间 GMT）。
 指定了显式时区的输入值将使用该时区的适当偏移量转换为 UTC。
 如果输入字符串中未指定时区，则假定其在系统的 TimeZone 参数指示的时区，
 并使用该时区区域的偏移值转换为 UTC。

 因此，对于 `带时区的时间戳`，您将收到转换为您 Postgres 实例中设置的时区的字符串。
 您可以使用以下 SQL 查询检查时区： 

```sql 
show timezone;
```


</Callout>

### 日期
`date`  
日历日期（年，月，日）

有关更多信息，请参阅官方 PostgreSQL **[文档.](https://www.postgresql.org/docs/current/datatype-datetime.html)**
<Section>
```typescript
import { date, pgTable } from "drizzle-orm/pg-core";

const table = pgTable('table', {
    date: date(),
});
```

```sql
CREATE TABLE IF NOT EXISTS "table" (
	"date" date
);
```
</Section>
您可以指定 `date` 或 `string` 推导模式：
```typescript
// 将推导为 date
date: date({ mode: "date" }),

// 将推导为 string
date: date({ mode: "string" }),
```
### 时间间隔
`interval`  
时间跨度

有关更多信息，请参阅官方 PostgreSQL **[文档.](https://www.postgresql.org/docs/current/datatype-datetime.html)** 

<Section>
```typescript
import { interval, pgTable } from "drizzle-orm/pg-core";

const table = pgTable('table', {
    interval1: interval(),
    interval2: interval({ fields: 'day' }),
    interval3: interval({ fields: 'month' , precision: 6 }),
});

```

```sql
CREATE TABLE IF NOT EXISTS "table" (
	"interval1" interval,
	"interval2" interval day,
	"interval3" interval(6) month
);
```
</Section>

## ---

### 点
`point`  
几何点类型

有关更多信息，请参阅官方 PostgreSQL **[文档.](https://www.postgresql.org/docs/current/datatype-geometric.html#DATATYPE-GEOMETRIC-POINTS)** 

类型 `point` 有 2 种从数据库映射的模式：`tuple` 和 `xy`。

- `tuple` 将被接受插入并在选择时映射为一个元组。因此，数据库的 Point(1,2) 将被 Drizzle 视为 [1, 2]。

- `xy` 将被接受插入并在选择时映射为具有 x，y 坐标的对象。因此，数据库的 Point(1,2) 将被 Drizzle 视为 `{ x: 1, y: 2 }`。

<Section>
```typescript
const items = pgTable('items', {
    point: point(),
    pointObj: point({ mode: 'xy' }),
});
```

```sql
CREATE TABLE IF NOT EXISTS "items" (
	"point" point,
	"pointObj" point
);
```
</Section>

### 线
`line`  
几何线类型

有关更多信息，请参阅官方 PostgreSQL **[文档.](https://www.postgresql.org/docs/current/datatype-geometric.html#DATATYPE-LINE)** 

类型 `line` 有 2 种从数据库映射的模式：`tuple` 和 `abc`。

- `tuple` 将被接受插入并在选择时映射为一个元组。因此，数据库的 Line{1,2,3} 将被 Drizzle 视为 [1,2,3]。

- `abc` 将被接受插入并在选择时映射为具有方程式 `Ax + By + C = 0` 的常数 a，b 和 c 的对象。因此，数据库的 Line{1,2,3} 将被 Drizzle 视为 `{ a: 1, b: 2, c: 3 }`。

<Section>
```typescript
const items = pgTable('items', {
    line: line(),
    lineObj: line({ mode: 'abc' }),
});
```

```sql
CREATE TABLE IF NOT EXISTS "items" (
	"line" line,
	"lineObj" line
);
```
</Section>

## ---

### 枚举
`enum` `枚举类型`  
枚举（enum）类型是由静态、排序的一组值组成的数据类型。 
它们等同于许多编程语言支持的枚举类型。 
枚举类型的一个例子可能是一周的天数，或者一组数据的状态值。

有关更多信息，请参阅官方 PostgreSQL **[文档.](https://www.postgresql.org/docs/current/datatype-enum.html)**
<Section>
```typescript
import { pgEnum, pgTable } from "drizzle-orm/pg-core";

export const moodEnum = pgEnum('mood', ['sad', 'ok', 'happy']);

export const table = pgTable('table', {
    mood: moodEnum(),
});
```

```sql
CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');

CREATE TABLE IF NOT EXISTS "table" (
	"mood" mood
);
```
</Section>

## ---

### 自定义数据类型
每个列构建器都有一个 `.$type()` 方法，允许您自定义列的数据类型。

这在处理未知或品牌类型时很有用：
```ts
type UserId = number & { __brand: 'user_id' };
type Data = {
    foo: string;
    bar: number;
};

const users = pgTable('users', {
    id: serial().$type<UserId>().primaryKey(),
    jsonField: json().$type<Data>(),
});
```

### 身份列

<Callout type="info">
要使用此功能，您需要安装 `drizzle-orm@0.32.0` 或更高版本，以及 `drizzle-kit@0.23.0` 或更高版本。
</Callout>

PostgreSQL 支持身份列作为自动生成列的唯一整数值的方式。这些值是使用序列生成的，可以使用 GENERATED AS IDENTITY 子句定义。

**身份列的类型**
- `GENERATED ALWAYS AS IDENTITY`: 数据库始终为列生成值。除非使用 OVERRIDING SYSTEM VALUE 子句，否则不允许手动插入或更新此列。
- `GENERATED BY DEFAULT AS IDENTITY`: 数据库默认生成一个值，但也可以手动插入或更新值。如果提供了手动值，它将替代系统生成的值。

**主要特性**
- 自动值生成：利用序列为每个新行生成唯一值。
- 可自定义序列选项：您可以定义起始值、增量和其他序列选项。
- 支持多个身份列：PostgreSQL 允许每个表有多个身份列。

**限制**
- 手动插入限制：对于定义为 GENERATED ALWAYS AS IDENTITY 的列，手动插入或更新需要使用 OVERRIDING SYSTEM VALUE 子句。
- 序列约束：身份列依赖于序列，必须正确管理以避免冲突或间隔。

**使用示例**
```ts
import { pgTable, integer, text } from 'drizzle-orm/pg-core'; 

export const ingredients = pgTable("ingredients", {
    id: integer().primaryKey().generatedAlwaysAsIdentity({ startWith: 1000 }),
    name: text().notNull(),
    description: text(),
});
```

您可以在 `.generatedAlwaysAsIdentity()` 函数中指定序列的所有可用属性。此外，您还可以为这些序列指定自定义名称。

[PostgreSQL 文档参考](https://www.postgresql.org/docs/current/sql-createtable.html#SQL-CREATETABLE-PARMS-GENERATED-IDENTITY)。

### 默认值
`DEFAULT` 子句指定在用户执行
`INSERT` 时未显式提供值的情况下使用的默认值。
如果列定义中未附加显式的 `DEFAULT` 子句，
则列的默认值为 `NULL`。

显式的 `DEFAULT` 子句可以指定默认值为 `NULL`、
字符串常量、blob 常量、带符号的数字或用括号括起的任何常量表达式。

<Section>
```typescript
import { sql } from "drizzle-orm";
import { integer, pgTable, uuid } from "drizzle-orm/pg-core";

const table = pgTable('table', {
    integer1: integer().default(42),
    integer2: integer().default(sql`'42'::integer`),
    uuid1: uuid().defaultRandom(),
    uuid2: uuid().default(sql`gen_random_uuid()`),
});
```

```sql
CREATE TABLE IF NOT EXISTS "table" (
    "integer1" integer DEFAULT 42,
    "integer2" integer DEFAULT '42'::integer,
    "uuid1" uuid DEFAULT gen_random_uuid(),
    "uuid2" uuid DEFAULT gen_random_uuid()
);
```
</Section>

当使用 `$default()` 或 `$defaultFn()` 时，这两个方法只是同一个函数的不同别名， 
您可以在运行时生成默认值并在所有插入查询中使用这些值。

这些函数可以帮助您利用各种实现，例如 `uuid`、`cuid`、`cuid2` 等等。

<Callout type="info" emoji="ℹ️">
    注意：此值不会影响 `drizzle-kit` 的行为，它仅在运行时用于 `drizzle-orm`。
</Callout>

```ts
import { text, pgTable } from "drizzle-orm/pg-core";
import { createId } from '@paralleldrive/cuid2';

const table = pgTable('table', {
    id: text().$defaultFn(() => createId()),
});
```

当使用 `$onUpdate()` 或 `$onUpdateFn()` 时，这两个函数只是同一个函数的不同别名， 
您可以在运行时生成默认值并在所有更新查询中使用这些值。 

它向列添加动态更新值。该函数将在行更新时调用，
返回的值将用作列值（如果未提供）。
如果未提供默认值（或 $defaultFn）值，
则该函数在行插入时也会被调用，返回的值将用作列值。

<Callout type="info" emoji="ℹ️">
    注意：此值不会影响 `drizzle-kit` 的行为，它仅在运行时用于 `drizzle-orm`。
</Callout>

```ts
import { integer, timestamp, text, pgTable } from "drizzle-orm/pg-core";

const table = pgTable('table', {
    updateCounter: integer().default(sql`1`).$onUpdateFn((): SQL => sql`${table.update_counter} + 1`),
    updatedAt: timestamp({ mode: 'date', precision: 3 }).$onUpdate(() => new Date()),
    alwaysNull: text().$type<string | null>().$onUpdate(() => null),
});
```


### 非空
`NOT NULL` 约束规定相关列不得包含 `NULL` 值。

<Section>
```typescript
import { integer, pgTable } from "drizzle-orm/pg-core";

const table = pgTable('table', {
    integer: integer().notNull(),
});
```

```sql
CREATE TABLE IF NOT EXISTS "table" (
	"integer" integer NOT NULL
);
```
</Section>


### 主键
主键约束表示列或列组可用作表中行的唯一标识符。 
这要求值既独特又非空。
<Section>
```typescript
import { serial, pgTable } from "drizzle-orm/pg-core";

const table = pgTable('table', {
    id: serial().primaryKey(),
});
```

```sql
CREATE TABLE IF NOT EXISTS "table" (
	"id" serial PRIMARY KEY NOT NULL
);
```
</Section>


Source: https://drizzle.zhcndoc.com/docs/column-types/singlestore

import Section from '@mdx/Section.astro';
import Callout from '@mdx/Callout.astro';

我们对所有类型均有原生支持，如果这些还不能满足您的需求，请随时创建 **[自定义类型](/docs/custom-types)**。

<Callout title='重要' type='warning'>
本章节文档中的所有示例均未使用数据库列名别名，列名均由 TypeScript 键名生成。

如果您愿意，可以在列名中使用数据库别名，也可以使用 `casing` 参数为 Drizzle 定义映射策略。

您可在此处了解更多内容 [here](/docs/sql-schema-declaration#shape-your-data-schema)
</Callout>

### integer

有符号整数，根据值的大小，存储在 `0`、`1`、`2`、`3`、`4`、`6` 或 `8` 字节中。

<Section>
```typescript
import { int, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	int: int()
});
```

```sql
CREATE TABLE `table` (
	`int` int
);
```
</Section>

### tinyint

<Section>
```typescript
import { tinyint, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	tinyint: tinyint()
});
```

```sql
CREATE TABLE `table` (
	`tinyint` tinyint
);
```
</Section>

### smallint

<Section>
```typescript
import { smallint, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	smallint: smallint()
});
```

```sql
CREATE TABLE `table` (
	`smallint` smallint
);
```
</Section>

### mediumint

<Section>
```typescript
import { mediumint, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	mediumint: mediumint()
});
```

```sql
CREATE TABLE `table` (
	`mediumint` mediumint
);
```
</Section>

### bigint

<Section>
```typescript
import { bigint, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	bigint: bigint({ mode: 'number' })
	bigintUnsigned: bigint({ mode: 'number', unsigned: true })
});

bigint('...', { mode: 'number' | 'bigint' });

// 也可以为 bigint 指定 unsigned 选项
bigint('...', { mode: 'number' | 'bigint', unsigned: true })
```

```sql
CREATE TABLE `table` (
	`bigint` bigint,
	`bigintUnsigned` bigint unsigned
);
```
</Section>

我们省略了 `bigint(M)` 中的 `M` 配置，因为它表示数字类型的显示宽度。

## ---

### real

<Section>
```typescript
import { real, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	real: real()
});
```

```sql
CREATE TABLE `table` (
	`real` real
);
```
</Section>

<Section>
```typescript
import { real, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	realPrecision: real({ precision: 1,}),
	realPrecisionScale: real({ precision: 1, scale: 1,}),
});
```

```sql
CREATE TABLE `table` (
	`realPrecision` real(1),
	`realPrecisionScale` real(1, 1)
);
```
</Section>

### decimal

<Section>
```typescript
import { decimal, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	decimal: decimal(),
	decimalNum: decimal({ scale: 30, mode: 'number' }),
	decimalBig: decimal({ scale: 30, mode: 'bigint' }),
});
```

```sql
CREATE TABLE `table` (
	`decimal` decimal,
	`decimalNum` decimal(30),
	`decimalBig` decimal(30)
);
```
</Section>

<Section>
```typescript
import { decimal, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	decimalPrecision: decimal({ precision: 1,}),
	decimalPrecisionScale: decimal({ precision: 1, scale: 1,}),
});
```

```sql
CREATE TABLE `table` (
	`decimalPrecision` decimal(1),
	`decimalPrecisionScale` decimal(1, 1)
);
```
</Section>

### double

<Section>
```typescript
import { double, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	double: double('double')
});
```

```sql
CREATE TABLE `table` (
	`double` double
);
```
</Section>

<Section>
```typescript
import { double, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	doublePrecision: double({ precision: 1,}),
	doublePrecisionScale: double({ precision: 1, scale: 1,}),
});
```

```sql
CREATE TABLE `table` (
	`doublePrecision` double(1),
	`doublePrecisionScale` double(1, 1)
);
```
</Section>

### float

<Section>
```typescript
import { float, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	float: float()
});
```

```sql
CREATE TABLE `table` (
	`float` float
);
```
</Section>

## ---

### serial

<Section>

`SERIAL` 是 `BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE` 的别名。

```typescript
import { serial, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	serial: serial()
});
```

```sql
CREATE TABLE `table` (
	`serial` serial AUTO_INCREMENT
);
```
</Section>

## ---

### binary

<Section>
```typescript
import { binary, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	binary: binary()
});
```

```sql
CREATE TABLE `table` (
	`binary` binary
);
```
</Section>

### varbinary

<Section>
```typescript
import { varbinary, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	varbinary: varbinary({ length: 2}),
});
```

```sql
CREATE TABLE `table` (
	`varbinary` varbinary(2)
);
```
</Section>

## ---

### char

<Section>
```typescript
import { char, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	char: char(),
});
```

```sql
CREATE TABLE `table` (
	`char` char
);
```
</Section>

### varchar
您可以定义 `{ enum: ["value1", "value2"] }` 配置以推断 `insert` 和 `select` 类型，但它 **不会** 在运行时检查值。
<Section>
```typescript
import { varchar, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	varchar: varchar({ length: 2 }),
});

// 推断为文本类型: "value1" | "value2" | null
varchar: varchar({ length: 6, enum: ["value1", "value2"] })
```

```sql
CREATE TABLE `table` (
	`varchar` varchar(2)
);
```
</Section>

### text

您可以定义 `{ enum: ["value1", "value2"] }` 配置以推断 `insert` 和 `select` 类型，但它 **不会** 在运行时检查值。

<Section>
```typescript
import { text, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	text: text(),
});

// 推断为文本类型: "value1" | "value2" | null
text: text({ enum: ["value1", "value2"] });
```

```sql
CREATE TABLE `table` (
	`text` text
);
```
</Section>

## ---

### boolean

<Section>
```typescript
import { boolean, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	boolean: boolean(),
});
```

```sql
CREATE TABLE `table` (
	`boolean` boolean
);
```
</Section>

## ---

### date

<Section>
```typescript
import { boolean, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	date: date(),
});
```

```sql
CREATE TABLE `table` (
	`date` date
);
```
</Section>

### datetime

<Section>
```typescript
import { datetime, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	datetime: datetime(),
});

datetime('...', { mode: 'date' | "string"}),
```

```sql
CREATE TABLE `table` (
	`datetime` datetime
);
```
</Section>

### time 

<Section>
```typescript
import { time, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	time: time(),
});
```

```sql
CREATE TABLE `table` (
	`time` time
);
```
</Section>

### year

<Section>
```typescript
import { year, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	year: year(),
});
```

```sql
CREATE TABLE `table` (
	`year` year
);
```
</Section>

### timestamp

<Section>
```typescript
import { timestamp, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	timestamp: timestamp(),
});

timestamp('...', { mode: 'date' | "string"}),
```

```sql
CREATE TABLE `table` (
	`timestamp` timestamp
);
```
</Section>

<Section>
```typescript
import { timestamp, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	timestamp: timestamp().defaultNow(),
});
```

```sql
CREATE TABLE `table` (
	`timestamp` timestamp DEFAULT (now())
);
```
</Section>

## ---

### json

<Section>
```typescript
import { json, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	json: json(),
});

```

```sql
CREATE TABLE `table` (
	`json` json
);
```
</Section>

您可以指定 `.$type<..>()` 来推断 json 对象类型，但它 **不会** 在运行时校验值。
此功能为默认值、插入和查询的类型提供编译时保护。
```typescript
// 推断为 { foo: string }
json: json().$type<{ foo: string }>();

// 推断为 string[]
json: json().$type<string[]>();

// 无法编译
json: json().$type<string[]>().default({});
```

## ---

### enum

<Section>
```typescript
import { singlestoreEnum, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	popularity: singlestoreEnum(['unknown', 'known', 'popular']),
});
```

```sql
CREATE TABLE `table` (
	`popularity` enum('unknown','known','popular')
);
```
</Section>

## ---

### 自定义数据类型

每个列构建器都拥有 `.$type()` 方法，允许您自定义列的数据类型。这在使用未知类型或标记类型时非常有用。

```ts
type UserId = number & { __brand: 'user_id' };
type Data = {
	foo: string;
	bar: number;
};

const users = singlestoreTable('users', {
  id: int().$type<UserId>().primaryKey(),
  jsonField: json().$type<Data>(),
});
```

### 非空

`NOT NULL` 约束规定表中对应列不可包含 `NULL` 值。

<Section>
```typescript
import { int, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	int: int().notNull(),
});
```

```sql
CREATE TABLE `table` (
	`int` int NOT NULL
);
```
</Section>

### 默认值

`DEFAULT` 子句指定在 `INSERT` 操作时若用户未提供明确值，列默认使用的值。
若定义时未显式指定 `DEFAULT` 子句，默认值为 `NULL`。

显式的 `DEFAULT` 子句允许指定默认值为 `NULL`、字符串常量、二进制常量、带符号数字或任意括号括起的常量表达式。

<Section>
```typescript
import { int, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	int: int().default(3),
});
```

```sql
CREATE TABLE `table` (
	`int` int DEFAULT 3
);
```
</Section>

使用 `$default()` 或 `$defaultFn()` 可在运行时生成默认值，并在所有插入查询中使用这些值。它们是同一函数的不同别名。
这些函数帮助您使用 `uuid`、`cuid`、`cuid2` 等多种实现。

<Callout type="info" emoji="ℹ️">
	注意：此值不影响 `drizzle-kit` 行为，仅在 `drizzle-orm` 运行时使用。
</Callout>

```ts
import { varchar, singlestoreTable } from "drizzle-orm/singlestore-core";
import { createId } from '@paralleldrive/cuid2';

const table = singlestoreTable('table', {
	id: varchar({ length: 128 }).$defaultFn(() => createId()),
});
```

使用 `$onUpdate()` 或 `$onUpdateFn()` 可在更新行时生成动态值。这两个是同一函数的不同别名。

该函数将在行更新时调用，若未提供该列值，使用函数返回值作为值。
如果未提供默认值（`$default` 或 `$defaultFn`），该函数在插入时也会被调用，使用返回值作为列值。

<Callout type="info" emoji="ℹ️">
	注意：此值不影响 `drizzle-kit` 行为，仅在 `drizzle-orm` 运行时使用。
</Callout>

```ts
import { text, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
    alwaysNull: text().$type<string | null>().$onUpdate(() => null),
});
```

### 主键

<Section>
```typescript
import { int, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	int: int().primaryKey(),
});
```

```sql
CREATE TABLE `table` (
	`int` int PRIMARY KEY NOT NULL
);
```
</Section>

### 自增

<Section>
```typescript
import { int, singlestoreTable } from "drizzle-orm/singlestore-core";

const table = singlestoreTable('table', {
	int: int().autoincrement(),
});
```

```sql
CREATE TABLE `table` (
	`int` int AUTO_INCREMENT
);
```
</Section>

Source: https://drizzle.zhcndoc.com/docs/column-types/sqlite


import Section from '@mdx/Section.astro';
import Callout from '@mdx/Callout.astro';

根据官方 **[SQLite 文档](https://www.sqlite.org/datatype3.html)**，
每个存储在 SQLite 数据库中的值（或被数据库引擎操作的值）
都具有以下存储类别之一：`NULL`、`INTEGER`、`REAL`、`TEXT` 和 `BLOB`。

我们对它们都提供了原生支持，如果这还不够，欢迎创建 **[自定义类型](/docs/custom-types)**。

<Callout title='important' type='warning'>
本部分文档中的所有示例均未使用数据库列名别名，列名是从 TypeScript 键生成的。

如果需要，您可以在列名中使用数据库别名，并且您还可以使用 `casing` 参数为 Drizzle 定义映射策略。

您可以在 [这里](/docs/sql-schema-declaration#shape-your-data-schema) 了解更多信息。
</Callout>

### 整数

一个有符号整数，存储为 `0`、`1`、`2`、`3`、`4`、`6` 或 `8` 字节，具体取决于值的大小。

<Section>
```typescript
import { integer, sqliteTable } from "drizzle-orm/sqlite-core";

const table = sqliteTable('table', {
	id: integer()
});

// 您可以自定义整数模式为 number、boolean、timestamp、timestamp_ms
integer({ mode: 'number' })
integer({ mode: 'boolean' })
integer({ mode: 'timestamp_ms' })
integer({ mode: 'timestamp' }) // Date

```

```sql
CREATE TABLE `table` (
	`id` integer
);
```

</Section>

<Section>
```typescript
// 使整数主键自动递增
integer({ mode: 'number' }).primaryKey({ autoIncrement: true })
```
```sql
CREATE TABLE `table` (
	`id` integer PRIMARY KEY AUTOINCREMENT NOT NULL
);
```
</Section>

### 实数

一个浮点值，存储为 `8-byte IEEE` 浮点数。

<Section>
```typescript
import { real, sqliteTable } from "drizzle-orm/sqlite-core";

const table = sqliteTable('table', {
	real: real()
});

```

```sql
CREATE TABLE `table` (
	`real` real
);
```

</Section>

### 文本

一个文本字符串，使用数据库编码（`UTF-8`、`UTF-16BE` 或 `UTF-16LE`）存储。

<Callout type="info" emoji="ℹ️">
	您可以定义 `{ enum: ["value1", "value2"] }` 配置来推导 `insert` 和 `select` 类型，它 **不会** 检查运行时值。
</Callout>

<Section>
```typescript
import { text, sqliteTable } from "drizzle-orm/sqlite-core";

const table = sqliteTable('table', {
	text: text()
});

// 将推导为 text: "value1" | "value2" | null
text({ enum: ["value1", "value2"] })
text({ mode: 'json' })
text({ mode: 'json' }).$type<{ foo: string }>()
```

```sql
CREATE TABLE `table` (
	`text` text
);
```

</Section>

### BLOB

一个数据块，准确地按照输入存储。

<Callout type="info" emoji="ℹ️">
	建议使用 `text('', { mode: 'json' })` 而不是 `blob('', { mode: 'json' })`， 
	因为它支持 JSON 函数：

	目前所有 JSON 函数在其任何参数为 BLOB 时都会抛出错误，
	因为 BLOB 保留用于将来增强功能，其中 BLOB 将存储 JSON 的二进制编码。

	请参阅 **https://www.sqlite.org/json1.html**。
</Callout>

<Section>
```typescript
import { blob, sqliteTable } from "drizzle-orm/sqlite-core";

const table = sqliteTable('table', {
	blob: blob()
});

blob()
blob({ mode: 'buffer' })
blob({ mode: 'bigint' })

blob({ mode: 'json' })
blob({ mode: 'json' }).$type<{ foo: string }>()

```

```sql
CREATE TABLE `table` (
	`blob` blob
);
```

您可以为 blob 推导指定 `.$type<..>()`，它 **不会** 检查运行时值。
它为默认值、插入和选择模式提供编译时保护。

```typescript
// 将推导为 { foo: string }
json: blob({ mode: 'json' }).$type<{ foo: string }>();

// 将推导为 string[]
json: blob({ mode: 'json' }).$type<string[]>();

// 不会编译
json: blob({ mode: 'json' }).$type<string[]>().default({});
```

</Section>

### 布尔值

SQLite 没有原生的 `boolean` 数据类型，但您可以指定 `integer` 列为 `boolean` 模式。
这使您能够在代码中操作布尔值，
Drizzle 将它们存储为数据库中的 0 和 1 整数值。


<Section>
```typescript
import { integer, sqliteTable } from "drizzle-orm/sqlite-core";

const table = sqliteTable('table', {
	id: integer({ mode: 'boolean' })
});
```

```sql
CREATE TABLE `table` (
	`id` integer
);
```

</Section>

### 大整数

由于 SQLite 中没有 `bigint` 数据类型，Drizzle 为 `blob` 列提供了一种特殊的 `bigint` 模式。
这种模式允许您在代码中处理 BigInt 实例，而 Drizzle 将它们作为 blob 值存储在数据库中。


<Section>
```typescript
import { blob, sqliteTable } from "drizzle-orm/sqlite-core";

const table = sqliteTable('table', {
	id: blob({ mode: 'bigint' })
});

```

```sql
CREATE TABLE `table` (
	`id` blob
);
```
</Section>

### Numeric

<Section>
```typescript
import { blob, sqliteTable } from "drizzle-orm/sqlite-core";

const table = sqliteTable('table', {
	numeric: numeric(),
	numericNum: numeric({ mode: 'number' }),
	numericBig: numeric({ mode: 'bigint' }),
});

```

```sql
CREATE TABLE `table` (
	`numeric` numeric,
	`numericNum` numeric,
	`numericBig` numeric
);
```
</Section>

## ---

### 自定义数据类型
每个列构建器都有一个 `.$type()` 方法，可以让您自定义列的数据类型。这在处理未知或品牌类型时非常有用。
```ts
type UserId = number & { __brand: 'user_id' };
type Data = {
	foo: string;
	bar: number;
};

const users = sqliteTable('users', {
  id: integer().$type<UserId>().primaryKey(),
  jsonField: blob().$type<Data>(),
});
```

### 非空
`NOT NULL` 约束指示关联列不得包含 `NULL` 值。
<Section>
```typescript
const table = sqliteTable('table', { 
	numInt: integer().notNull() 
});
```

```sql
CREATE TABLE table (
	`numInt` integer NOT NULL
);
```
</Section>

### 默认值

`DEFAULT` 子句指定在用户在执行 `INSERT` 
操作时未明确提供值时，使用的默认值。
如果列定义中没有明确的 `DEFAULT` 子句，
则列的默认值为 `NULL`。

一个明确的 `DEFAULT` 子句可以指定默认值为 `NULL`、
字符串常量、blob 常量、有符号数字或任何用括号括起来的常量表达式。

<Section>
```typescript
import { sql } from "drizzle-orm";
import { integer, sqliteTable } from "drizzle-orm/sqlite-core";

const table = sqliteTable('table', {
	int1: integer().default(42),
	int2: integer().default(sql`(abs(42))`)
});

```
```sql
CREATE TABLE `table` (
	`int1` integer DEFAULT 42,
	`int2` integer DEFAULT (abs(42))
);
```
</Section>

默认值也可以是不区分大小写的特殊关键字 `CURRENT_TIME`、`CURRENT_DATE` 或 `CURRENT_TIMESTAMP`。

<Section>
```typescript
import { sql } from "drizzle-orm";
import { text, sqliteTable } from "drizzle-orm/sqlite-core";

const table = sqliteTable("table", {
  time: text().default(sql`(CURRENT_TIME)`),
  date: text().default(sql`(CURRENT_DATE)`),
  timestamp: text().default(sql`(CURRENT_TIMESTAMP)`),
});
```

```sql
CREATE TABLE `table` (
	`time` text DEFAULT (CURRENT_TIME),
	`date` text DEFAULT (CURRENT_DATE),
	`timestamp` text DEFAULT (CURRENT_TIMESTAMP)
);
```
</Section>

使用 `$default()` 或 `$defaultFn()`，它们只是同一函数的不同别名，
您可以在运行时生成默认值并在所有插入查询中使用这些值。
这些函数可以帮助您利用各种实现，例如 `uuid`、`cuid`、`cuid2` 等等。

<Callout type="info" emoji="ℹ️">
	注意：该值不影响 `drizzle-kit` 的行为，它仅在 `drizzle-orm` 中用于运行时。
</Callout>

```ts
import { text, sqliteTable } from "drizzle-orm/sqlite-core";
import { createId } from '@paralleldrive/cuid2';

const table = sqliteTable('table', {
	id: text().$defaultFn(() => createId()),
});
```

使用 `$onUpdate()` 或 `$onUpdateFn()`，它们只是同一函数的不同别名，
您可以在运行时生成默认值并在所有更新查询中使用这些值。

向该列添加动态更新值。当行被更新时，将调用该函数，
如果未提供任何值，则返回的值将用作列值。
如果未提供默认值（或 $defaultFn 值），
当行被插入时也会调用该函数，并且返回的值将用作列值。

<Callout type="info" emoji="ℹ️">
	注意：该值不影响 `drizzle-kit` 的行为，它仅在 `drizzle-orm` 中用于运行时。
</Callout>

```ts
import { text, sqliteTable } from "drizzle-orm/sqlite-core";

const table = sqliteTable('table', {
    alwaysNull: text().$type<string | null>().$onUpdate(() => null),
});
```


Source: https://drizzle.zhcndoc.com/docs/connect-aws-data-api-mysql

import Callout from '@mdx/Callout.astro';


# Drizzle \<\> AWS 数据 API MySQL

<Callout>
目前 AWS 数据 API for MySQL 在 Drizzle ORM 中尚未实现
</Callout>

Source: https://drizzle.zhcndoc.com/docs/connect-aws-data-api-pg

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";

# Drizzle \<\> AWS 数据 API Postgres

<Prerequisites>
- 数据库 [连接基础](/docs/connect-overview) 与 Drizzle
- AWS 数据 API - [官网](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/data-api.html)
- AWS SDK - [官网](https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/Package/-aws-sdk-client-rds-data/)
</Prerequisites>

#### 第一步 - 安装包
<Npm>
drizzle-orm @aws-sdk/client-rds-data
-D drizzle-kit
</Npm>

#### 第二步 - 初始化驱动程序并进行查询
```typescript copy
import { drizzle } from 'drizzle-orm/aws-data-api/pg';

// 这三个属性是必需的。您也可以在连接对象中指定
// RDSDataClient 类型的任何属性。
const db = drizzle({ connection: {
  database: process.env['DATABASE']!,
  secretArn: process.env['SECRET_ARN']!,
  resourceArn: process.env['RESOURCE_ARN']!,
}});

await db.select().from(...);
```

如果您需要提供您现有的驱动程序：

```typescript copy
import { drizzle } from 'drizzle-orm/aws-data-api/pg';
import { RDSDataClient } from '@aws-sdk/client-rds-data';

const rdsClient = new RDSDataClient({ region: 'us-east-1' });

const db = drizzle(rdsClient, {
  database: process.env['DATABASE']!,
  secretArn: process.env['SECRET_ARN']!,
  resourceArn: process.env['RESOURCE_ARN']!,
});

await db.select().from(...);
```

#### 接下来是什么？

<WhatsNextPostgres/>


Source: https://drizzle.zhcndoc.com/docs/connect-bun-sql

import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Steps from '@mdx/Steps.astro';
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";

# Drizzle \<\> Bun SQL

<Prerequisites>
- 数据库 [连接基础](/docs/connect-overview) 与 Drizzle
- Bun - [网站](https://bun.sh/docs)
- Bun SQL - 用于处理 PostgreSQL 数据库的原生绑定 - [在这里阅读](https://bun.sh/docs/api/sql)
</Prerequisites>

根据 **[官方网站](https://bun.sh/)**，Bun 是一个快速的全功能 JavaScript 运行时。

Drizzle ORM 原生支持 **[`bun sql`](https://bun.sh/docs/api/sql)** 模块，速度非常快 🚀

#### 步骤 1 - 安装软件包
<Npm>
drizzle-orm
-D drizzle-kit
</Npm>

#### 步骤 2 - 初始化驱动程序并进行查询
```typescript copy
import 'dotenv/config';
import { drizzle } from 'drizzle-orm/bun-sql';

const db = drizzle(process.env.DATABASE_URL);

const result = await db.select().from(...);
```

如果您需要提供现有的驱动程序：
```typescript copy
import 'dotenv/config';
import { drizzle } from 'drizzle-orm/bun-sql';
import { SQL } from 'bun';

const client = new SQL(process.env.DATABASE_URL!);
const db = drizzle({ client });
```

#### 接下来是什么？

<WhatsNextPostgres/>


Source: https://drizzle.zhcndoc.com/docs/connect-bun-sqlite

import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Steps from '@mdx/Steps.astro';
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";

# Drizzle \<\> Bun SQLite

<Prerequisites>
- 数据库 [连接基础](/docs/connect-overview) 与 Drizzle
- Bun - [网站](https://bun.sh/docs)
- Bun SQLite 驱动 - [文档](https://bun.sh/docs/api/sqlite)
</Prerequisites>

根据 **[官方网站](https://bun.sh/)**，Bun 是一个快速的全能 JavaScript 运行时。

Drizzle ORM 原生支持 **[`bun:sqlite`](https://bun.sh/docs/api/sqlite)** 模块，速度非常快 🚀

我们支持 SQL 方言以及特定方言的驱动程序和语法，与其他 ORM 不同，

对于像 `bun:sqlite` 这样的同步驱动，我们提供了 **async** 和 **sync** API，并且我们镜像了最流行的

SQLite 类的 `all`、`get`、`values` 和 `run` 查询方法的语法。

#### 步骤 1 - 安装软件包
<Npm>
drizzle-orm
-D drizzle-kit
</Npm>

#### 步骤 2 - 初始化驱动并执行查询
```typescript copy
import { drizzle } from 'drizzle-orm/bun-sqlite';

const db = drizzle();

const result = await db.select().from(...);
```

如果您需要提供现有的驱动程序：
```typescript copy
import { drizzle } from 'drizzle-orm/bun-sqlite';
import { Database } from 'bun:sqlite';

const sqlite = new Database('sqlite.db');
const db = drizzle({ client: sqlite });

const result = await db.select().from(...);
```

如果你想使用 **同步** API：
```typescript copy
import { drizzle } from 'drizzle-orm/bun-sqlite';
import { Database } from 'bun:sqlite';

const sqlite = new Database('sqlite.db');
const db = drizzle({ client: sqlite });

const result = db.select().from(users).all();
const result = db.select().from(users).get();
const result = db.select().from(users).values();
const result = db.select().from(users).run();
```

#### 接下来做什么？

<WhatsNextPostgres/>

Source: https://drizzle.zhcndoc.com/docs/connect-cloudflare-d1

import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Steps from '@mdx/Steps.astro';
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";

# Drizzle \<\> Cloudflare D1

<Prerequisites>
- 数据库 [连接基础](/docs/connect-overview) 与 Drizzle
- D1 数据库 - [官网](https://developers.cloudflare.com/d1/)
- D1 驱动 - [官网](https://developers.cloudflare.com/d1/build-with-d1/d1-client-api/)
</Prerequisites>

根据 **[官方网站](https://developers.cloudflare.com/d1/)**，  
D1 是 Cloudflare 首个可查询的关系数据库。  
  
Drizzle ORM 完全支持 Cloudflare D1 数据库和 Cloudflare Workers 环境。  
我们支持 SQL 方言以及特定驱动和语法，
并且映射大多数流行的 SQLite 类 `all`、`get`、`values` 和 `run` 查询方法的语法。

要为您的 Cloudflare D1 设置项目，请参考 **[官方文档。](https://developers.cloudflare.com/d1/)**

#### 第一步 - 安装包
<Npm>
drizzle-orm
-D drizzle-kit
</Npm>

#### 第二步 - 初始化驱动并进行查询

您需要有一个 `wrangler.json` 或 `wrangler.toml` 文件用于 D1 数据库，内容大致如下：
<CodeTabs items={["wrangler.json", "wrangler.toml"]}>
```json
{
    "name": "YOUR_PROJECT_NAME",
    "main": "src/index.ts",
    "compatibility_date": "2024-09-26",
    "compatibility_flags": [
        "nodejs_compat"
    ],
    "d1_databases": [
        {
            "binding": "BINDING_NAME",
            "database_name": "YOUR_DB_NAME",
            "database_id": "YOUR_DB_ID",
            "migrations_dir": "drizzle/migrations"
        }
    ]
}
```
```toml
name = "YOUR_PROJECT_NAME"
main = "src/index.ts"
compatibility_date = "2022-11-07"
node_compat = true

[[ d1_databases ]]
binding = "BINDING_NAME"
database_name = "YOUR_DB_NAME"
database_id = "YOUR_DB_ID"
migrations_dir = "drizzle/migrations"
```
</CodeTabs>

进行您的第一个 D1 查询：
```typescript copy
import { drizzle } from 'drizzle-orm/d1';

export interface Env {
  <绑定名称>: D1Database;
}

export default {
  async fetch(request: Request, env: Env) {
    const db = drizzle(env.<绑定名称>);
    const result = await db.select().from(users).all()
    return Response.json(result);
  },
};
```

#### 接下来是什么？

<WhatsNextPostgres/>

Source: https://drizzle.zhcndoc.com/docs/connect-cloudflare-do

import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Steps from '@mdx/Steps.astro';
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";

# Drizzle \<\> Cloudflare Durable Objects SQLite

<Prerequisites>
- 使用 Drizzle 的数据库[连接基础](/docs/connect-overview)
- **Cloudflare SQLite Durable Objects** - 嵌入在 Durable Object 中的 SQLite 数据库 - [详情请阅读](https://developers.cloudflare.com/durable-objects/best-practices/access-durable-objects-storage/#sqlite-storage-backend)
</Prerequisites>
  
Drizzle ORM 完全支持 Cloudflare Durable Objects 数据库和 Cloudflare Workers 环境。
我们支持 SQL 方言及特定驱动与语法，并且支持大多数流行的类似 SQLite 的 `all`、`get`、`values` 和 `run` 查询方法语法。

要为您的 Cloudflare Durable Objects 设置项目，请参阅 **[官方文档。](https://developers.cloudflare.com/durable-objects)**

#### 第一步 - 安装包
<Npm>
drizzle-orm
-D drizzle-kit
</Npm>

#### 第二步 - 初始化驱动并执行查询

您需要为 Durable Objects 数据库创建一个 `wrangler.toml` 文件，内容大致如下：
```toml {16-18,21-24}
#:schema node_modules/wrangler/config-schema.json
name = "sqlite-durable-objects"
main = "src/index.ts"
compatibility_date = "2024-11-12"
compatibility_flags = [ "nodejs_compat" ]

# 绑定 Durable Object。Durable Object 是一种基于 actor 模型的可随需缩放计算原语。
# Durable Object 可以长时间运行。适用于需要长时间运行“服务器”的场景，如实时应用。
# 文档：https://developers.cloudflare.com/workers/wrangler/configuration/#durable-objects
[[durable_objects.bindings]]
name = "MY_DURABLE_OBJECT"
class_name = "MyDurableObject"

# Durable Object 迁移。
# 文档：https://developers.cloudflare.com/workers/wrangler/configuration/#migrations
[[migrations]]
tag = "v1"
new_sqlite_classes = ["MyDurableObject"]

# 我们需要规则以便下一步导入迁移文件
[[rules]] 
type = "Text"
globs = ["**/*.sql"]
fallthrough = true
```

执行您的第一个 Durable Objects SQLite 查询：
```typescript copy
/// <reference types="@cloudflare/workers-types" />
import { drizzle, DrizzleSqliteDODatabase } from 'drizzle-orm/durable-sqlite';
import { DurableObject } from 'cloudflare:workers'
import { migrate } from 'drizzle-orm/durable-sqlite/migrator';
import migrations from '../drizzle/migrations';
import { usersTable } from './db/schema';

export class MyDurableObject extends DurableObject {
	storage: DurableObjectStorage;
	db: DrizzleSqliteDODatabase<any>;

	constructor(ctx: DurableObjectState, env: Env) {
		super(ctx, env);
		this.storage = ctx.storage;
		this.db = drizzle(this.storage, { logger: false });

		// 确保所有迁移完成后再接受查询。
		// 否则，任何访问 Drizzle 数据库 `this.db` 的函数中都需调用 `this.migrate()`。
		ctx.blockConcurrencyWhile(async () => {
			await this._migrate();
		});
	}

	async insertAndList(user: typeof usersTable.$inferInsert) {
		await this.insert(user);
		return this.select();
	}

	async insert(user: typeof usersTable.$inferInsert) {
		await this.db.insert(usersTable).values(user);
	}

	async select() {
		return this.db.select().from(usersTable);
	}

	async _migrate() {
		migrate(this.db, migrations);
	}
}

export default {
	/**
	 * 这是 Cloudflare Worker 的标准 fetch 处理函数
	 *
	 * @param request - 客户端提交到 Worker 的请求
	 * @param env - 用于引用 wrangler.toml 中声明的绑定
	 * @param ctx - Worker 的执行上下文
	 * @returns 返回给客户端的响应
	 */
	async fetch(request: Request, env: Env): Promise<Response> {
		const id: DurableObjectId = env.MY_DURABLE_OBJECT.idFromName('durable-object');
		const stub = env.MY_DURABLE_OBJECT.get(id);

		// 选项 A - 最大性能。
		// 将所有数据库操作打包在单个 Durable Object 调用中以获得最大性能，
		// 因为在 DO 内部访问数据库非常快。
		const usersAll = await stub.insertAndList({
			name: 'John',
			age: 30,
			email: 'john@example.com',
		});
		console.log('新用户已创建。从数据库获取所有用户: ', users);

		// 选项 B - 速度较慢但有时对调试有用。
		// 也可以直接调用单个暴露的 Drizzle 查询，
		// 但请注意，每次查询都相当于往返调用 Durable Object 实例。
		await stub.insert({
			name: 'John',
			age: 30,
			email: 'john@example.com',
		});
		console.log('新用户已创建！');
	
		const users = await stub.select();
		console.log('从数据库获取所有用户: ', users);

		return Response.json(users);
	}
}
```

#### 下一步是什么？

<WhatsNextPostgres/>

Source: https://drizzle.zhcndoc.com/docs/connect-drizzle-proxy

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import Steps from '@mdx/Steps.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import Section from "@mdx/Section.astro";

# Drizzle HTTP 代理

<Prerequisites>
- 数据库 [连接基础](/docs/connect-overview) 与 Drizzle
</Prerequisites>

HTTP 代理的工作原理以及您可能需要它的原因

Drizzle Proxy 在您需要实现自己的驱动程序与数据库的通信时使用。 
它可以在几种情况下使用，例如在现有驱动程序的查询阶段添加自定义逻辑。 
最常见的用法是与 HTTP 驱动程序一起使用，它将查询发送到您的数据库服务器，执行查询 
并以原始数据响应，Drizzle ORM 然后可以将其映射为结果。

<Callout collapsed="它是如何在底层工作的？">
```                                  
┌───────────────────────────┐                 ┌─────────────────────────────┐              
│       Drizzle ORM         │                 │  带数据库的 HTTP 服务器    │             
└─┬─────────────────────────┘                 └─────────────────────────┬───┘             
  │                                                ^                    │
  │-- 1. 构建查询         2. 发送构建的查询 --│                    │
  │                                                │                    │
  │              ┌───────────────────────────┐     │                    │
  └─────────────>│                           │─────┘                    │ 
                 │      HTTP 代理驱动        │                          │
  ┌──────────────│                           │<─────────────┬───────────┘
  │              └───────────────────────────┘              │
  │                                                  3. 执行查询 + 返回原始结果
  │-- 4. 映射数据并返回        
  │                   
  v
```
</Callout>

Drizzle ORM 还支持简单地使用异步回调函数来执行 SQL。

- `sql` 是带占位符的查询字符串。
- `params` 是参数数组。
- 根据 SQL 语句，`method` 将被设置为 `run`、`all`、`values` 或 `get` 之一。

Drizzle 总是等待返回值为 `{rows: string[][]}` 或 `{rows: string[]}`。

- 当 `method` 为 `get` 时，您应该返回一个作为 `{rows: string[]}` 的值。
- 否则，您应该返回 `{rows: string[][]}`。

<br/>

<CodeTabs items={['PostgreSQL', 'MySQL', 'SQLite']}>
<Section>
```typescript copy
// 驱动程序实现示例
import { drizzle } from 'drizzle-orm/pg-proxy';

const db = drizzle(async (sql, params, method) => {
  try {
    const rows = await axios.post('http://localhost:3000/query', { sql, params, method });

    return { rows: rows.data };
  } catch (e: any) {
    console.error('来自 pg 代理服务器的错误：', e.response.data)
    return { rows: [] };
  }
});
```
```ts
// 服务器实现示例
import { Client } from 'pg';
import express from 'express';

const app = express();

app.use(express.json());
const port = 3000;

const client = new Client('postgres://postgres:postgres@localhost:5432/postgres');

app.post('/query', async (req, res) => {
  const { sql, params, method } = req.body;

  // prevent multiple queries
  const sqlBody = sql.replace(/;/g, '');

  try {
    const result = await client.query({
      text: sqlBody,
      values: params,
      rowMode: method === 'all' ? 'array': undefined,
    });
    res.send(result.rows);
  } catch (e: any) {
    res.status(500).json({ error: e });
  }

  res.status(500).json({ error: 'Unknown method value' });
});

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`);
});
```
</Section>
<Section>
```typescript copy
// 驱动程序实现示例
import { drizzle } from 'drizzle-orm/mysql-proxy';

const db = drizzle(async (sql, params, method) => {
  try {
    const rows = await axios.post('http://localhost:3000/query', { sql, params, method });

    return { rows: rows.data };
  } catch (e: any) {
    console.error('来自 mysql 代理服务器的错误：', e.response.data)
    return { rows: [] };
  }
});
```
```ts
// 服务器实现示例
import * as mysql from 'mysql2/promise';
import express from 'express';

const app = express();

app.use(express.json());
const port = 3000;

const main = async () => {
    const connection = await mysql.createConnection('mysql://root:mysql@127.0.0.1:5432/drizzle');

    app.post('/query', async (req, res) => {
      const { sql, params, method } = req.body;

      // prevent multiple queries
      const sqlBody = sql.replace(/;/g, '');

      try {
            const result = await connection.query({
                sql: sqlBody,
                values: params,
                rowsAsArray: method === 'all',
                typeCast: function(field: any, next: any) {
                    if (field.type === 'TIMESTAMP' || field.type === 'DATETIME' || field.type === 'DATE') {
                        return field.string();
                    }
                    return next();
                },
            });
      } catch (e: any) {
        res.status(500).json({ error: e });
      }

      if (method === 'all') {
        res.send(result[0]);
      } else if (method === 'execute') {
        res.send(result);
      }
      res.status(500).json({ error: 'Unknown method value' });
    });

    app.listen(port, () => {
      console.log(`Example app listening on port ${port}`);
    });
}

main();
```
</Section>
<Section>
```typescript copy
import { drizzle } from 'drizzle-orm/sqlite-proxy';

const db = drizzle(async (sql, params, method) => {
  try {
    const rows = await axios.post('http://localhost:3000/query', { sql, params, method });

    return { rows: rows.data };
  } catch (e: any) {
    console.error('来自 sqlite 代理服务器的错误：', e.response.data)
    return { rows: [] };
  }
});
```

**批量支持**

Sqlite Proxy 支持批量请求，和其他驱动程序的处理方式相同。请查看完整的 [文档](/docs/batch-api)

您需要为批量查询指定特定的回调，并处理对代理服务器的请求：

```ts
import { drizzle } from 'drizzle-orm/sqlite-proxy';

type ResponseType = { rows: any[][] | any[] }[];

const db = drizzle(async (sql, params, method) => {
  // 单查询逻辑。和上面的代码相同
}, async (queries: { sql: string, params: any[], method: 'all' | 'run' | 'get' | 'values'}[]) => {
    try {
      const result: ResponseType = await axios.post('http://localhost:3000/batch', { queries });

      return result;
    } catch (e: any) {
      console.error('Error from sqlite proxy server:', e);
      throw e;
    }
  });
```

然后您可以使用 `db.batch([])` 方法，这将代理所有查询。

<Callout>
  批量响应应为原始值的数组（数组中的数组），顺序与它们发送到代理服务器时相同。
</Callout>

除非您打算手动编写每个 SQL 查询，否则表声明是很有帮助的：
```typescript copy
import { sql } from "drizzle-orm";
import { text, integer, sqliteTable } from "drizzle-orm/sqlite-core";

const users = sqliteTable('users', {
  id: text('id'),
  textModifiers: text('text_modifiers').notNull().default(sql`CURRENT_TIMESTAMP`),
  intModifiers: integer('int_modifiers', { mode: 'boolean' }).notNull().default(false),
});
```
有关列类型的更多详细信息，请参见 **[SQLite 中的列类型在 Drizzle.](/docs/column-types/sqlite)**
</Section>
</CodeTabs>



Source: https://drizzle.zhcndoc.com/docs/connect-expo-sqlite

import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Steps from '@mdx/Steps.astro';


# Drizzle \<\> Expo SQLite
根据 **[官方网站](https://expo.dev/)**，Expo是一个用于开发、构建和发布React Native应用程序的工具生态系统。 
它由Hermes JavaScript运行时和Metro捆绑器提供支持，Drizzle Expo驱动程序旨在原生支持这两者。  
  
Drizzle ORM为Expo SQLite提供了业界最佳的工具包：
- Expo SQLite的原生ORM驱动程序 ✅
- [Drizzle Kit](/docs/kit-overview)支持迁移生成和应用程序中的捆绑 ✅
- [Drizzle Studio](https://github.com/drizzle-team/drizzle-studio-expo)开发工具插件，用于浏览设备数据库 ✅
- 实时查询 ✅
  
<Npm>
drizzle-orm expo-sqlite@next
-D drizzle-kit 
</Npm>

```ts
import { drizzle } from "drizzle-orm/expo-sqlite";
import { openDatabaseSync } from "expo-sqlite";

const expo = openDatabaseSync("db.db");
const db = drizzle(expo);

await db.select().from(users);
```
#### 实时查询
使用 `useLiveQuery` 钩子，您可以使任何Drizzle查询变为响应式：
```ts
import { useLiveQuery, drizzle } from 'drizzle-orm/expo-sqlite';
import { openDatabaseSync } from 'expo-sqlite';
import { Text } from 'react-native';
import * as schema from './schema';

const expo = openDatabaseSync('db.db', { enableChangeListener: true }); // <-- 启用更改监听器
const db = drizzle(expo);

const App = () => {
  // 当数据更改时自动重新渲染
  const { data } = useLiveQuery(db.select().from(schema.users));
  return <Text>{JSON.stringify(data)}</Text>;
};

export default App;
```

#### 使用Drizzle Kit进行Expo SQLite迁移
您可以使用Drizzle Kit进行SQL迁移生成。  
在继续之前，请确保检查[Drizzle迁移](/docs/kit-overview)的工作原理。  
Expo / React Native要求您将SQL迁移捆绑到应用程序中，我们已经为您提供支持。  

<Steps>
#### 安装babel插件
将SQL迁移文件作为字符串直接打包到您的包中是必要的。
```shell
npm install babel-plugin-inline-import
```

#### 更新配置文件。
您需要更新 `babel.config.js`、`metro.config.js` 和 `drizzle.config.ts` 文件
```js filename='babel.config.js'
module.exports = function(api) {
  api.cache(true);

  return {
    presets: ['babel-preset-expo'],
    plugins: [["inline-import", { "extensions": [".sql"] }]] // <-- 添加此项
  };
};
```

```js filename="metro.config.js"
const { getDefaultConfig } = require('expo/metro-config');

/** @type {import('expo/metro-config').MetroConfig} */
const config = getDefaultConfig(__dirname);

config.resolver.sourceExts.push('sql'); // <--- 添加此项

module.exports = config;
```

确保在Drizzle Kit配置中设置 `dialect: 'sqlite'` 和 `driver: 'expo'`
```ts filename="drizzle.config.ts"
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
	schema: './db/schema.ts',
	out: './drizzle',
  dialect: 'sqlite',
	driver: 'expo', // <--- 非常重要
});
```

#### 生成迁移
在创建SQL模式文件和drizzle.config.ts文件后，您可以生成迁移
```bash
npx drizzle-kit generate
```

#### 将迁移添加到您的应用程序
现在您需要从 `./drizzle` 文件夹中将 `migrations.js` 文件导入到您的Expo/React Native应用中。 
您可以使用我们自定义的 `useMigrations` 迁移钩子在应用程序启动时运行迁移，手动在 `useEffect` 钩子中按您希望的方式进行。

```ts filename="App.tsx"
import { drizzle } from "drizzle-orm/expo-sqlite";
import { openDatabaseSync } from "expo-sqlite";
import { useMigrations } from 'drizzle-orm/expo-sqlite/migrator';
import migrations from './drizzle/migrations';

const expoDb = openDatabaseSync("db.db");

const db = drizzle(expoDb);

export default function App() {
  const { success, error } = useMigrations(db, migrations);

  if (error) {
    return (
      <View>
        <Text>迁移错误: {error.message}</Text>
      </View>
    );
  }

  if (!success) {
    return (
      <View>
        <Text>迁移正在进行中...</Text>
      </View>
    );
  }

  return ...你的应用组件;
}
```
</Steps>

Source: https://drizzle.zhcndoc.com/docs/connect-neon

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import Steps from '@mdx/Steps.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import Section from "@mdx/Section.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";

# Drizzle \<\> Neon Postgres
<Prerequisites>
- 数据库 [连接基础](/docs/connect-overview) 与 Drizzle
- Neon 无服务器数据库 - [网站](https://neon.tech)
- Neon 无服务器驱动 - [文档](https://neon.tech/docs/serverless/serverless-driver) & [GitHub](https://github.com/neondatabase/serverless)
- Drizzle PostgreSQL 驱动 - [文档](/docs/get-started-postgresql)
</Prerequisites>

Drizzle 原生支持使用 `neon-http` 和 `neon-websockets` 驱动连接 Neon。这些驱动在底层使用 **neon-serverless** 驱动。  
  
使用 `neon-http` 和 `neon-websockets` 驱动，您可以通过 HTTP 或 WebSockets 从无服务器环境访问 Neon 数据库，而不是通过 TCP。  
通过 HTTP 查询对于单个非交互事务来说速度更快。  
  
如果您需要会话或交互事务支持，或需要一个完全兼容的可替换 `pg` 驱动, 那您可以使用基于 WebSocket 的 `neon-serverless` 驱动。  
您可以直接使用 [Postgres](/docs/get-started/postgresql-new) 连接到 Neon 数据库。
  
有关在 Cloudflare Worker 中使用 Drizzle ORM 和 Neon 无服务器驱动的示例，**[请见这里](http://driz.link/neon-cf-ex)**。  
要从有服务器环境使用 Neon，您可以使用 PostgresJS 驱动，正如 Neon 的 **[官方 Node.js 文档](https://neon.tech/docs/guides/node)** 中所描述的 — 参见 **[文档](#postgresjs)**。

#### 第一步 - 安装包
<Npm>
drizzle-orm @neondatabase/serverless
-D drizzle-kit
</Npm>

#### 第二步 - 初始化驱动并进行查询
<CodeTabs items={["Neon HTTP", "Neon Websockets", "node-postgres", "postgres.js"]}>
```typescript
import { drizzle } from 'drizzle-orm/neon-http';

const db = drizzle(process.env.DATABASE_URL);

const result = await db.execute('select 1');
```
<Section> 
```typescript 
import { drizzle } from 'drizzle-orm/neon-serverless';

const db = drizzle(process.env.DATABASE_URL);

const result = await db.execute('select 1');
```
```typescript
// 对于 Node.js - 确保安装 'ws' 和 'bufferutil' 包
import { drizzle } from 'drizzle-orm/neon-serverless';
import ws from 'ws';

const db = drizzle({
  connection: process.env.DATABASE_URL,
  ws: ws,
});

const result = await db.execute('select 1');
```
<Callout type="warning" emoji="⚙️"> 
在 `WebSocket` 全局未定义的环境（例如 Node.js）中使用 WebSockets 需要额外的配置。 
将 `ws` 和 `bufferutil` 包添加到项目的依赖中，并在 Drizzle 配置中设置 `ws`。 
</Callout>
</Section> 
```typescript 
// 确保安装 'pg' 包 
import { drizzle } from 'drizzle-orm/node-postgres';

const db = drizzle(process.env.DATABASE_URL);
 
const result = await db.execute('select 1');
```
```typescript
// 确保安装 'postgres' 包
import { drizzle } from 'drizzle-orm/postgres-js';

const db = drizzle(process.env.DATABASE_URL);

const result = await db.execute('select 1');
```
</CodeTabs>

如果您需要提供现有的驱动程序：

<CodeTabs items={["Neon HTTP", "Neon Websockets", "node-postgres", "postgres.js"]}>
```typescript
import { neon } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-http';

const sql = neon(process.env.DATABASE_URL!);
const db = drizzle({ client: sql });

const result = await db.execute('select 1');
```
<Section> 
```typescript 
import { Pool } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-serverless';

const pool = new Pool({ connectionString: process.env.DATABASE_URL });
const db = drizzle({ client: pool });

const result = await db.execute('select 1');
```
```typescript
// 对于 Node.js - 确保安装 'ws' 和 'bufferutil' 包
import { Pool, neonConfig } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-serverless';

neonConfig.webSocketConstructor = ws;

const pool = new Pool({ connectionString: process.env.DATABASE_URL });
const db = drizzle({ client: pool });

const result = await db.execute('select 1');
```
<Callout type="warning" emoji="⚙️"> 
在 `WebSocket` 全局未定义的环境（例如 Node.js）中使用 WebSockets 需要额外的配置。 
将 `ws` 和 `bufferutil` 包添加到项目的依赖中，并在 Drizzle 配置中设置 `ws`。 
</Callout>
</Section> 
```typescript 
// 确保安装 'pg' 包 
import { drizzle } from "drizzle-orm/node-postgres";
import { Pool } from "pg";

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});
const db = drizzle({ client: pool });
 
const result = await db.execute('select 1');
```
```typescript
// 确保安装 'postgres' 包
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';

const queryClient = postgres(process.env.DATABASE_URL);
const db = drizzle({ client: queryClient });

const result = await db.execute('select 1');
```
</CodeTabs>

#### 接下来是什么？

<WhatsNextPostgres/>


Source: https://drizzle.zhcndoc.com/docs/connect-nile

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import Steps from '@mdx/Steps.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";

# Drizzle \<\> Nile

<Prerequisites>
- 数据库 [连接基础](/docs/connect-overview) 与 Drizzle
- Nile 数据库 - [网站](https://thenile.dev)
- Drizzle PostgreSQL 驱动 - [文档](/docs/get-started-postgresql)
</Prerequisites>

根据 **[官方网站](https://thenile.dev)**，Nile 是为多租户应用重新设计的 PostgreSQL。

请查看官方 **[Nile + Drizzle 快速入门](https://www.thenile.dev/docs/getting-started/languages/drizzle)** 和 **[迁移](https://www.thenile.dev/docs/getting-started/schema_migrations/drizzle)** 文档。

您可以使用 Nile 与任何 Drizzle 的 Postgres 驱动，我们将在下文中展示 `node-postgres` 的使用。

#### 第一步 - 安装软件包

<Npm>
drizzle-orm postgres
-D drizzle-kit
</Npm>

#### 第二步 - 初始化驱动并进行查询

```typescript copy filename="index.ts"
// 确保安装了 'pg' 包
import { drizzle } from 'drizzle-orm/node-postgres'

const db = drizzle(process.env.NILEDB_URL);

const response = await db.select().from(...);
```

如果您需要提供现有的驱动：

```typescript copy filename="index.ts"
// 确保安装了 'pg' 包
import { drizzle } from "drizzle-orm/node-postgres";
import { Pool } from "pg";
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});
const db = drizzle({ client: pool });

const response = await db.select().from(...);
```

#### 连接到虚拟租户数据库

Nile 提供虚拟租户数据库，当您设置租户上下文时，Nile 会将您的查询定向到该特定租户的虚拟数据库，所有查询都将应用于该租户（即 `select * from table` 将仅返回该租户的记录）。

为了设置租户上下文，我们将每个查询包装在一个事务中，在运行事务之前设置适当的租户上下文。

可以将租户 ID 作为参数简单地传递给包装器：

```typescript copy filename="index.ts"
import { drizzle } from 'drizzle-orm/node-postgres';
import { todosTable, tenants } from "./db/schema";
import { sql } from 'drizzle-orm';
import 'dotenv/config';

const db = drizzle(process.env.NILEDB_URL);

function tenantDB<T>(tenantId: string, cb: (tx: any) => T | Promise<T>): Promise<T> {
  return db.transaction(async (tx) => {
    if (tenantId) {
      await tx.execute(sql`set local nile.tenant_id = '${sql.raw(tenantId)}'`);
    }

    return cb(tx);
  }) as Promise<T>;
}

// 在 Web 应用中，您可能会从请求路径参数或头获取租户 ID
const tenantId = '01943e56-16df-754f-a7b6-6234c368b400'

const response = await tenantDB(tenantId, async (tx) => {
    // 这里不需要 "where" 子句
    return await tx.select().from(todosTable);
});

console.log(response);
```

如果您使用支持的 Web 框架，可以设置 [AsyncLocalStorage](https://nodejs.org/api/async_context.html) 并使用中间件将其填充租户 ID。在这种情况下，您的 Drizzle 客户端设置将是：

```typescript copy filename="db/index.ts
import { drizzle } from 'drizzle-orm/node-postgres';
import dotenv from "dotenv/config";
import { sql } from "drizzle-orm";
import { AsyncLocalStorage } from "async_hooks";

export const db = drizzle(process.env.NILEDB_URL);
export const tenantContext = new AsyncLocalStorage<string | undefined>();

export function tenantDB<T>(cb: (tx: any) => T | Promise<T>): Promise<T> {
  return db.transaction(async (tx) => {
    const tenantId = tenantContext.getStore();
    console.log("执行查询的租户: " + tenantId);
    // 如果存在租户 ID，将其设置在事务上下文中
    if (tenantId) {
      await tx.execute(sql`set local nile.tenant_id = '${sql.raw(tenantId)}'`);
    }

    return cb(tx);
  }) as Promise<T>;
}
```

然后，配置中间件以填充 AsyncLocalStorage，并在处理请求时使用 `tenantDB` 方法：

```typescript copy filename="app.ts"
// 中间件以设置租户上下文
app.use("/api/tenants/:tenantId/*", async (c, next) => {
  const tenantId = c.req.param("tenantId");
  console.log("将上下文设置为租户: " + tenantId);
  return tenantContext.run(tenantId, () => next());
});

// 路由处理程序
app.get("/api/tenants/:tenantId/todos", async (c) => {
    const todos = await tenantDB(c, async (tx) => {
      return await tx
        .select({
          id: todoSchema.id,
          tenant_id: todoSchema.tenantId,
          title: todoSchema.title,
          estimate: todoSchema.estimate,
        })
        .from(todoSchema);
    });
    return c.json(todos);
});
```

#### 接下来是什么？

<WhatsNextPostgres/>





Source: https://drizzle.zhcndoc.com/docs/connect-op-sqlite

import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Steps from '@mdx/Steps.astro';

# Drizzle \<\> OP SQLite
根据 **[官方 GitHub 页面](https://github.com/OP-Engineering/op-sqlite)**， 
OP-SQLite 嵌入了最新版本的 SQLite，并提供了执行 SQL 查询的低级 API。

<Npm>
drizzle-orm @op-engineering/op-sqlite
-D drizzle-kit 
</Npm>

```ts
import { drizzle } from "drizzle-orm/op-sqlite";
import { open } from '@op-engineering/op-sqlite';

const opsqlite = open({
  name: 'myDB',
});
const db = drizzle(opsqlite);

await db.select().from(users);
```

你可以使用 Drizzle Kit 来生成 SQL 迁移。  
在继续之前，请确保查看 [Drizzle Kit 迁移](/docs/kit-overview) 的工作原理。  
OP SQLite 要求你将 SQL 迁移捆绑到应用中，我们已经为你准备好了。

<Steps>

#### 安装 babel 插件
将 SQL 迁移文件直接捆绑为字符串到你的包中是必要的。
```shell
npm install babel-plugin-inline-import
```

#### 更新配置文件。
你需要更新 `babel.config.js`、`metro.config.js` 和 `drizzle.config.ts` 文件
```js filename='babel.config.js'
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: [
    [
      'inline-import',
      {
        extensions: ['.sql'],
      },
    ],
  ],
};
```

```js filename="metro.config.js"
const { getDefaultConfig } = require('@react-native/metro-config');

const config = getDefaultConfig(__dirname);

config.resolver.sourceExts.push('sql');

module.exports = config;
```

确保在 Drizzle Kit 配置中有 `dialect: 'sqlite'` 和 `driver: 'expo'`
```ts filename="drizzle.config.ts"
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
	schema: './db/schema.ts',
	out: './drizzle',
  dialect: 'sqlite',
	driver: 'expo', // <--- 非常重要
});
```

#### 生成迁移
在创建 SQL 架构文件和 drizzle.config.ts 文件后，你可以生成迁移
```bash
npx drizzle-kit generate
```

#### 将迁移添加到你的应用
现在你需要从 `./drizzle` 文件夹将 `migrations.js` 文件导入到你的 Expo/React Native 应用中。 
你可以在应用启动时使用我们自定义的 `useMigrations` 迁移钩子在 `useEffect` 钩子中手动运行迁移。

```ts filename="App.tsx"
import { drizzle } from "drizzle-orm/op-sqlite";
import { open } from '@op-engineering/op-sqlite';
import { useMigrations } from 'drizzle-orm/op-sqlite/migrator';
import migrations from './drizzle/migrations';

const opsqliteDb = open({
  name: 'myDB',
});

const db = drizzle(opsqliteDb);

export default function App() {
  const { success, error } = useMigrations(db, migrations);

  if (error) {
    return (
      <View>
        <Text>迁移错误：{error.message}</Text>
      </View>
    );
  }

  if (!success) {
    return (
      <View>
        <Text>迁移正在进行中...</Text>
      </View>
    );
  }

  return ...你的应用组件;
}
```

</Steps>



Source: https://drizzle.zhcndoc.com/docs/connect-overview

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import Steps from '@mdx/Steps.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from '@mdx/CodeTabs.astro';
import CodeTab from '@mdx/CodeTab.astro';
import Section from "@mdx/Section.astro";
import LinksList from "@mdx/LinksList.astro"
import Flex from "@mdx/Flex.astro"

# 与 Drizzle 的数据库连接
Drizzle ORM 通过 **数据库驱动** 在您的数据库上运行 SQL 查询。
<CodeTabs items={["index.ts", "schema.ts"]}>

<CodeTab>
```ts
import { drizzle } from "drizzle-orm/node-postgres"
import { users } from "./schema"

const db = drizzle(process.env.DATABASE_URL);
const usersCount = await db.$count(users);
```
```  
                        ┌──────────────────────┐
                        │   db.$count(users)   │ <--- drizzle 查询
                        └──────────────────────┘     
                            │               ʌ
select count(*) from users -│               │
                            │               │- [{ count: 0 }]
                            v               │
                         ┌─────────────────────┐
                         │    node-postgres    │ <--- 数据库驱动
                         └─────────────────────┘
                            │               ʌ
01101000 01100101 01111001 -│               │
                            │               │- 01110011 01110101 01110000
                            v               │
                         ┌────────────────────┐
                         │      数据库        │ 
                         └────────────────────┘
```
</CodeTab>

```ts
import { pgTable, integer, text } from "drizzle-orm";

export const users = pgTable("users", {
  id: integer("id").generateAlwaysAsIdentity(),
  name: text("name"),
})
```
</CodeTabs>

在后台，Drizzle 会创建一个 **node-postgres** 驱动实例，如果需要，您可以通过 `db.$client` 访问它。
<Section>
```ts
import { drizzle } from "drizzle-orm/node-postgres"

const db = drizzle(process.env.DATABASE_URL);
const pool = db.$client;
```
```ts
// 以上代码等价于
import { drizzle } from "drizzle-orm/node-postgres";
import { Pool } from "pg";

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});
const db = drizzle({ client: pool });
```
</Section>

Drizzle 的设计使其与每一种 **边缘** 或 **无服务器** 运行时本地兼容，无论何时您需要访问无服务器数据库 - 我们都会为您提供支持。

<CodeTabs items={["Neon HTTP", "Neon with websockets", "Vercel Postgres", "PlanetScale HTTP", "Cloudflare d1"]}>
```ts
import { drizzle } from "drizzle-orm/neon-http";

const db = drizzle(process.env.DATABASE_URL);
```
```ts
import { drizzle } from "drizzle-orm/neon-serverless";

const db = drizzle(process.env.DATABASE_URL);
```
```ts
import { drizzle } from "drizzle-orm/vercel-postgres";

const db = drizzle();
```
```ts
import { drizzle } from "drizzle-orm/planetscale";

const db = drizzle(process.env.DATABASE_URL);
```
```ts
import { drizzle } from "drizzle-orm/d1";

const db = drizzle({ connection: env.DB });
```
</CodeTabs>

确实，我们支持特定于运行时的驱动程序，如 [Bun SQLite](/docs/connect-bun-sqlite) 或 [Expo SQLite](/docs/connect-expo-sqlite)：
<Section>
```ts
import { drizzle } from "drizzle-orm/bun-sqlite"

const db = drizzle(); // <--- will create an in-memory db
const db = drizzle("./sqlite.db");
```
```ts
import { drizzle } from "drizzle-orm/expo-sqlite";
import { openDatabaseSync } from "expo-sqlite";

const expo = openDatabaseSync("db.db");
const db = drizzle(expo);
```
</Section>

#### 数据库连接 URL
以防您对数据库连接 URL 概念不熟悉
```
postgresql://alex:AbC123dEf@ep-cool-darkness-123456.us-east-2.aws.neon.tech/dbname
             └──┘ └───────┘ └─────────────────────────────────────────────┘ └────┘
              ʌ    ʌ          ʌ                                              ʌ
        角色 -│    │          │- 主机名                                    │- 数据库
                   │
                   │- 密码

```
#### 下一步
欢迎查看每个驱动程序的文档  

<rem/>
<Flex>
  <LinksList 
    title='PostgreSQL 驱动'
    links={[
        ["PostgreSQL", "/docs/get-started-postgresql"], 
        ["Neon", "/docs/connect-neon"], 
        ["Vercel Postgres", "/docs/connect-vercel-postgres"],
        ["Supabase", "/docs/connect-supabase"],
        ["Xata", "/docs/connect-xata"],
        ["PGLite", "/docs/connect-pglite"],
      ]}
  />
  <LinksList 
    title='MySQL 驱动'
    links={[
        ["MySQL", "/docs/get-started-mysql"], 
        ["PlanetsScale", "/docs/connect-planetscale"], 
        ["TiDB", "/docs/connect-tidb"],
      ]}
  />
  <LinksList 
  title='SQLite 驱动'
  links={[
      ["SQLite", "/docs/get-started-sqlite"], 
      ["Turso", "/docs/connect-turso"], 
      ["Cloudflare D1", "/docs/connect-cloudflare-d1"],
      ["Bun SQLite", "/docs/connect-bun-sqlite"],
    ]}
  />
  <LinksList 
  title='原生 SQLite'
  links={[
      ["Expo SQLite", "/docs/get-started/expo-new"], 
      ["OP SQLite", "/docs/connect-op-sqlite"], 
      ["React Native SQLite", "/docs/connect-react-native-sqlite"],
    ]}
  />
  <LinksList 
  title='其他'
  links={[
      ["Drizzle Proxy", "/docs/connect-drizzle-proxy"], 
    ]}
  />
</Flex>
{/* TODO: @AndriiSherman ["AWS Data API", "/docs/get-started/aws-data-api"],  */}


Source: https://drizzle.zhcndoc.com/docs/connect-pglite

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import Steps from '@mdx/Steps.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";

# Drizzle \<\> PGlite

<Prerequisites>
- 数据库 [连接基础知识](/docs/connect-overview) 与 Drizzle
- ElectricSQL - [网站](https://electric-sql.com/)
- PgLite 驱动 - [文档](https://pglite.dev/) & [GitHub](https://github.com/electric-sql/pglite)
</Prerequisites>

根据 **[官方仓库](https://github.com/electric-sql/pglite)**，PGlite 是一个将 Postgres 打包到 TypeScript 客户端库中的 WASM 构建，使您能够在浏览器、Node.js 和 Bun 中运行 Postgres，而无需安装任何其他依赖项。压缩后只有 2.6mb。

它可以用作短暂的内存数据库，或持久化到文件系统（Node/Bun）或 indexedDB（浏览器）。

与之前的“浏览器中的 Postgres”项目不同，PGlite 不使用 Linux 虚拟机 - 它只是 WASM 中的 Postgres。

#### 第 1 步 - 安装软件包

<Npm>
drizzle-orm @electric-sql/pglite
-D drizzle-kit
</Npm>

#### 第 2 步 - 初始化驱动并进行查询
<CodeTabs items={["内存中", "目录中", "使用额外配置选项"]}>
```typescript copy"
import { drizzle } from 'drizzle-orm/pglite';

const db = drizzle();

await db.select().from(...);
```
```typescript copy"
import { drizzle } from 'drizzle-orm/pglite';

const db = drizzle('path-to-dir');

await db.select().from(...);
```
```typescript copy"
import { drizzle } from 'drizzle-orm/pglite';

// connection 是一个本地 PGLite 配置
const db = drizzle({ connection: { dataDir: 'path-to-dir' }});

await db.select().from(...);
```
</CodeTabs>

如果您需要提供现有的驱动程序：

```typescript copy"
import { PGlite } from '@electric-sql/pglite';
import { drizzle } from 'drizzle-orm/pglite';

// 内存中的 Postgres
const client = new PGlite();
const db = drizzle({ client });

await db.select().from(users);
```

#### 接下来是什么？

<WhatsNextPostgres/>


Source: https://drizzle.zhcndoc.com/docs/connect-planetscale

import Npm from '@mdx/Npm.astro';
import Callout from '@mdx/Callout.astro';
import Tabs from '@mdx/Tabs.astro';
import Tab from '@mdx/Tab.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";

# Drizzle \<\> PlanetScale

<Prerequisites>
- 数据库 [连接基础]( /docs/connect-overview) 与 Drizzle
- PlanetScale 数据库 - [官网](https://planetscale.com/docs)
- PlanetScale HTTP 驱动 - [GitHub](https://github.com/planetscale/database-js)
- Drizzle MySQL 驱动 - [文档]( /docs/get-started-mysql)
</Prerequisites>

根据 **[官方网站](https://planetscale.com)**， 
PlanetScale 是世界上最先进的无服务器 MySQL 平台。

使用 Drizzle ORM，您可以通过官方的
**[`database-js`](https://github.com/planetscale/database-js)**
驱动程序，通过无服务器和有服务器环境访问 PlanetScale，使用我们的 `drizzle-orm/planetscale-serverless` 包。

您还可以通过 TCP 使用 `mysql2` 驱动访问 PlanetScale — **[请参见此处.](/docs/get-started-mysql)**

#### 步骤 1 - 安装软件包
<Npm>
drizzle-orm @planetscale/database
-D drizzle-kit
</Npm>

#### 步骤 2 - 初始化驱动并进行查询
```typescript copy"
import { drizzle } from "drizzle-orm/planetscale-serverless";

const db = drizzle({ connection: {
  host: process.env["DATABASE_HOST"],
  username: process.env["DATABASE_USERNAME"],
  password: process.env["DATABASE_PASSWORD"],
}});

const response = await db.select().from(...)
```

如果您需要提供现有的驱动程序：

```typescript copy"
import { drizzle } from "drizzle-orm/planetscale-serverless";
import { Client } from "@planetscale/database";

const client = new Client({
  host: process.env["DATABASE_HOST"],
  username: process.env["DATABASE_USERNAME"],
  password: process.env["DATABASE_PASSWORD"],
});

const db = drizzle({ client });
```

确保查看 PlanetScale 官方的 **[MySQL 课程](https://planetscale.com/courses/mysql-for-developers)**， 
我们认为它们非常棒 🙌

#### 接下来做什么？

<WhatsNextPostgres/>

Source: https://drizzle.zhcndoc.com/docs/connect-prisma-postgres

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import Steps from '@mdx/Steps.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import Section from "@mdx/Section.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";

# Drizzle \<\> Prisma Postgres
<Prerequisites>
- 使用 Drizzle 的数据库[连接基础](/docs/connect-overview)
- Prisma Postgres 无服务器数据库 - [官网](https://prisma.io/postgres)
- Prisma Postgres 直接连接 - [文档](https://www.prisma.io/docs/postgres/database/direct-connections) 
- Drizzle PostgreSQL 驱动 - [文档](/docs/get-started-postgresql)
</Prerequisites>

Prisma Postgres 是一个基于 [unikernels](https://www.prisma.io/blog/announcing-prisma-postgres-early-access) 构建的无服务器数据库。它拥有大量的免费额度，[基于操作的定价](https://www.prisma.io/blog/operations-based-billing) 并且没有冷启动。

你可以使用 PostgreSQL 的 [`node-postgres`](https://node-postgres.com/) 或 [`postgres.js`](https://github.com/porsager/postgres) 驱动进行连接。

<Callout type="info">
Prisma Postgres 也有一个[无服务器驱动](https://www.prisma.io/docs/postgres/database/serverless-driver)，将来 Drizzle ORM 会支持它。
</Callout>

#### 第一步 - 安装包
<CodeTabs items={["node-postgres (pg)", "postgres.js"]}>
<Npm>
drizzle-orm pg
-D drizzle-kit
</Npm>

<Npm>
drizzle-orm postres
-D drizzle-kit
</Npm>

</CodeTabs>


#### 第二步 - 初始化驱动并执行查询
<CodeTabs items={["node-postgres (pg)", "postgres.js"]}>
```typescript 
// 确保安装了 'pg' 包 
import { drizzle } from "drizzle-orm/node-postgres";
import { Pool } from "pg";

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});
const db = drizzle({ client: pool });
 
const result = await db.execute('select 1');
```
```typescript
// 确保安装了 'postgres' 包
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';

const queryClient = postgres(process.env.DATABASE_URL);
const db = drizzle({ client: queryClient });

const result = await db.execute('select 1');
```
</CodeTabs>

#### 接下来？

<WhatsNextPostgres/>

Source: https://drizzle.zhcndoc.com/docs/connect-react-native-sqlite

import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Steps from '@mdx/Steps.astro';

# Drizzle \<\> React Native SQLite
请使用 [`Expo SQLite`](#expo-sqlite) 在 React Native 应用中运行 Drizzle ORM。  
我们发现的唯一 [流行库](https://github.com/andpor/react-native-sqlite-storage) 不支持新的 Hermes JavaScript 运行时，
而 Hermes 现在是 React Native 和 Expo 的默认标准运行时。




Source: https://drizzle.zhcndoc.com/docs/connect-supabase

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import Steps from '@mdx/Steps.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";

# Drizzle \<\> Supabase

<Prerequisites>
- 数据库 [连接基础](/docs/connect-overview) 与 Drizzle
- Drizzle PostgreSQL 驱动 - [文档](/docs/get-started-postgresql)
</Prerequisites>

根据 **[官方网站](https://supabase.com/docs)**，Supabase 是一个开源的 Firebase 替代品，旨在使用最小的配置构建安全且高性能的 Postgres 后端。

查看官方 **[Supabase + Drizzle](https://supabase.com/docs/guides/database/connecting-to-postgres#connecting-with-drizzle)** 文档。

#### 第一步 - 安装软件包

<Npm>
drizzle-orm postgres
-D drizzle-kit
</Npm>

#### 第二步 - 初始化驱动并进行查询

```typescript copy filename="index.ts"
import { drizzle } from 'drizzle-orm/postgres-js'

const db = drizzle(process.env.DATABASE_URL);

const allUsers = await db.select().from(...);
```

如果您需要提供现有的驱动程序：
```typescript copy filename="index.ts"
import { drizzle } from 'drizzle-orm/postgres-js'
import postgres from 'postgres'

const client = postgres(process.env.DATABASE_URL)
const db = drizzle({ client });

const allUsers = await db.select().from(...);
```

如果您决定通过 Supabase 使用连接池（在 [这里](https://supabase.com/docs/guides/database/connecting-to-postgres#connection-pooler) 描述），并启用了“事务”池模式，则确保将 prepare 关闭，因为不支持预编译语句。

```typescript copy filename="index.ts"
import { drizzle } from 'drizzle-orm/postgres-js'
import postgres from 'postgres'

// 禁用预取，因为在“事务”池模式下不支持 
const client = postgres(process.env.DATABASE_URL, { prepare: false })
const db = drizzle({ client });

const allUsers = await db.select().from(...);
```

使用连接池连接到您的数据库以适应 **无服务器环境**，而在 **长时间运行的服务器** 中使用直接连接。

#### 接下来是什么？

<WhatsNextPostgres/>



Source: https://drizzle.zhcndoc.com/docs/connect-tidb

import Npm from '@mdx/Npm.astro';
import Callout from '@mdx/Callout.astro';
import Tabs from '@mdx/Tabs.astro';
import Tab from '@mdx/Tab.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";

# Drizzle \<\> TiDB Serverless

<Prerequisites>
- 数据库 [连接基础](/docs/connect-overview) 与 Drizzle
- TiDB 数据库 - [官网](https://docs.pingcap.com/)
- TiDB HTTP 驱动 - [官网](https://docs.pingcap.com/tidbcloud/serverless-driver)
- Drizzle MySQL 驱动 - [文档](/docs/get-started-mysql)
</Prerequisites>

根据 **[官方网站](https://www.pingcap.com/tidb-serverless/)**, 
TiDB Serverless 是一款完全托管、自主的 DBaaS，具备瞬时集群配置和基于消费的定价。

<Callout type="info" emoji="ℹ️">
TiDB Serverless 兼容 MySQL，因此您可以使用 [MySQL 连接指南](/docs/get-started-mysql) 进行连接。
</Callout>

TiDB Serverless 提供了一种 [HTTP 驱动](https://docs.pingcap.com/tidbcloud/serverless-driver) 用于边缘环境。它通过 `drizzle-orm/tidb-serverless` 包被 Drizzle ORM 原生支持。

#### 步骤 1 - 安装包
<Npm>
drizzle-orm @tidbcloud/serverless
-D drizzle-kit
</Npm>

#### 步骤 2 - 初始化驱动并执行查询
```typescript copy filename="index.ts"
import { drizzle } from 'drizzle-orm/tidb-serverless';

const db = drizzle({ connection: { url: process.env.TIDB_URL }});

const response = await db.select().from(...)
```

如果您需要提供现有的驱动程序：
```typescript copy"
import { connect } from '@tidbcloud/serverless';
import { drizzle } from 'drizzle-orm/tidb-serverless';

const client = connect({ url: process.env.TIDB_URL });
const db = drizzle({ client });
```

#### 下一步？

<WhatsNextPostgres/>

Source: https://drizzle.zhcndoc.com/docs/connect-turso

import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Steps from '@mdx/Steps.astro';
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import LibsqlTable from "@mdx/LibsqlTable.mdx";
import LibsqlTabs from "@mdx/LibsqlTabs.mdx";

# Drizzle \<\> Turso

<Prerequisites>
- 数据库 [连接基础](/docs/connect-overview) 与 Drizzle
- Turso 数据库 - [官方网站](https://docs.turso.tech/introduction)
- LibSQL 驱动 - [官方网站](https://docs.turso.tech/sdk/ts/reference) & [GitHub](https://github.com/tursodatabase/libsql-client-ts)
</Prerequisites>

根据**[官方网站](https://turso.tech/drizzle)**，
Turso 是一个基于 **[libSQL](https://github.com/libsql/libsql)** 的边缘 SQLite 数据库即服务。

Drizzle ORM 原生支持 libSQL 驱动，
我们支持 SQL 方言和特定方言的驱动和语法，并镜像最流行的
类似 SQLite 的 `all`、`get`、`values` 和 `run` 查询方法语法。

#### 第 1 步 - 安装包
<Npm>
drizzle-orm @libsql/client
-D drizzle-kit
</Npm>

#### 第 2 步 - 初始化驱动
Drizzle 原生支持所有 `@libsql/client` 驱动变体：

<LibsqlTable />

<br />

<LibsqlTabs />

如果您需要提供您现有的驱动：

<CodeTabs items={["default", "web"]}>
```typescript copy
import { drizzle } from 'drizzle-orm/libsql';
import { createClient } from '@libsql/client';

const client = createClient({ 
  url: process.env.DATABASE_URL,
  authToken: process.env.DATABASE_AUTH_TOKEN
});

const db = drizzle({ client });

const result = await db.select().from(users).all()
```
```typescript copy
import { drizzle } from 'drizzle-orm/libsql/web';
import { createClient } from '@libsql/client/web';

const client = createClient({ 
  url: process.env.DATABASE_URL,
  authToken: process.env.DATABASE_AUTH_TOKEN
});

const db = drizzle({ client });

const result = await db.select().from(users).all()
```
</CodeTabs>

#### 第 3 步 - 执行查询

```ts
import { drizzle } from 'drizzle-orm/libsql';
import * as s from 'drizzle-orm/sqlite-core';

const db = drizzle({ connection: {
  url: process.env.DATABASE_URL, 
  authToken: process.env.DATABASE_AUTH_TOKEN 
}});

const users = s.sqliteTable("users", {
  id: s.integer(),
  name: s.text(),
})

const result = await db.select().from(users);
```

#### 接下来是什么？

<WhatsNextPostgres/>

Source: https://drizzle.zhcndoc.com/docs/connect-vercel-postgres

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import Steps from '@mdx/Steps.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";

# Drizzle \<\> Vercel Postgres

<Prerequisites>
- 数据库 [连接基础](/docs/connect-overview) 与 Drizzle
- Vercel Postgres 数据库 - [网站](https://vercel.com/docs/storage/vercel-postgres)
- Vercel Postgres 驱动 - [文档](https://vercel.com/docs/storage/vercel-postgres/sdk) & [GitHub](https://github.com/vercel/storage/tree/main/packages/postgres)
- Drizzle PostgreSQL 驱动 - [文档](/docs/get-started-postgresql)
</Prerequisites>

根据他们的 **[官方网站](https://vercel.com/docs/storage/vercel-postgres)**，
Vercel Postgres 是一个无服务器 SQL 数据库，旨在与 Vercel Functions 集成。

Drizzle ORM 原生支持 **[@vercel/postgres](https://vercel.com/docs/storage/vercel-postgres)** 无服务器
驱动以及 `drizzle-orm/vercel-postgres` 包和 **[`postgres`](#postgresjs)** 或 **[`pg`](#node-postgres)**
驱动通过 `postgesql://` 访问 Vercel Postgres。

查看官方 **[Vercel Postgres + Drizzle](https://vercel.com/docs/storage/vercel-postgres/using-an-orm#drizzle)** 文档。

#### 步骤 1 - 安装包

<Npm>
drizzle-orm @vercel/postgres
-D drizzle-kit
</Npm>

#### 步骤 2 - 准备 Vercel Postgres

根据 **[官方文档](https://vercel.com/docs/storage/vercel-postgres/quickstart)** 设置项目。

#### 步骤 3 - 初始化驱动并进行查询

```typescript copy
import { drizzle } from 'drizzle-orm/vercel-postgres';

const db = drizzle();

const result = await db.execute('select 1');
```

如果您需要提供现有的驱动程序：

```typescript copy
import { sql } from '@vercel/postgres';
import { drizzle } from 'drizzle-orm/vercel-postgres';

const db = drizzle({ client: sql })

const result = await db.execute('select 1');
```

使用 **[@vercel/postgres](https://vercel.com/docs/storage/vercel-postgres)** 无服务器包
您可以通过 websockets 从无 TCP 可用的服务器和无服务器环境访问 Vercel Postgres，
如 Cloudflare Workers。
  
如果您打算从 _服务器_ 环境使用 Vercel Postgres，您可以选择使用 `@vercel/postgres` 
或直接通过 `postgesql://` 访问数据库，使用 
**[`postgres`](#postgresjs)** 或 **[`pg`](#node-postgres)**。

#### 接下来是什么？

<WhatsNextPostgres/>


Source: https://drizzle.zhcndoc.com/docs/connect-xata

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import Steps from '@mdx/Steps.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import CodeTabs from "@mdx/CodeTabs.astro";

# Drizzle \<\> Xata

<Prerequisites>
- 使用 Drizzle 的数据库[连接基础](/docs/connect-overview)
- Drizzle PostgreSQL 驱动 - [文档](/docs/get-started-postgresql)
</Prerequisites>

**[Xata](https://xata.io)** 是一个 PostgreSQL 数据库平台，旨在帮助开发者以更高的生产力和性能管理和扩展数据库。Xata 提供的功能包括即时的写时复制数据库分支、零停机架构变更、数据匿名化、AI 驱动的性能监控以及自带云（BYOC）。

查看官方 **[Xata + Drizzle](https://xata.io/documentation/quickstarts/drizzle)** 文档。

#### 第一步 - 安装包

<Npm>
drizzle-orm postgres
-D drizzle-kit
</Npm>

#### 第二步 - 初始化驱动并进行查询

```typescript copy filename="index.ts"
import { drizzle } from 'drizzle-orm/postgres-js'

const db = drizzle(process.env.DATABASE_URL);

const allUsers = await db.select().from(...);
```

如果需要提供已有驱动：
```typescript copy filename="index.ts"
import { drizzle } from 'drizzle-orm/postgres-js'
import postgres from 'postgres'

const client = postgres(process.env.DATABASE_URL)
const db = drizzle({ client });

const allUsers = await db.select().from(...);
```

#### 下一步是什么？

<WhatsNextPostgres/>

Source: https://drizzle.zhcndoc.com/docs/custom-types

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';

# 定义自定义类型的常用方法

## 示例

查看 `customType` 定义如何工作的最佳方法是检查如何使用 Drizzle ORM 中的 `customType` 函数定义 postgres 和 mysql 中现有的数据类型。


<Tabs items={['Postgres 数据类型', 'MySql 数据类型']}>
  <Tab>

**Serial**

```typescript copy
import { customType } from 'drizzle-orm/pg-core';

const customSerial = customType<{ data: number; notNull: true; default: true }>(
  {
    dataType() {
      return 'serial';
    },
  },
);
```

**Text**

```typescript copy
import { customType } from 'drizzle-orm/pg-core';

const customText = customType<{ data: string }>({
  dataType() {
    return 'text';
  },
});
```

**Boolean**

```typescript copy
import { customType } from 'drizzle-orm/pg-core';

const customBoolean = customType<{ data: boolean }>({
  dataType() {
    return 'boolean';
  },
});
```

**Jsonb**

```typescript copy
import { customType } from 'drizzle-orm/pg-core';

const customJsonb = <TData>(name: string) =>
  customType<{ data: TData; driverData: string }>({
    dataType() {
      return 'jsonb';
    },
    toDriver(value: TData): string {
      return JSON.stringify(value);
    },
  })(name);
```

**Timestamp**

```typescript copy
import { customType } from 'drizzle-orm/pg-core';

const customTimestamp = customType<
  {
    data: Date;
    driverData: string;
    config: { withTimezone: boolean; precision?: number };
  }
>({
  dataType(config) {
    const precision = typeof config.precision !== 'undefined'
      ? ` (${config.precision})`
      : '';
    return `timestamp${precision}${
      config.withTimezone ? ' with time zone' : ''
    }`;
  },
  fromDriver(value: string): Date {
    return new Date(value);
  },
});
```

所有类型的用法与 Drizzle ORM 中定义的函数相同。例如：

```typescript copy
const usersTable = pgTable('users', {
  id: customSerial('id').primaryKey(),
  name: customText('name').notNull(),
  verified: customBoolean('verified').notNull().default(false),
  jsonb: customJsonb<string[]>('jsonb'),
  createdAt: customTimestamp('created_at', { withTimezone: true }).notNull()
    .default(sql`now()`),
});
```
  </Tab>
  <Tab>

**Serial**

```typescript copy
import { customType } from 'drizzle-orm/mysql-core';

const customInt = customType<{ data: number; notNull: false; default: false }>(
  {
    dataType() {
      return 'int';
    },
  },
);
```

**Text**

```typescript copy
import { customType } from 'drizzle-orm/mysql-core';

const customText = customType<{ data: string }>({
  dataType() {
    return 'text';
  },
});
```

**Boolean**

```typescript copy
import { customType } from 'drizzle-orm/mysql-core';

const customBoolean = customType<{ data: boolean }>({
  dataType() {
    return 'boolean';
  },
  fromDriver(value) {
    if (typeof value === 'boolean') {
      return value;
    }
    return value === 1;
  },
});
```

**Json**

```typescript copy
import { customType } from 'drizzle-orm/mysql-core';

const customJson = <TData>(name: string) =>
  customType<{ data: TData; driverData: string }>({
    dataType() {
      return 'json';
    },
    toDriver(value: TData): string {
      return JSON.stringify(value);
    },
  })(name);
```

**Timestamp**

```typescript copy
import { customType } from 'drizzle-orm/mysql-core';

const customTimestamp = customType<
  { data: Date; driverData: string; config: { fsp: number } }
>({
  dataType(config) {
    const precision = typeof config.fsp !== 'undefined'
      ? ` (${config.fsp})`
      : '';
    return `timestamp${precision}`;
  },
  fromDriver(value: string): Date {
    return new Date(value);
  },
});
```

所有类型的用法与 Drizzle ORM 中定义的函数相同。例如：

```typescript copy
const usersTable = mysqlTable('userstest', {
  id: customInt('id').primaryKey(),
  name: customText('name').notNull(),
  verified: customBoolean('verified').notNull().default(false),
  jsonb: customJson<string[]>('jsonb'),
  createdAt: customTimestamp('created_at', { fsp: 2 }).notNull().default(
    sql`now()`,
  ),
});
```

  </Tab>
</Tabs>

## 自定义类型定义的 TS 文档

您可以查看 `types` 和 `param` 定义的 ts-doc。

```typescript
export type CustomTypeValues = {
  /**
   * 自定义列所需的类型，将推断适当的类型模型
   *
   * 示例：
   *
   * 如果您希望您的列在选择/插入后为 `string` 类型 - 使用 `data: string`。如 `text`，`varchar`
   *
   * 如果您希望您的列在选择/插入后为 `number` 类型 - 使用 `data: number`。如 `integer`
   */
  data: unknown;

  /**
   * 类型助手，表示数据库驱动程序接受特定数据库数据类型的类型
   */
  driverData?: unknown;

  /**
   * {@link CustomTypeParams} `dataType` 生成应使用什么配置类型
   */
  config?: Record<string, unknown>;

  /**
   * 如果您的自定义数据类型应默认不为空，您可以使用 `notNull: true`
   *
   * @example
   * const customSerial = customType<{ data: number, notNull: true, default: true }>({
   *    dataType() {
   *      return 'serial';
   *    },
   * });
   */
  notNull?: boolean;

  /**
   * 如果您的自定义数据类型有默认值，您可以使用 `default: true`
   *
   * @example
   * const customSerial = customType<{ data: number, notNull: true, default: true }>({
   *    dataType() {
   *      return 'serial';
   *    },
   * });
   */
  default?: boolean;
};

export interface CustomTypeParams<T extends CustomTypeValues> {
  /**
   * 用于迁移的数据库数据类型字符串表示
   * @example
   * ```
   * `jsonb`, `text`
   * ```
   *
   * 如果数据库数据类型需要附加参数，您可以从 `config` 参数中使用它们
   * @example
   * ```
   * `varchar(256)`, `numeric(2,3)`
   * ```
   *
   * 要使 `config` 为特定类型，请在 {@link CustomTypeValues} 中使用配置泛型
   *
   * @example
   * 使用示例
   * ```
   *   dataType() {
   *     return 'boolean';
   *   },
   * ```
   * 或
   * ```
   *   dataType(config) {
   *     return typeof config.length !== 'undefined' ? `varchar(${config.length})` : `varchar`;
   *   }
   * ```
   */
  dataType: (config: T['config']) => string;

  /**
   * 可选的映射函数，介于用户输入和驱动程序之间
   * @example
   * 例如，当使用 jsonb 时，我们需要将 JS/TS 对象映射为字符串，然后写入数据库
   * ```
   * toDriver(value: TData): string {
   *   return JSON.stringify(value);
   * }
   * ```
   */
  toDriver?: (value: T['data']) => T['driverData'];

  /**
   * 可选的映射函数，负责将数据从数据库映射到 JS/TS 代码
   * @example
   * 例如，当使用时间戳时，我们需要将字符串日期表示映射为 JS 日期
   * ```
   * fromDriver(value: string): Date {
   *  return new Date(value);
   * },
   * ```
   */
  fromDriver?: (value: T['driverData']) => T['data'];
}
```


Source: https://drizzle.zhcndoc.com/docs/data-querying

import Callout from '@mdx/Callout.astro';
import CodeTabs from "@mdx/CodeTabs.astro";
import Section from '@mdx/Section.astro';
import Flex from "@mdx/Flex.astro"
import LinksList from "@mdx/LinksList.astro"
import Prerequisites from "@mdx/Prerequisites.astro";

# Drizzle 查询 + CRUD

<Prerequisites>
  - 如何定义你的架构 - [架构基础](/docs/sql-schema-declaration)
  - 如何连接数据库 - [连接基础](/docs/connect-overview)
</Prerequisites>

Drizzle 提供了几种查询数据库的方法，您可以根据下一个项目的需要选择合适的方式。

它可以是类似 SQL 的语法或关系语法。让我们来看看它们：

## 为什么选择 SQL 类似语法？
\
**如果你知道 SQL，你就能掌握 Drizzle。**

其他 ORM 和数据框架往往偏离或抽象 SQL，这导致了双重学习曲线：你需要同时学习 SQL 和框架的 API。

Drizzle 则恰恰相反。
我们拥抱 SQL，并将 Drizzle 的核心构建成类似 SQL 的形式，以便你几乎没有学习曲线，并能完全利用 SQL 的强大功能。

<Section>
```typescript copy
// 访问你的数据
await db
  .select()
	.from(posts)
	.leftJoin(comments, eq(posts.id, comments.post_id))
	.where(eq(posts.id, 10))
```
```sql
SELECT * 
FROM posts
LEFT JOIN comments ON posts.id = comments.post_id
WHERE posts.id = 10
```
</Section>

使用 SQL 类似语法，你可以复制大部分纯 SQL 中可以做的事情，
并清楚知道 Drizzle 将执行什么以及会生成什么查询。你可以执行各种范围的查询，
包括选择、插入、更新、删除，以及使用别名、WITH 子句、子查询、准备语句等。
让我们看更多示例。

<CodeTabs items={['插入', '更新', '删除']}>
<Section>
```ts
await db.insert(users).values({ email: 'user@gmail.com' })
```
```sql
INSERT INTO users (email) VALUES ('user@gmail.com')
```
</Section>
<Section>
```ts
await db.update(users)
        .set({ email: 'user@gmail.com' })
        .where(eq(users.id, 1))
```
```sql
UPDATE users 
SET email = 'user@gmail.com'
WHERE users.id = 1
```
</Section>
<Section>
```ts
await db.delete(users).where(eq(users.id, 1))
```
```sql
DELETE FROM users WHERE users.id = 1
```
</Section>
</CodeTabs>

## 为什么不选择 SQL 类似语法？

我们始终在追求一个完美平衡的解决方案。虽然 SQL 类似查询可以满足 100% 的需求，
但在某些常见场景中，数据的查询可以更高效。

我们构建了查询 API，以便你可以以最方便和高效的方式从数据库中获取关系型、嵌套数据，
而无需担心联接或数据映射。

**Drizzle 总是输出确切的一个 SQL 查询**。可以放心地与无服务器数据库一起使用，
而无需担心性能或往返成本！

<Section>
```ts
const result = await db.query.users.findMany({
	with: {
		posts: true
	},
});
```
{/* ```sql
SELECT * FROM users ...
``` */}
</Section>

## 高级
使用 Drizzle，查询可以以你想要的任何方式组合和分区。
你可以独立于主查询组合过滤器，分离子查询或条件语句，等等。
让我们来看几个高级示例：

#### 组合一个 WHERE 语句，然后在查询中使用它
```ts
async function getProductsBy({
  name,
  category,
  maxPrice,
}: {
  name?: string;
  category?: string;
  maxPrice?: string;
}) {
  const filters: SQL[] = [];

  if (name) filters.push(ilike(products.name, name));
  if (category) filters.push(eq(products.category, category));
  if (maxPrice) filters.push(lte(products.price, maxPrice));

  return db
    .select()
    .from(products)
    .where(and(...filters));
}
```

#### 将子查询分离到不同变量中，然后在主查询中使用它们
```ts
const subquery = db
	.select()
	.from(internalStaff)
	.leftJoin(customUser, eq(internalStaff.userId, customUser.id))
	.as('internal_staff');

const mainQuery = await db
	.select()
	.from(ticket)
	.leftJoin(subquery, eq(subquery.internal_staff.userId, ticket.staffId));
```

#### 接下来是什么？
<br/>
<Flex>
  <LinksList 
    title='访问你的数据'
    links={[
        ["查询", "/docs/rqb"], 
        ["选择", "/docs/select"],
        ["插入", "/docs/insert"],
        ["更新", "/docs/update"],
        ["删除", "/docs/delete"],
        ["过滤器", "/docs/operators"],
        ["联接", "/docs/joins"],
        ["sql`` 操作符", "/docs/sql"],
      ]}
  />
  <LinksList 
    title='从零到英雄'
    links={[
        ["迁移", "/docs/migrations"], 
      ]}
  />
</Flex>


Source: https://drizzle.zhcndoc.com/docs/delete

import IsSupportedChipGroup from '@mdx/IsSupportedChipGroup.astro';
import Callout from '@mdx/Callout.astro';
import Section from '@mdx/Section.astro';

# SQL 删除
您可以删除表中的所有行：
```typescript copy
await db.delete(users);
```
您还可以使用过滤器和条件删除：
```typescript copy
await db.delete(users).where(eq(users.name, 'Dan'));
```

### 限制

<IsSupportedChipGroup chips={{ 'PostgreSQL': false, 'MySQL': true, 'SQLite': true, 'SingleStore': true }} />

使用 `.limit()` 向查询添加 `limit` 子句 - 例如：
<Section>
```typescript
await db.delete(users).where(eq(users.name, 'Dan')).limit(2);
```
```sql
delete from "users" where "users"."name" = $1 limit $2;
```
</Section>

### 按顺序排列
使用 `.orderBy()` 将 `order by` 子句添加到查询中，按指定字段对结果进行排序：
<Section>
```typescript
import { asc, desc } from 'drizzle-orm';

await db.delete(users).where(eq(users.name, 'Dan')).orderBy(users.name);
await db.delete(users).where(eq(users.name, 'Dan')).orderBy(desc(users.name));

// order by multiple fields
await db.delete(users).where(eq(users.name, 'Dan')).orderBy(users.name, users.name2);
await db.delete(users).where(eq(users.name, 'Dan')).orderBy(asc(users.name), desc(users.name2));
```
```sql
delete from "users" where "users"."name" = $1 order by "name";
delete from "users" where "users"."name" = $1 order by "name" desc;

delete from "users" where "users"."name" = $1 order by "name", "name2";
delete from "users" where "users"."name" = $1 order by "name" asc, "name2" desc;
```
</Section>

### 带返回值的删除
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'SQLite': true, 'MySQL': false, 'SingleStore': false}} />
您可以在 PostgreSQL 和 SQLite 中删除一行并获取返回值：
```typescript copy
const deletedUser = await db.delete(users)
  .where(eq(users.name, 'Dan'))
  .returning();

// 部分返回
const deletedUserIds: { deletedId: number }[] = await db.delete(users)
  .where(eq(users.name, 'Dan'))
  .returning({ deletedId: users.id });
```

## 使用 WITH DELETE 子句

<Callout>
  查看如何使用 WITH 语句与 [选择](/docs/select#with-clause)、[插入](/docs/insert#with-insert-clause)、[更新](/docs/update#with-update-clause)
</Callout>

使用 `with` 子句可以通过将复杂查询分割成称为公共表表达式（CTE）的小子查询来简化复杂查询：
<Section>
```typescript copy
const averageAmount = db.$with('average_amount').as(
  db.select({ value: sql`avg(${orders.amount})`.as('value') }).from(orders)
);

const result = await db
	.with(averageAmount)
	.delete(orders)
	.where(gt(orders.amount, sql`(select * from ${averageAmount})`))
	.returning({
		id: orders.id
	});
```
```sql
with "average_amount" as (select avg("amount") as "value" from "orders") 
delete from "orders" 
where "orders"."amount" > (select * from "average_amount") 
returning "id"
```
</Section>

Source: https://drizzle.zhcndoc.com/docs/drizzle-config-file

import CodeTab from "@mdx/CodeTab.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import Section from "@mdx/Section.astro";
import Tab from "@mdx/Tab.astro";
import Tabs from "@mdx/Tabs.astro";
import Callout from "@mdx/Callout.astro";
import SchemaFilePaths from "@mdx/SchemaFilePaths.mdx"
import Prerequisites from "@mdx/Prerequisites.astro"
import Dialects from "@mdx/Dialects.mdx"
import Drivers from "@mdx/Drivers.mdx"
import DriversExamples from "@mdx/DriversExamples.mdx"
import Npx from "@mdx/Npx.astro"

# Drizzle Kit 配置文件
<Prerequisites>
- 开始使用 Drizzle 和 `drizzle-kit` - [阅读这里](/docs/get-started)
- Drizzle 模式基础 - [阅读这里](/docs/sql-schema-declaration)
- 数据库连接基础 - [阅读这里](/docs/connect-overview)
- Drizzle 迁移基础 - [阅读这里](/docs/migrations)
- Drizzle Kit [概述](/docs/kit-overview) 以及 [配置文件](/docs/drizzle-config-file)
</Prerequisites>

Drizzle Kit 允许您在 `TypeScript` 或 `JavaScript` 配置文件中声明配置选项。

<Section>
```plaintext {5}
📦 <项目根目录>
 ├ ...
 ├ 📂 drizzle
 ├ 📂 src
 ├ 📜 drizzle.config.ts
 └ 📜 package.json
```
<CodeTabs items={["drizzle.config.ts", "drizzle.config.js"]}>
<CodeTab>
```ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql",
  schema: "./src/schema.ts",
  out: "./drizzle",
});
```
</CodeTab>
<CodeTab>
```js
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql",
  schema: "./src/schema.ts",
  out: "./drizzle",
});
```
</CodeTab>
</CodeTabs>
</Section>

扩展配置文件的示例
```ts collapsable
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  out: "./drizzle",
  dialect: "postgresql",
  schema: "./src/schema.ts",

  driver: "pglite",
  dbCredentials: {
    url: "./database/",
  },

  extensionsFilters: ["postgis"],
  schemaFilter: "public",
  tablesFilter: "*",

  introspect: {
    casing: "camel",
  },

  migrations: {
    prefix: "timestamp",
    table: "__drizzle_migrations__",
    schema: "public",
  },

  entities: {
    roles: {
      provider: '',
      exclude: [],
      include: []
    }
  },

  breakpoints: true,
  strict: true,
  verbose: true,
});
```

### 多个配置文件
您可以在项目中有多个配置文件，这在您有多个数据库环境、多个数据库或在同一个项目中有不同数据库时非常有用：
<Npx>
  drizzle-kit generate --config=drizzle-dev.config.ts
  drizzle-kit generate --config=drizzle-prod.config.ts
</Npx>
```plaintext {5-6}
📦 <项目根目录>
 ├ 📂 drizzle
 ├ 📂 src
 ├ 📜 .env
 ├ 📜 drizzle-dev.config.ts
 ├ 📜 drizzle-prod.config.ts
 ├ 📜 package.json
 └ 📜 tsconfig.json
```

### 迁移文件夹
`out` 参数让您定义迁移文件的文件夹，这是可选的，默认是 `drizzle`。  
这非常有用，因为您可以在同一个项目中有许多针对不同数据库的独立架构，
并为它们设置不同的迁移文件夹。  
  
迁移文件夹包含 `.sql` 迁移文件和 `_meta` 文件夹，后者由 `drizzle-kit` 使用。

<Section>
```plaintext {3}
📦 <项目根目录>
 ├ ...
 ├ 📂 drizzle
 │ ├ 📂 _meta
 │ ├ 📜 user.ts 
 │ ├ 📜 post.ts 
 │ └ 📜 comment.ts 
 ├ 📂 src
 ├ 📜 drizzle.config.ts
 └ 📜 package.json
```
```ts {5}
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql", // "mysql" | "sqlite" | "postgresql" | "turso" | "singlestore"
  schema: "./src/schema/*",
  out: "./drizzle",
});
```
</Section>

## ---

### `dialect`
<rem025/>

您使用的数据库的方言 
|               |                                                 |
| :------------ | :-----------------------------------            |
| 类型         | <Dialects/>                                     |
| 默认        | --                                     |
| 命令        | `generate` `migrate` `push` `pull` `check` `up` |

<rem025/>
```ts {4}
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "mysql", 
});
```


### `schema`
<rem025/>

[`glob`](https://www.digitalocean.com/community/tools/glob?comments=true&glob=/**/*.js&matches=false&tests=//%20This%20will%20match%20as%20it%20ends%20with%20'.js'&tests=/hello/world.js&tests=//%20This%20won't%20match!&tests=/test/some/globs)
 基于路径的 Drizzle 模式文件或包含模式文件的文件夹。
|               |                      |
| :------------ | :-----------------   |
| 类型          | `string` `string[]` |
| 默认        | --                    |
| 命令        | `generate` `push`    |

<rem025/>
<SchemaFilePaths />


### `out`
<rem025/>

定义您的 SQL 迁移文件、模式的 json 快照以及来自 `drizzle-kit pull` 命令的 `schema.ts` 的输出文件夹。
|               |                      |
| :------------ | :-----------------   |
| 类型          | `string` `string[]` |
| 默认        | `drizzle`                    |
| 命令        | `generate` `migrate` `push` `pull` `check` `up`    |

<rem025/>
```ts {4}
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  out: "./drizzle", 
});
```

### `driver`
<rem025/>

Drizzle Kit 会根据提供的 `dialect` 自动选择当前项目中可用的数据库驱动，
但某些供应商特定的数据库需要不同的连接参数子集。

`driver` 选项允许您明确选择这些例外驱动。

|               |                      |
| :------------ | :-----------------   |
| 类型          | <Drivers/> |
| 默认        | --                    |
| 命令        | `migrate` `push` `pull`   |

<rem025/>

<DriversExamples />

## ---

### `dbCredentials`
<rem025/>

以 `url` 的形式提供数据库连接凭据，
`user:password@host:port/db` 参数或特定驱动（<Drivers/>）的连接选项。

|               |                      |
| :------------ | :-----------------   |
| 类型          | 驱动连接选项的联合 |
| 默认       | --                    |
| 命令      | `migrate` `push` `pull`   |

<rem025/>

<CodeTabs items={["PostgreSQL", "MySQL", "SQLite", "Turso", "Cloudflare D1", "AWS Data API", "PGLite"]}>
<Section>
```ts
import { defineConfig } from 'drizzle-kit'

export default defineConfig({
  dialect: "postgresql",
  dbCredentials: {
    url: "postgres://user:password@host:port/db",
  }
});
```
```ts
import { defineConfig } from 'drizzle-kit'

// 通过连接参数
export default defineConfig({
  dialect: "postgresql",
  dbCredentials: {
    host: "host",
    port: 5432,
    user: "user",
    password: "password",
    database: "dbname",
    ssl: true, // 可以是布尔值 | "require" | "allow" | "prefer" | "verify-full" | node:tls 中的选项
  }
});
```
</Section>
<Section>
```ts
import { defineConfig } from 'drizzle-kit'

export default defineConfig({
  dialect: "mysql",
  dbCredentials: {
    url: "mysql://user:password@host:port/db",
  }
});
```
```ts
import { defineConfig } from 'drizzle-kit'

// 通过连接参数
export default defineConfig({
  dialect: "mysql",
  dbCredentials: {
    host: "host",
    port: 5432,
    user: "user",
    password: "password",
    database: "dbname",
    ssl: "...", // 可以是: string | SslOptions (来自 mysql2 包的 ssl 选项)
  }
});
```
</Section>
```ts
import { defineConfig } from 'drizzle-kit'

export default defineConfig({
  dialect: "sqlite",
  dbCredentials: {
    url: ":memory:", // 内存数据库
    // 或
    url: "sqlite.db", 
    // 或
    url: "file:sqlite.db" // file: 前缀是 libsql 所需的
  }
});
```
```ts
import { defineConfig } from 'drizzle-kit'

export default defineConfig({
  dialect: "turso",
  dbCredentials: {
    url: "libsql://acme.turso.io" // 远程 Turso 数据库 url
    authToken: "...",

    // 或如果您需要本地数据库

    url: ":memory:", // 内存数据库
    // 或
    url: "file:sqlite.db", // file: 前缀是 libsql 所需的
  }
});
```
```ts
import { defineConfig } from 'drizzle-kit'

export default defineConfig({
  dialect: "sqlite",
  driver: "d1-http",
  dbCredentials: {
    accountId: "",
    databaseId: "",
    token: "",
  }
});
```
```ts
import { defineConfig } from 'drizzle-kit'

export default defineConfig({
  dialect: "postgresql",
  driver: "aws-data-api",
  dbCredentials: {
    database: "database",
    resourceArn: "resourceArn",
    secretArn: "secretArn",
  },
});
```
```ts
import { defineConfig } from 'drizzle-kit'

export default defineConfig({
  dialect: "postgresql",
  driver: "pglite",
  dbCredentials: {
    url: "./database/", // 数据库文件夹路径
  }
});
```
</CodeTabs>

### `migrations`
<rem025/>

运行 `drizzle-kit migrate` 时，Drizzle 会在您的数据库中记录成功应用迁移的日志，
名为 `__drizzle_migrations` 的日志表在 `public` 模式下（仅适用于 PostgreSQL）。

`migrations` 配置选项让您可以更改迁移日志 `table` 名称和 `schema`。

|               |                      |
| :------------ | :-----------------   |
| 类型          | `{ table: string, schema: string }` |
| 默认       | `{ table: "__drizzle_migrations", schema: "drizzle" }`                    |
| 命令      | `migrate`   |

<rem025/>

```ts
export default defineConfig({
  dialect: "postgresql",
  schema: "./src/schema.ts",
  migrations: {
    table: 'my-migrations-table', // 默认是 `__drizzle_migrations`
    schema: 'public', // 仅在 PostgreSQL 中使用，默认是 `drizzle`
  },
});
```

### `introspect`
<rem025/>

`drizzle-kit pull` 命令的配置。

`casing` 负责代码中的列键大小写

|               |                      |
| :------------ | :-----------------   |
| 类型          | `{ casing: "preserve" \| "camel" }` |
| 默认       | `{ casing: "camel" }`                    |
| 命令      | `pull`   |

<rem025/>

<CodeTabs items={["camel", "preserve"]}>
<Section>
```ts
import * as p from "drizzle-orm/pg-core"

export const users = p.pgTable("users", {
  id: p.serial(),
  firstName: p.text("first-name"),
  lastName: p.text("LastName"),
  email: p.text(),
  phoneNumber: p.text("phone_number"),
});
```
```sql
SELECT a.attname AS column_name, format_type(a.atttypid, a.atttypmod) as data_type FROM pg_catalog.pg_attribute a;
```
``` 
 column_name   | data_type        
---------------+------------------------
 id            | serial
 first-name    | text
 LastName      | text
 email         | text
 phone_number  | text
```
</Section>
<Section>
```ts
import * as p from "drizzle-orm/pg-core"

export const users = p.pgTable("users", {
  id: p.serial(),
  "first-name": p.text("first-name"),
  LastName: p.text("LastName"),
  email: p.text(),
  phone_number: p.text("phone_number"),
});
```
```sql
SELECT a.attname AS column_name, format_type(a.atttypid, a.atttypmod) as data_type FROM pg_catalog.pg_attribute a;
```
``` 
 column_name   | data_type        
---------------+------------------------
 id            | serial
 first-name    | text
 LastName      | text
 email         | text
 phone_number  | text
```
</Section>
</CodeTabs>


## --- 

### `tablesFilter`
<Callout>
如果您想在一个数据库中运行多个项目 - 查看 [我们的指南](/docs/goodies#multi-project-schema)。
</Callout>
<rem025/>
`drizzle-kit push` 和 `drizzle-kit pull` 默认会管理 `public` 模式下的所有表。
您可以通过 `tablesFilters`、`schemaFilter` 和 `extensionFilters` 选项配置表、模式和扩展的列表。

`tablesFilter` 选项让您指定基于 [`glob`](https://www.digitalocean.com/community/tools/glob?comments=true&glob=/**/*.js&matches=false&tests=//%20This%20will%20match%20as%20it%20ends%20with%20'.js'&tests=/hello/world.js&tests=//%20This%20won't%20match!&tests=/test/some/globs) 的表名过滤，
例如 `["users", "user_info"]` 或者 `"user*"`

|               |                      |
| :------------ | :-----------------   |
| 类型          | `string` `string[]` |
| 默认       | --                    |
| 命令      | `generate` `push` `pull`   |

<rem025/>
```ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql",
  tablesFilter: ["users", "posts", "project1_*"],
});
```

### `schemaFilter`
<Callout>
如果您想在一个数据库中运行多个项目 - 查看 [我们的指南](/docs/goodies#multi-project-schema)。
</Callout>

<rem025/>
`drizzle-kit push` 和 `drizzle-kit pull` 默认会管理 `public` 模式下的所有表。
您可以通过 `tablesFilters`、`schemaFilter` 和 `extensionFilters` 选项配置表、模式和扩展的列表。

`schemaFilter` 选项让您指定 Drizzle Kit 要管理的模式列表

|               |                      |
| :------------ | :-----------------   |
| 类型          | `string[]` |
| 默认       | `["public"]`                    |
| 命令      | `push` `pull`   |

<rem025/>

```ts
export default defineConfig({
  dialect: "postgresql",
  schemaFilter: ["public", "schema1", "schema2"],
});
```

### `extensionsFilters`
<rem025/>

某些扩展如 [`postgis`](https://postgis.net/)，在数据库中安装后，会在公共模式中创建其自己的表。
这些表必须被 `drizzle-kit push` 或 `drizzle-kit pull` 忽略。

`extensionsFilters` 选项允许您声明一个安装扩展的列表，以便 Drizzle Kit 忽略其在模式中的表。

|               |                      |
| :------------ | :-----------------   |
| 类型          | `["postgis"]` |
| 默认       | `[]`                    |
| 命令      | `push` `pull`   |

<rem025/>

```ts
export default defineConfig({
  dialect: "postgresql",
  extensionsFilters: ["postgis"],
});
```

## ---

### `entities`

此配置用于设置数据库中特定 `实体` 的管理设置。

目前，它仅包括 `角色`，但最终所有数据库实体将迁移到这里，例如 `表`、`模式`、`扩展`、`函数`、`触发器` 等。

#### `roles`

<rem025/>

如果您使用 Drizzle Kit 来管理您的架构，特别是定义的角色，可能会出现一些角色未在 Drizzle 架构中定义的情况。
在这种情况下，您可能希望 Drizzle Kit 跳过那些 `roles`，而无需在您的 Drizzle 架构中逐一写出每个角色并用 `.existing()` 标记。

`roles` 选项让您可以：

- 启用或禁用与 Drizzle Kit 的角色管理。
- 排除特定角色不被 Drizzle Kit 管理。
- 包含特定角色以供 Drizzle Kit 管理。
- 为像 `Neon` 和 `Supabase` 这样的提供者启用模式，这些提供者不管理其特定角色。
- 组合上述所有选项。

|               |                       |
| :------------ | :-----------------    |
| type          | `boolean \| { provider: "neon" \| "supabase", include: string[], exclude: string[]}`|
| default       | `false`                  |
| commands      | `push` `pull` `generate` |

<rem025/>

默认情况下，`drizzle-kit` 不会为您管理角色，因此您需要在 `drizzle.config.ts` 中启用该功能。
```ts
export default defineConfig({
  dialect: "postgresql",
  entities: {
    roles: true
  }
});
```

**您有一个角色 `admin`，并希望将其排除在可管理角色列表之外**

```ts
// drizzle.config.ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  ...
  entities: {
    roles: {
      exclude: ['admin']
    }
  }
});
```

**您拥有一个角色 `admin`，并希望将其包含在可管理角色的列表中**

```ts
// drizzle.config.ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  ...
  entities: {
    roles: {
      include: ['admin']
    }
  }
});
```

如果您正在使用 `Neon` 并希望排除由 `Neon` 定义的角色，您可以使用提供者选项。

```ts
// drizzle.config.ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  ...
  entities: {
    roles: {
      provider: 'neon'
    }
  }
});
```

**如果您正在使用 `Supabase` 并希望排除由 `Supabase` 定义的角色，可以使用提供者选项**

```ts
// drizzle.config.ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  ...
  entities: {
    roles: {
      provider: 'supabase'
    }
  }
});
```

<Callout title='important'>
您可能会遇到 Drizzle 相对于数据库提供者指定的新角色略显过时的情况，
因此您可能需要同时使用 `provider` 选项和 `exclude` 附加角色。您可以轻松地使用 Drizzle 来做到这一点：

```ts
// drizzle.config.ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  ...
  entities: {
    roles: {
      provider: 'supabase',
      exclude: ['new_supabase_role']
    }
  }
});
```
</Callout>

## ---

### `strict`
<rem025/>

在运行 `drizzle-kit push` 命令时提示确认执行打印的 SQL 语句。

|               |                      |
| :------------ | :-----------------   |
| 类型          | `boolean` |
| 默认       | `false`                    |
| 命令      | `push`   |

<rem025/>

```ts
export default defineConfig({
  dialect: "postgresql",
  strict: false,
});
```

### `verbose`
<rem025/>

在 `drizzle-kit push` 命令期间打印所有 SQL 语句。

|               |                      |
| :------------ | :-----------------   |
| 类型          | `boolean` |
| 默认       | `true`                    |
| 命令      | `generate` `pull`   |

<rem025/>

```ts
export default defineConfig({
  dialect: "postgresql",
  verbose: false,
});
```

### `breakpoints`
<rem025/>

Drizzle Kit 将自动在生成的 SQL 迁移文件中嵌入 `--> statement-breakpoint`，
这对于不支持在一个事务中进行多个 DDL 更改语句的数据库（MySQL 和 SQLite）是必要的。

`breakpoints` 选项标志允许您开关此功能。

|               |                      |
| :------------ | :-----------------   |
| 类型          | `boolean` |
| 默认       | `true`                    |
| 命令      | `generate` `pull`   |

<rem025/>

```ts
export default defineConfig({
  dialect: "postgresql",
  breakpoints: false,
});
```


Source: https://drizzle.zhcndoc.com/docs/drizzle-kit-check

import CodeTab from "@mdx/CodeTab.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import Section from "@mdx/Section.astro";
import Tab from "@mdx/Tab.astro";
import Tabs from "@mdx/Tabs.astro";
import Callout from "@mdx/Callout.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import Npm from "@mdx/Npm.astro";
import Npx from "@mdx/Npx.astro";


# `drizzle-kit check`

<Prerequisites>
- 开始使用 Drizzle 和 `drizzle-kit` - [查看这里](/docs/get-started)
- Drizzle schema 基础知识 - [查看这里](/docs/sql-schema-declaration)
- 数据库连接基础知识 - [查看这里](/docs/connect-overview)
- Drizzle 迁移基础知识 - [查看这里](/docs/migrations)
- Drizzle Kit [概述](/docs/kit-overview) 和 [配置文件](/docs/drizzle-config-file)
- `drizzle-kit generate` 命令 - [查看这里](/docs/drizzle-kit-generate)
</Prerequisites>

`drizzle-kit check` 命令可以让你检查生成的 SQL 迁移历史的一致性。

当多个开发者在项目中工作并在不同的分支上更改数据库模式时，
这非常有用 - 了解更多有关 [团队迁移](/docs/kit-migrations-for-teams)。

<br/>
<hr/>
<br/>

`drizzle-kit check` 命令要求你指定 `dialect` 和数据库连接凭据，
你可以通过 [drizzle.config.ts](/docs/drizzle-config-file) 配置文件或 CLI 选项提供它们。

<CodeTabs items={["使用配置文件", "作为 CLI 选项"]}>
<Section>
```ts {5,8}
// drizzle.config.ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql",
});
```
```shell
npx drizzle-kit check
```
</Section>
```shell
npx drizzle-kit check --dialect=postgresql
```
</CodeTabs>

### 在一个项目中使用多个配置文件
你可以在项目中拥有多个配置文件，当你有多个数据库阶段或在同一项目中有多个数据库时，这非常有用：
<Npx>
  drizzle-kit migrate --config=drizzle-dev.config.ts
  drizzle-kit migrate --config=drizzle-prod.config.ts
</Npx>
```plaintext {5-6}
📦 <项目根目录>
 ├ 📂 drizzle
 ├ 📂 src
 ├ 📜 .env
 ├ 📜 drizzle-dev.config.ts
 ├ 📜 drizzle-prod.config.ts
 ├ 📜 package.json
 └ 📜 tsconfig.json
```

### 扩展配置选项列表
我们推荐通过 [drizzle.config.ts](/docs/drizzle-config-file) 文件配置 `drizzle-kit`，
但如有必要，你也可以通过 CLI 提供所有配置选项，例如在 CI/CD 管道中等。
<rem025/>
|           |            |                                                                         |
| :-------- | :--------- | :---------------------------------------------------------------------- |
| `dialect` | `required` | 你正在使用的数据库方言。可以是 `postgresql`、`mysql` 或 `sqlite` |
| `out`     |            | 迁移文件夹，默认为 `./drizzle`                                       |
| `config`  |            | 配置文件路径，默认为 `drizzle.config.ts`                             |
<br/>
<Npx>
drizzle-kit check --dialect=postgresql
drizzle-kit check --dialect=postgresql --out=./migrations-folder
</Npx>


Source: https://drizzle.zhcndoc.com/docs/drizzle-kit-export

import CodeTab from "@mdx/CodeTab.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import Section from "@mdx/Section.astro";
import Tab from "@mdx/Tab.astro";
import Tabs from "@mdx/Tabs.astro";
import Callout from "@mdx/Callout.astro";
import Prerequisites from "@mdx/Prerequisites.astro"
import Npx from "@mdx/Npx.astro";
import SchemaFilePaths from "@mdx/SchemaFilePaths.mdx"
import Dialects from "@mdx/Dialects.mdx"

# `drizzle-kit export`

<Prerequisites>
- 开始使用 Drizzle 和 `drizzle-kit` - [阅读这里](/docs/get-started)
- Drizzle 架构基础 - [阅读这里](/docs/sql-schema-declaration)
- 数据库连接基础 - [阅读这里](/docs/connect-overview)
- Drizzle 迁移基础 - [阅读这里](/docs/migrations)
- Drizzle Kit [概述](/docs/kit-overview) 和 [配置文件](/docs/drizzle-config-file)
</Prerequisites>

<br/>

`drizzle-kit export` 让你导出 Drizzle 架构的 SQL 表示，并在控制台打印其 SQL DDL 表示。
<Callout collapsed="它是如何在后台工作的？">
Drizzle Kit `export` 命令触发一系列事件：
1. 它将读取你的 Drizzle 架构文件并生成架构的 JSON 快照
3. 基于 JSON 差异，它将生成 SQL DDL 语句
4. 输出 SQL DDL 语句到控制台
</Callout>

它旨在覆盖 [代码优先](/docs/migrations) 的 Drizzle 迁移管理方法。  
你可以导出 Drizzle 架构的 SQL 表示，允许像 Atlas 这样的外部工具为你处理所有迁移。

`drizzle-kit export` 命令要求你提供 `dialect` 和 `schema` 路径选项，  
你可以通过 [drizzle.config.ts](/docs/drizzle-config-file) 配置文件或通过 CLI 选项设置它们。
<CodeTabs items={["使用配置文件", "作为 CLI 选项"]}>
<Section>
```ts
// drizzle.config.ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql",
  schema: "./src/schema.ts",
});
```
```shell
npx drizzle-kit export
```
</Section>

```shell
npx drizzle-kit export --dialect=postgresql --schema=./src/schema.ts
```
</CodeTabs>

### 架构文件路径
你可以拥有一个 `schema.ts` 文件，或者根据需要在项目中分布多个架构文件。  
Drizzle Kit 要求你通过 `schema` 配置选项指定文件路径，可以使用 [glob](https://www.digitalocean.com/community/tools/glob?comments=true&glob=/**/*.js&matches=false&tests=//%20This%20will%20match%20as%20it%20ends%20with%20'.js'&tests=/hello/world.js&tests=//%20This%20won't%20match!&tests=/test/some/globs) 来指定路径。

<SchemaFilePaths/>

### 一个项目中的多个配置文件
你可以在项目中使用多个配置文件，这在有多个数据库阶段或多个数据库，或同一项目中使用不同数据库时非常有用：
<Npx>
  drizzle-kit export --config=drizzle-dev.config.ts
  drizzle-kit export --config=drizzle-prod.config.ts
</Npx>
```plaintext {5-6}
📦 <项目根目录>
 ├ 📂 drizzle
 ├ 📂 src
 ├ 📜 .env
 ├ 📜 drizzle-dev.config.ts
 ├ 📜 drizzle-prod.config.ts
 ├ 📜 package.json
 └ 📜 tsconfig.json
```

### 可用配置项的扩展列表
`drizzle-kit export` 有一个仅限 CLI 的选项列表

<rem025/>

|               |                                                      |
| :--------     | :--------------------------------------------------- |
| `--sql`       | 生成 Drizzle 架构的 SQL 表示                              |

默认情况下，Drizzle Kit 输出 SQL 文件，但未来我们希望支持不同的格式

<rem025/>

<Npx>
drizzle-kit push --name=init
drizzle-kit push --name=seed_users --custom
</Npx>

<br/>
<hr/>
<br/>
我们推荐通过 [drizzle.config.ts](/docs/drizzle-config-file) 文件配置 `drizzle-kit`，  
但如果需要，也可以通过 CLI 提供所有配置选项，例如在 CI/CD 管道中等。

|               |            |                                                                            |
| :------------ | :-------   | :----------------------------------------------------------------------    |
| `dialect`     | `必需`     | 数据库方言，可选值见 <Dialects/>                                       |
| `schema`      | `必需`     | TypeScript 架构文件或包含多个架构文件的文件夹路径                        |
| `config`      |            | 配置文件路径，默认是 `drizzle.config.ts`                                |

### 示例
如何将 Drizzle 架构导出到控制台，Drizzle 架构位于 `./src/schema.ts`

我们还将把 Drizzle 配置文件放在 `configs` 文件夹中。

让我们创建配置文件：

```plaintext {4}
📦 <项目根目录>
 ├ 📂 configs
 │ └ 📜 drizzle.config.ts
 ├ 📂 src
 │ └ 📜 schema.ts
 └ …
```
```ts filename='drizzle.config.ts'
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql",
  schema: "./src/schema.ts",
});
```

```ts filename='schema.ts'
import { pgTable, serial, text } from 'drizzle-orm/pg-core'

export const users = pgTable('users', {
	id: serial('id').primaryKey(),
	email: text('email').notNull(),
	name: text('name')
});
```

现在让我们运行：
```shell
npx drizzle-kit export --config=./configs/drizzle.config.ts
```
它将成功输出 Drizzle 架构的 SQL 表示：
```bash
CREATE TABLE "users" (
        "id" serial PRIMARY KEY NOT NULL,
        "email" text NOT NULL,
        "name" text
);
```

Source: https://drizzle.zhcndoc.com/docs/drizzle-kit-generate

import CodeTab from "@mdx/CodeTab.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import Section from "@mdx/Section.astro";
import Tab from "@mdx/Tab.astro";
import Tabs from "@mdx/Tabs.astro";
import Callout from "@mdx/Callout.astro";
import Prerequisites from "@mdx/Prerequisites.astro"
import Npx from "@mdx/Npx.astro";
import SchemaFilePaths from "@mdx/SchemaFilePaths.mdx"
import Dialects from "@mdx/Dialects.mdx"

# `drizzle-kit generate`

<Prerequisites>
- 开始使用 Drizzle 和 `drizzle-kit` - [点击这里阅读](/docs/get-started)
- Drizzle 模式基础 - [点击这里阅读](/docs/sql-schema-declaration)
- 数据库连接基础 - [点击这里阅读](/docs/connect-overview)
- Drizzle 迁移基础 - [点击这里阅读](/docs/migrations)
- Drizzle Kit [概述](/docs/kit-overview) 和 [配置文件](/docs/drizzle-config-file)
</Prerequisites>


<br/>

`drizzle-kit generate` 允许您根据r Drizzle 模式在声明时或后续模式更改时生成 SQL 迁移。
<Callout collapsed="它是如何在后台工作的？">
Drizzle Kit `generate` 命令触发以下事件序列：
1. 它将读取您的 Drizzle 模式文件并创建模式的 JSON 快照
2. 它将读取您先前的迁移文件夹并将当前 JSON 快照与最新的快照进行比较
3. 基于 JSON 差异，它将生成 SQL 迁移
4. 保存 `migration.sql` 和 `snapshot.json` 在以当前时间戳命名的迁移文件夹中

<Section>
```typescript filename="src/schema.ts"
import * as p from "./drizzle-orm/pg-core";

export const users = p.pgTable("users", {
  id: p.serial().primaryKey(),
  name: p.text(),
  email: p.text().unique(), 
};
```
```                                  
┌────────────────────────┐                  
│ $ drizzle-kit generate │                  
└─┬──────────────────────┘                  
  │                                           
  └ 1. 读取先前的迁移文件夹
    2. 找到当前和先前模式之间的差异
    3. 如果需要，提示开发者重命名
  ┌ 4. 生成 SQL 迁移并持久化到文件
  │    ┌─┴───────────────────────────────────────┐  
  │      📂 drizzle       
  │      ├ 📂 _meta
  │      └ 📜 0000_premium_mister_fear.sql
  v
```
```sql
-- drizzle/0000_premium_mister_fear.sql

CREATE TABLE "users" (
 "id" SERIAL PRIMARY KEY,
 "name" TEXT,
 "email" TEXT UNIQUE
);
```
</Section>
</Callout>

它旨在覆盖 [代码优先](/docs/migrations) 的 Drizzle 迁移管理方法。
您可以使用 [`drizzle-kit migrate`](/docs/drizzle-kit-migrate) 应用生成的迁移，也可以使用 drizzle-orm 的 `migrate()`，
使用外部迁移工具，如 [bytebase](https://www.bytebase.com/)，或者直接在数据库上执行迁移。

`drizzle-kit generate` 命令要求您提供 `dialect` 和 `schema` 路径选项，
您可以通过 [drizzle.config.ts](/docs/drizzle-config-file) 配置文件或通过 CLI 选项设置它们。
<CodeTabs items={["使用配置文件", "作为 CLI 选项"]}>
<Section>
```ts
// drizzle.config.ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql",
  schema: "./src/schema.ts",
});
```
```shell
npx drizzle-kit generate
```
</Section>

```shell
npx drizzle-kit generate --dialect=postgresql --schema=./src/schema.ts
```
</CodeTabs>

### 模式文件路径
您可以有一个单独的 `schema.ts` 文件，或者在项目中拥有任意数量的模式文件。
Drizzle Kit 要求您通过 `schema` 配置选项以 [glob](https://www.digitalocean.com/community/tools/glob?comments=true&glob=/**/*.js&matches=false&tests=//%20This%20will%20match%20as%20it%20ends%20with%20'.js'&tests=/hello/world.js&tests=//%20This%20won't%20match!&tests=/test/some/globs) 指定路径。

<SchemaFilePaths/>


### 自定义迁移文件名
您可以通过提供 `--name` CLI 选项设置自定义迁移文件名。
```shell
npx drizzle-kit generate --name=init
```
```plaintext {4}
📦 <项目根目录>
 ├ 📂 drizzle
 │ ├ 📂 _meta
 │ └ 📜 0000_init.sql 
 ├ 📂 src
 └ …
```

### 项目中的多个配置文件
您可以在项目中拥有多个配置文件，这在您有多个数据库阶段、多个数据库或者在同一个项目上有不同数据库时非常有用：
<Npx>
  drizzle-kit generate --config=drizzle-dev.config.ts
  drizzle-kit generate --config=drizzle-prod.config.ts
</Npx>
```plaintext {5-6}
📦 <项目根目录>
 ├ 📂 drizzle
 ├ 📂 src
 ├ 📜 .env
 ├ 📜 drizzle-dev.config.ts
 ├ 📜 drizzle-prod.config.ts
 ├ 📜 package.json
 └ 📜 tsconfig.json
```

### 自定义迁移
您可以生成空的迁移文件以编写自己的自定义 SQL 迁移
用于当前不被 Drizzle Kit 支持的 DDL 更改或数据填充。有关自定义迁移的扩展文档 - [点击这里](/docs/kit-custom-migrations)

```shell
drizzle-kit generate --custom --name=seed-users
```
<Section>
```plaintext {5}
📦 <项目根目录>
 ├ 📂 drizzle
 │ ├ 📂 _meta
 │ ├ 📜 0000_init.sql 
 │ └ 📜 0001_seed-users.sql 
 ├ 📂 src
 └ …
```
```sql
-- ./drizzle/0001_seed-users.sql

INSERT INTO "users" ("name") VALUES('Dan');
INSERT INTO "users" ("name") VALUES('Andrew');
INSERT INTO "users" ("name") VALUES('Dandrew');
```
</Section>

### 可用配置的扩展列表
`drizzle-kit generate` 有一系列仅限 cli 的选项。

<rem025/>

|               |                                                      |
| :--------     | :--------------------------------------------------- |
| `custom`      | 生成自定义迁移的空 SQL 文件                     |
| `name`        | 生成自定义名称的迁移                             |

<rem025/>

<Npx>
drizzle-kit generate --name=init
drizzle-kit generate --name=seed_users --custom
</Npx>

<br/>
<hr/>
<br/>
我们推荐通过 [drizzle.config.ts](/docs/drizzle-config-file) 文件来配置 `drizzle-kit`，
但如果有必要，您也可以通过 CLI 提供所有配置选项，例如在 CI/CD 管道等中。

|               |            |                                                                            |
| :------------ | :-------   | :----------------------------------------------------------------------    |
| `dialect`     | `required` | 数据库方言，取值之一 <Dialects/>                                       |
| `schema`      | `required` | 指向 TypeScript 模式文件或包含多个模式文件的文件夹的路径             |
| `out`         |            | 迁移输出文件夹，默认为 `./drizzle`                                       |
| `config`      |            | 配置文件路径，默认为 `drizzle.config.ts`                                  |
| `breakpoints` |            | SQL 语句断点，默认值为 `true`                                            |


### 扩展示例
如何创建一个名为 `0001_seed-users.sql` 的自定义 PostgreSQL 迁移文件的示例。
Drizzle 模式位于 `./src/schema.ts`，迁移文件夹名为 `./migrations`，而不是默认的 `./drizzle`。

我们还将在 `configs` 文件夹中放置 drizzle 配置文件。

让我们创建配置文件：

```plaintext {4}
📦 <项目根目录>
 ├ 📂 migrations
 ├ 📂 configs
 │ └ 📜 drizzle.config.ts
 ├ 📂 src
 └ …
```
```ts filename='drizzle.config.ts'
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql",
  schema: "./src/schema.ts",
  out: "./migrations",
});
```

现在让我们运行：
```shell
npx drizzle-kit generate --config=./configs/drizzle.config.ts --name=seed-users --custom
```
它将成功生成：
<Section>
```plaintext {6}
📦 <项目根目录>
 ├ …
 ├ 📂 migrations
 │ ├ 📂 _meta
 │ ├ 📜 0000_init.sql 
 │ └ 📜 0001_seed-users.sql 
 └ …
```
```sql
-- ./drizzle/0001_seed-users.sql

INSERT INTO "users" ("name") VALUES('Dan');
INSERT INTO "users" ("name") VALUES('Andrew');
INSERT INTO "users" ("name") VALUES('Dandrew');
```
</Section>


Source: https://drizzle.zhcndoc.com/docs/drizzle-kit-migrate

import CodeTab from "@mdx/CodeTab.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import Section from "@mdx/Section.astro";
import Tab from "@mdx/Tab.astro";
import Tabs from "@mdx/Tabs.astro";
import Callout from "@mdx/Callout.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import Npx from "@mdx/Npx.astro";

# `drizzle-kit migrate`
<Prerequisites>
- 开始使用 Drizzle 和 `drizzle-kit` - [点击这里阅读](/docs/get-started)
- Drizzle 模式基础 - [点击这里阅读](/docs/sql-schema-declaration)
- 数据库连接基础 - [点击这里阅读](/docs/connect-overview)
- Drizzle 迁移基础 - [点击这里阅读](/docs/migrations)
- Drizzle Kit [概述](/docs/kit-overview) 和 [配置文件](/docs/drizzle-config-file)
- `drizzle-kit generate` 命令 - [点击这里阅读](/docs/drizzle-kit-generate)
</Prerequisites>
<br/>


`drizzle-kit migrate` 允许您应用由 [`drizzle-kit generate`](/docs/drizzle-kit-generate) 生成的 SQL 迁移。
它设计用于支持管理 Drizzle 迁移的 [代码优先（选项 3）](/docs/migrations) 方法。

<Callout collapsed="它是如何在后台工作的？">
Drizzle Kit `migrate` 命令触发一系列事件：
1. 读取迁移文件夹并读取所有 `.sql` 迁移文件
2. 连接到数据库并从 drizzle 迁移日志表中获取条目
3. 根据之前应用的迁移决定要运行哪些新迁移
4. 运行 SQL 迁移并将已应用的迁移记录到 drizzle 迁移表

<Section>
```plaintext
  ├ 📂 drizzle       
  │ ├ 📂 _meta
  │ ├ 📜 0000_premium_mister_fear.sql
  │ └ 📜 0001_delicate_professor_xavie.sql
  └ …
```
```plaintext
┌───────────────────────┐                  
│ $ drizzle-kit migrate │                  
└─┬─────────────────────┘                  
  │                                                         ┌──────────────────────────┐                                         
  └ 1. 读取迁移.sql 文件在迁移文件夹中       │                          │
    2. 从数据库获取迁移历史 -------------> │                          │
  ┌ 3. 选择之前未应用的迁移 <-------------- │         数据库         │
  └ 4. 将新迁移应用到数据库 ---------------> │                          │
                                                            │                          │
                                                            └──────────────────────────┘
[✓] 完成!        
```
</Section>
</Callout>

`drizzle-kit migrate` 命令要求您指定 `dialect` 和数据库连接凭据，
您可以通过 [drizzle.config.ts](/docs/drizzle-config-file) 配置文件或 CLI 选项提供这些信息。

<CodeTabs items={["使用配置文件", "作为 CLI 选项"]}>
<Section>
```ts {5,8}
// drizzle.config.ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql",
  schema: "./src/schema.ts",
  dbCredentials: {
    url: "postgresql://user:password@host:port/dbname"
  },
});
```
```shell
npx drizzle-kit migrate
```
</Section>
```shell
npx drizzle-kit migrate --dialect=postgresql --url=postgresql://user:password@host:port/dbname
```
</CodeTabs>

### 数据库中的已应用迁移日志
在运行迁移后，Drizzle Kit 将在您的数据库中持久化关于成功应用迁移的记录。
它将把这些记录存储在名为 `__drizzle_migrations` 的迁移日志表中。

您可以通过 drizzle 配置文件自定义该表的 **表** 和 **模式**（仅用于 PostgreSQL）：
```ts filename="drizzle.config.ts" {8-9}
export default defineConfig({
  dialect: "postgresql",
  schema: "./src/schema.ts",
  dbCredentials: {
    url: "postgresql://user:password@host:port/dbname"
  },
  migrations: {
    table: 'my-migrations-table', // 默认是 `__drizzle_migrations`
    schema: 'public', // 仅在 PostgreSQL 中使用，默认是 `drizzle`
  },
});
```

### 一个项目中的多个配置文件
您可以在项目中拥有多个配置文件，当您有多个数据库阶段或在同一项目中有多个数据库时，这非常有用：
<Npx>
  drizzle-kit migrate --config=drizzle-dev.config.ts
  drizzle-kit migrate --config=drizzle-prod.config.ts
</Npx>
```plaintext {5-6}
📦 <项目根目录>
 ├ 📂 drizzle
 ├ 📂 src
 ├ 📜 .env
 ├ 📜 drizzle-dev.config.ts
 ├ 📜 drizzle-prod.config.ts
 ├ 📜 package.json
 └ 📜 tsconfig.json
```

### 扩展示例
让我们生成 SQL 迁移并使用 `drizzle-kit generate` 和 `drizzle-kit migrate` 命令将其应用到我们的数据库。

```plaintext
📦 <项目根目录>
 ├ 📂 drizzle
 ├ 📂 src
 │ ├ 📜 schema.ts
 │ └ 📜 index.ts
 ├ 📜 drizzle.config.ts
 └ …
```
<CodeTabs items={["drizzle.config.ts", "src/schema.ts"]}>
```ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql",
  schema: "./src/schema.ts",
  dbCredentials: {
    url: "postgresql://user:password@host:port/dbname"
  },
  migrations: {
    table: 'journal', 
    schema: 'drizzle', 
  },
});
```
```ts 
import * as p from "drizzle-orm/pg-core";

export const users = p.pgTable("users", {
  id: p.serial().primaryKey(),
  name: p.text(),
})
```
</CodeTabs>

现在让我们运行
```shell
npx drizzle-kit generate --name=init
```
它将生成
<Section>
```plaintext {5}
📦 <项目根目录>
 ├ …
 ├ 📂 migrations
 │ ├ 📂 _meta
 │ └ 📜 0000_init.sql 
 └ …
```
```sql
-- ./drizzle/0000_init.sql

CREATE TABLE "users"(
  id serial primary key,
  name text
)
```
</Section>

现在让我们运行
```shell
npx drizzle-kit migrate
```

我们的 SQL 迁移现在已成功应用到数据库 ✅


Source: https://drizzle.zhcndoc.com/docs/drizzle-kit-pull

import CodeTab from "@mdx/CodeTab.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import Section from "@mdx/Section.astro";
import Tab from "@mdx/Tab.astro";
import Tabs from "@mdx/Tabs.astro";
import Callout from "@mdx/Callout.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import Drivers from "@mdx/Drivers.mdx"
import Dialects from "@mdx/Dialects.mdx"
import Npm from "@mdx/Npm.astro"
import Npx from "@mdx/Npx.astro"

# `drizzle-kit pull`

<Prerequisites>
  - 开始使用 Drizzle 和 `drizzle-kit` - [阅读这里](/docs/get-started)
  - Drizzle 模式基础 - [阅读这里](/docs/sql-schema-declaration) 
  - 数据库连接基础 - [阅读这里](/docs/connect-overview) 
  - Drizzle 迁移基础 - [阅读这里](/docs/migrations) 
  - Drizzle Kit [概述](/docs/kit-overview) 以及 [配置文件](/docs/drizzle-config-file) 文档
</Prerequisites>

`drizzle-kit pull` 允许你从现有数据库模式中提取（自省）数据，生成 `schema.ts` drizzle 模式文件，
它设计用于支持 Drizzle 迁移的 [数据库优先](/docs/migrations) 方法。

<Callout collapsed="它背后是如何工作的？">
当你运行 Drizzle Kit 的 `pull` 命令时，它会：
1. 从现有数据库中提取数据库模式（DDL）
2. 生成 `schema.ts` drizzle 模式文件并将其保存在 `out` 文件夹中

<Section>
```
                                  ┌────────────────────────┐      ┌─────────────────────────┐ 
                                  │                        │ <---  CREATE TABLE "users" (
┌──────────────────────────┐      │                        │        "id" SERIAL PRIMARY KEY,
│ ~ drizzle-kit pull       │      │                        │        "name" TEXT,
└─┬────────────────────────┘      │        DATABASE        │        "email" TEXT UNIQUE
  │                               │                        │       );
  └ Pull 数据库模式 --------> │                        │
  ┌ 生成 Drizzle 所需       <----- │                        │
  │ 模式 TypeScript 文件        └────────────────────────┘
  │
  v
```
```typescript
import * as p from "drizzle-orm/pg-core";

export const users = p.pgTable("users", {
  id: p.serial().primaryKey(),
  name: p.text(),
  email: p.text().unique(), 
};
```
</Section>
</Callout>

这是一个很好的方法，适合需要在 TypeScript 项目之外管理数据库模式的情况，或者
您正在使用一个由其他人管理的数据库。

<br/>
<hr/>
<br/>

`drizzle-kit pull` 要求您指定 `dialect` 以及
数据库连接 `url` 或 `user:password@host:port/db` 参数，您可以通过
[drizzle.config.ts](/docs/drizzle-config-file) 配置文件或通过 CLI 选项提供它们：

<CodeTabs items={["使用配置文件", "使用 CLI 选项"]}>
<Section>
```ts
// drizzle.config.ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql",
  dbCredentials: {
    url: "postgresql://user:password@host:port/dbname",
  },
});
```
```shell
npx drizzle-kit pull
```
</Section>

```shell
npx drizzle-kit pull --dialect=postgresql --url=postgresql://user:password@host:port/dbname
```
</CodeTabs>

### 在一个项目中使用多个配置文件

您可以在项目中拥有多个配置文件，当您有多个数据库阶段、多个数据库或同一项目中的不同数据库时，这非常有用：

<Npx>
  drizzle-kit pull --config=drizzle-dev.config.ts
  drizzle-kit pull --config=drizzle-prod.config.ts
</Npx>
```plaintext {5-6}
📦 <项目根目录>
 ├ 📂 drizzle
 ├ 📂 src
 ├ 📜 .env
 ├ 📜 drizzle-dev.config.ts
 ├ 📜 drizzle-prod.config.ts
 ├ 📜 package.json
 └ 📜 tsconfig.json
```

### 指定数据库驱动
<Callout type="warning">
**Expo SQLite** 和 **OP SQLite** 是设备内（每用户）数据库，无法从中 `pull` 数据库模式。<br/>
对于嵌入式数据库，Drizzle 提供 **嵌入式迁移** - 请查看我们的 [开始使用](/docs/get-started/expo-new) 指南。
</Callout>
Drizzle Kit 不自带预打包的数据库驱动，
它会根据当前项目中的 `dialect` 自动选择可用的数据库驱动 - [查看讨论](https://github.com/drizzle-team/drizzle-orm/discussions/2203)。

大多数相同方言的驱动共享相同的连接参数集，
对于像 `aws-data-api`、`pglight` 和 `d1-http` 这样的例外情况 - 您需要明确指定 `driver` 参数。

<CodeTabs items={["AWS Data API", "PGLite", "Cloudflare D1 HTTP"]}>
```ts {6}
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql",
  driver: "aws-data-api",
  dbCredentials: {
    database: "database",
    resourceArn: "resourceArn",
    secretArn: "secretArn",
  },
};
```
```ts {6}
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql",
  driver: "pglite",
  dbCredentials: {
    // 内存中
    url: ":memory:"
    
    // 或数据库文件夹
    url: "./database/"
  },
};
```
```ts {6}
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "sqlite",
  driver: "d1-http",
  dbCredentials: {
    accountId: "accountId",
    databaseId: "databaseId",
    token: "token",
  },
};
```
</CodeTabs>

### 包含表、模式和扩展
`drizzle-kit push` 默认会管理 `public` 模式中的所有表。
您可以通过 `tablesFilters`、`schemaFilter` 和 `extensionFilters` 选项配置表、模式和扩展的列表。

|                     |                                                                                               |
| :------------------ | :-------------------------------------------------------------------------------------------- |
| `tablesFilter`      | 基于 `glob` 的表名过滤器，例如 `["users", "user_info"]` 或 `"user*"`。默认为 `"*"` |
| `schemaFilter`      | 模式名过滤器，例如 `["public", "drizzle"]`。默认为 `["public"]`                    |
| `extensionsFilters` | 已安装的数据库扩展列表，例如 `["postgis"]`。默认为 `[]`                    |
<br/>

让我们配置 drizzle-kit 只操作 **public** 模式中的 **所有表**，
并告知 drizzle-kit 已安装了 **postgis** 扩展， 
以使其可以忽略在公共模式中创建自己的表。

<Section>
```ts filename="drizzle.config.ts" {9-11}
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql",
  schema: "./src/schema.ts",
  dbCredentials: {
    url: "postgresql://user:password@host:port/dbname",
  },
  extensionsFilters: ["postgis"],
  schemaFilter: ["public"],
  tablesFilter: ["*"],
});
```
```shell
npx drizzle-kit push
```
</Section>

### 扩展的配置列表
我们建议通过 [drizzle.config.ts](/docs/drizzle-config-file) 文件来配置 `drizzle-kit`， 
不过如果必要的话，您也可以通过 CLI 提供所有配置选项，例如在 CI/CD 管道中等。

|                     |            |                                                                           |
| :------------------ | :--------- | :------------------------------------------------------------------------ |
| `dialect`           | `必需`     | 数据库方言, 选项之一 <Dialects/>                                      |
| `driver`            |            | 驱动程序例外 <Drivers/>                                             |
| `out`               |            | 迁移输出文件夹路径，默认是 `./drizzle`                     |
| `url`               |            | 数据库连接字符串                                                |
| `user`              |            | 数据库用户                                                             |
| `password`          |            | 数据库密码                                                         |
| `host`              |            | 主机                                                                      |
| `port`              |            | 端口                                                                      |
| `database`          |            | 数据库名称                                                             |
| `config`            |            | 配置文件路径，默认是 `drizzle.config.ts`                          |
| `introspect-casing` |            | 列、表等中 JS 键创建的策略，`preserve` `camel` |
| `tablesFilter`      |            | 表名过滤器                                                         |
| `schemaFilter`      |            | 模式名过滤器。默认为 `["public"]`                                 |
| `extensionsFilters` |            | 数据库扩展的内部数据库过滤器                             |

<Npx>
drizzle-kit pull --dialect=postgresql --url=postgresql://user:password@host:port/dbname
drizzle-kit pull --dialect=postgresql --driver=pglite url=database/
drizzle-kit pull --dialect=postgresql --tablesFilter='user*' --extensionsFilters=postgis url=postgresql://user:password@host:port/dbname
</Npx>

![](@/assets/gifs/introspect_mysql.gif)


Source: https://drizzle.zhcndoc.com/docs/drizzle-kit-push

import CodeTab from "@mdx/CodeTab.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import Section from "@mdx/Section.astro";
import Tab from "@mdx/Tab.astro";
import Tabs from "@mdx/Tabs.astro";
import Callout from "@mdx/Callout.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import Npx from "@mdx/Npx.astro";
import SchemaFilePaths from "@mdx/SchemaFilePaths.mdx";
import Drivers from "@mdx/Drivers.mdx"
import Dialects from "@mdx/Dialects.mdx"
import DriversExamples from "@mdx/DriversExamples.mdx"

# `drizzle-kit push`

<Prerequisites>
  - 从 Drizzle 和 `drizzle-kit` 开始 - [点击这里阅读](/docs/get-started)
  - Drizzle 模式基础 - [点击这里阅读](/docs/sql-schema-declaration) 
  - 数据库连接基础 - [点击这里阅读](/docs/connect-overview) 
  - Drizzle 迁移基础 - [点击这里阅读](/docs/migrations) 
  - Drizzle Kit [概述](/docs/kit-overview) 和 [配置文件](/docs/drizzle-config-file) 文档
</Prerequisites>


`drizzle-kit push` 允许你直接将你的模式及后续的模式变化推送到数据库，
同时省略 SQL 文件的生成，
旨在覆盖 Drizzle 迁移的 [代码优先](/docs/migrations) 方法。

<Callout collapsed="它是如何在内部工作的？">
当你运行 Drizzle Kit 的 `push` 命令时，它会：
1. 读取你的 Drizzle 模式文件并组成一个 JSON 快照
2. 拉取（内省）数据库模式 
3. 根据这两者之间的差异生成 SQL 迁移
4. 将 SQL 迁移应用到数据库

<Section>
```typescript filename="src/schema.ts"
import * as p from "drizzle-orm/pg-core";

export const users = p.pgTable("users", {
  id: p.serial().primaryKey(),
  name: p.text(),
};
```
```
┌─────────────────────┐                  
│ ~ drizzle-kit push  │                  
└─┬───────────────────┘                  
  │                                           ┌──────────────────────────┐
  └ Pull current datatabase schema ---------> │                          │
                                              │                          │
  ┌ Generate alternations based on diff <---- │         DATABASE         │
  │                                           │                          │
  └ Apply migrations to the database -------> │                          │
                                       │      └──────────────────────────┘
                                       │
  ┌────────────────────────────────────┴────────────────┐
   create table users(id serial primary key, name text);
```
</Section>
</Callout>

这是快速原型设计的最佳方法，
我们已经看到数十个团队和独立开发者成功地将其作为他们生产应用中的主要迁移流程。
它与蓝绿部署策略和无服务器数据库如
[Planetscale](https://planetscale.com)、[Neon](https://neon.tech)、[Turso](https://turso.tech/drizzle) 等非常契合。

<br/>
<hr/>
<br/>


`drizzle-kit push` 需要你指定 `dialect`、模式文件的路径，
并提供数据库连接的 `url` 或 `user:password@host:port/db` 参数，
你可以通过 [drizzle.config.ts](/docs/drizzle-config-file) 配置文件或 CLI 选项提供它们：

<CodeTabs items={["使用配置文件", "使用 CLI 选项"]}>
<Section>
```ts
// drizzle.config.ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql",
  schema: "./src/schema.ts",
  dbCredentials: {
    url: "postgresql://user:password@host:port/dbname",
  },
});
```
```shell
npx drizzle-kit push
```
</Section>

```shell
npx drizzle-kit push --dialect=postgresql --schema=./src/schema.ts --url=postgresql://user:password@host:port/dbname
```

</CodeTabs>

### 模式文件路径

你可以有一个单独的 `schema.ts` 文件，也可以根据需要在项目中分散多个模式文件。
Drizzle Kit 要求你通过 `schema` 配置选项作为 [glob](https://www.digitalocean.com/community/tools/glob?comments=true&glob=/**/*.js&matches=false&tests=//%20This%20will%20match%20as%20it%20ends%20with%20'.js'&tests=/hello/world.js&tests=//%20This%20won't%20match!&tests=/test/some/globs) 指定它们的路径。

<SchemaFilePaths />

### 项目中多个配置文件

你可以在项目中有多个配置文件，当你有多个数据库阶段、多个数据库或同一项目中的不同数据库时，这非常有用：

<Npx>
  drizzle-kit push --config=drizzle-dev.config.ts
  drizzle-kit push --config=drizzle-prod.config.ts
</Npx>
```plaintext {5-6}
📦 <项目根目录>
 ├ 📂 drizzle
 ├ 📂 src
 ├ 📜 .env
 ├ 📜 drizzle-dev.config.ts
 ├ 📜 drizzle-prod.config.ts
 ├ 📜 package.json
 └ 📜 tsconfig.json
```

### 指定数据库驱动
<Callout type="warning">
**Expo SQLite** 和 **OP SQLite** 是设备上的（每用户）数据库，无法在其中 `push` 迁移。<br/>
对于嵌入式数据库，Drizzle 提供了 **嵌入式迁移** - 查看我们的 [快速开始](/docs/get-started/expo-new) 指南。
</Callout>
Drizzle Kit 不包含预打包的数据库驱动，
它将根据当前项目的 `dialect` 自动选择可用的数据库驱动 - [查看讨论](https://github.com/drizzle-team/drizzle-orm/discussions/2203)。

大多数同一方言的驱动程序共享相同的连接参数，
至于像 `aws-data-api`、`pglight` 和 `d1-http` 的例外情况，你将需要显式指定 `driver` 参数。

<DriversExamples/>

### 包括表、模式和扩展
`drizzle-kit push` 默认管理 `public` 模式中的所有表。
你可以通过 `tablesFilters`、`schemaFilter` 和 `extensionFilters` 选项配置表、模式和扩展的列表。

|                     |                                                                                               |
| :------------------ | :-------------------------------------------------------------------------------------------- |
| `tablesFilter`      | 基于 `glob` 的表名过滤器，例如 `["users", "user_info"]` 或 `"user*" `。默认是 `"*"` |
| `schemaFilter`      | 模式名过滤器，例如 `["public", "drizzle"]`。默认是 `["public"]`                    |
| `extensionsFilters` | 已安装数据库扩展的列表，例如 `["postgis"]`。默认是 `[]`                    |
<br/>

让我们配置 drizzle-kit 只操作 **public** 模式中的 **所有表**，
并让 drizzle-kit 知道有一个安装的 **postgis** 扩展，
它会在 public 模式中创建自己的表，因此 drizzle 可以忽略它们。

<Section>
```ts filename="drizzle.config.ts" {9-11}
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql",
  schema: "./src/schema.ts",
  dbCredentials: {
    url: "postgresql://user:password@host:port/dbname",
  },
  extensionsFilters: ["postgis"],
  schemaFilter: ["public"],
  tablesFilter: ["*"],
});
```
```shell
npx drizzle-kit push
```
</Section>

### 扩展的配置选项列表

`drizzle-kit push` 有一些仅限于 CLI 的选项

<rem025/>

|           |                                                          |
| :-------- | :---------------------------------------------------     |
| `verbose` | 执行前打印所有 SQL 语句                                   |
| `strict`  | 执行 SQL 语句前始终要求确认                             |
| `force`   | 自动接受所有数据丢失的语句                               |
<br/>
<Npx>
drizzle-kit push --strict --verbose --force
</Npx>

<br/>
<hr/>
<br/>
我们推荐通过 [drizzle.config.ts](/docs/drizzle-config-file) 文件配置 `drizzle-kit`，
但如果有必要，你可以通过 CLI 提供所有配置选项，例如在 CI/CD 管道中等。

|                     |            |                                                                           |
| :------------------ | :--------- | :------------------------------------------------------------------------ |
| `dialect`           | `required` | 数据库方言，必须是 <Dialects/>                                      |
| `schema`            | `required` | 指向 TypeScript 模式文件或包含多个模式文件的文件夹的路径 |
| `driver`            |            | 驱动程序例外 <Drivers/>                                             |
| `tablesFilter`      |            | 表名过滤器                                                         |
| `schemaFilter`      |            | 模式名称过滤器。默认：`["public"]`                                 |
| `extensionsFilters` |            | 数据库扩展内部数据库过滤器                             |
| `url`               |            | 数据库连接字符串                                                |
| `user`              |            | 数据库用户                                                             |
| `password`          |            | 数据库密码                                                         |
| `host`              |            | 主机                                                                      |
| `port`              |            | 端口                                                                      |
| `database`          |            | 数据库名称                                                             |
| `config`            |            | 配置文件路径，默认=`drizzle.config.ts`                             |

<Npx>
drizzle-kit push dialect=postgresql schema=src/schema.ts url=postgresql://user:password@host:port/dbname
drizzle-kit push dialect=postgresql schema=src/schema.ts driver=pglite url=database/
drizzle-kit push dialect=postgresql schema=src/schema.ts --tablesFilter='user*' --extensionsFilters=postgis url=postgresql://user:password@host:port/dbname
</Npx>


### 扩展示例
让我们在项目中声明 drizzle 模式并通过 `drizzle-kit push` 命令将其推送到数据库

```plaintext
📦 <项目根目录>
 ├ 📂 src
 │ ├ 📜 schema.ts
 │ └ 📜 index.ts
 ├ 📜 drizzle.config.ts
 └ …
```
<CodeTabs items={["drizzle.config.ts", "src/schema.ts"]}>
```ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql",
  schema: "./src/schema.ts",
  dbCredentials: {
    url: "postgresql://user:password@host:port/dbname"
  },
});
```
```ts 
import * as p from "drizzle-orm/pg-core";

export const users = p.pgTable("users", {
  id: p.serial().primaryKey(),
  name: p.text(),
})
```
</CodeTabs>

现在让我们运行
```shell
npx drizzle-kit push
```

它将从数据库中拉取现有（空）模式，生成 SQL 迁移并在后台应用它
```sql
CREATE TABLE "users"(
  id serial primary key,
  name text
)
```

完成 ✅


Source: https://drizzle.zhcndoc.com/docs/drizzle-kit-studio

import CodeTab from "@mdx/CodeTab.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import Section from "@mdx/Section.astro";
import Tab from "@mdx/Tab.astro";
import Tabs from "@mdx/Tabs.astro";
import Callout from "@mdx/Callout.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import Npm from "@mdx/Npm.astro";
import Npx from "@mdx/Npx.astro";


# `drizzle-kit studio`
<Prerequisites>
- Drizzle Kit [概述](/docs/kit-overview) 和 [配置文件](/docs/drizzle-config-file)
- Drizzle Studio，我们的数据库浏览器 - [阅读这里](/drizzle-studio/overview)
</Prerequisites>

`drizzle-kit studio` 命令启动一个用于 [Drizzle Studio](/drizzle-studio/overview) 的服务器，托管在 [local.drizzle.studio](https://local.drizzle.studio)。 
它要求您通过 [drizzle.config.ts](/docs/drizzle-config-file) 配置文件指定数据库连接凭据。

默认情况下，它将在 `127.0.0.1:4983` 启动 Drizzle Studio 服务器。
<Section>
```ts {6}
// drizzle.config.ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql",
  dbCredentials: {
    url: "postgresql://user:password@host:port/dbname"
  },
});
```
```shell
npx drizzle-kit migrate
```
</Section>

### 配置 `host` 和 `port`
默认情况下，Drizzle Studio 服务器在 `127.0.0.1:4983` 启动， 
您可以通过 CLI 选项配置 `host` 和 `port`。

<Npx>
drizzle-kit studio --port=3000
drizzle-kit studio --host=0.0.0.0
drizzle-kit studio --host=0.0.0.0 --port=3000
</Npx>


### 日志记录
您可以通过提供 `verbose` 标志来启用每个 SQL 语句的日志记录。

<Npx>
drizzle-kit studio --verbose
</Npx>

### Safari 和 Brave 支持
Safari 和 Brave 默认阻止对 localhost 的访问。 
您需要安装 [mkcert](https://github.com/FiloSottile/mkcert) 并生成自签名证书：

1. 按照 mkcert [安装步骤](https://github.com/FiloSottile/mkcert#installation) 操作
2. 运行 `mkcert -install`
3. 重启您的 `drizzle-kit studio`

### 可嵌入的 Drizzle Studio 版本
虽然本地开发的 Drizzle Studio 托管版本是免费使用的，并旨在丰富 Drizzle 生态系统， 
我们也提供 B2B 的可嵌入版 Drizzle Studio 供企业使用。

**Drizzle Studio 组件** - 是一个预打包的框架无关的 Drizzle Studio 网页组件， 
您可以将其嵌入到您的 UI 中，如 `React` `Vue` `Svelte` `VanillaJS` 等等。

这是一个极具力量的 UI 元素，可以提升您的产品 
如果您提供的是数据库作为 SaaS 或基于 SQL 的数据中心 SaaS 解决方案， 
或者用于私有的非客户可见的内部使用。

使用 Drizzle Studio 的数据库平台：
- [Turso](https://turso.tech/)，自 2023 年 10 月以来我们的第一位客户！
- [Neon](https://neon.tech/)，[发布帖子](https://neon.tech/docs/changelog/2024-05-24)
- [Hydra](https://www.hydra.so/)

使用 Drizzle Studio 的数据中心平台：
- [Nuxt Hub](https://hub.nuxt.com/)，Sébastien Chopin 的 [发布帖子](https://x.com/Atinux/status/1768663789832929520)
- [Deco.cx](https://deco.cx/)

您可以在 [这里](https://www.npmjs.com/package/@drizzle-team/studio) 阅读详细概述， 
如果您感兴趣 - 可以通过 [Twitter](https://x.com/drizzleorm) 的私信与我们联系，或在 [Discord #drizzle-studio](https://driz.link/discord) 频道中与我们交流。

### Drizzle Studio Chrome 扩展
Drizzle Studio [Chrome 扩展](https://chromewebstore.google.com/detail/drizzle-studio/mjkojjodijpaneehkgmeckeljgkimnmd) 
让您可以直接在其供应商管理面板中浏览您的 [PlanetScale](https://planetscale.com)、 
[Cloudflare](https://developers.cloudflare.com/d1/) 和 [Vercel Postgres](https://vercel.com/docs/storage/vercel-postgres) 
无服务器数据库！

### 限制
我们的托管版本 Drizzle Studio 旨在用于本地开发，不适用于远程（VPS 等）。

如果您希望将 Drizzle Studio 部署到 VPS - 我们有一个 Drizzle Studio Gateway 的 alpha 版本， 
欢迎通过 [Twitter](https://x.com/drizzleorm) 的私信与我们联系，或在 [Discord #drizzle-studio](https://driz.link/discord) 频道中与我们询问。

### 它是开源的吗？
不是。Drizzle ORM 和 Drizzle Kit 完全开源，而 Studio 不是。

Drizzle Studio 用于本地开发永久免费，以丰富 Drizzle 生态系统，开源一个将打破我们提供 B2B 服务和盈利的能力，不幸的是。

Source: https://drizzle.zhcndoc.com/docs/drizzle-kit-up

import CodeTab from "@mdx/CodeTab.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import Section from "@mdx/Section.astro";
import Tab from "@mdx/Tab.astro";
import Tabs from "@mdx/Tabs.astro";
import Callout from "@mdx/Callout.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import Npx from "@mdx/Npx.astro";

# `drizzle-kit up`

<Prerequisites>
- 开始使用 Drizzle 和 `drizzle-kit` - [阅读这里](/docs/get-started)
- Drizzle 模式基础 - [阅读这里](/docs/sql-schema-declaration)
- 数据库连接基础 - [阅读这里](/docs/connect-overview)
- Drizzle 迁移基础 - [阅读这里](/docs/migrations)
- Drizzle Kit [概述](/docs/kit-overview) 和 [配置文件](/docs/drizzle-config-file)
- `drizzle-kit generate` 命令 - [阅读这里](/docs/drizzle-kit-generate)
</Prerequisites>

`drizzle-kit up` 命令允许您将 drizzle 模式快照升级到新版本。
每当我们引入对模式的 json 快照的破坏性更改并升级内部版本时，都会要求使用此命令。

<br/>
<hr/>
<br/>

`drizzle-kit up` 命令要求您指定 `dialect` 和数据库连接凭据，
您可以通过 [drizzle.config.ts](/docs/drizzle-config-file) 配置文件或通过 CLI 选项提供它们。

<CodeTabs items={["使用配置文件", "作为 CLI 选项"]}>
<Section>
```ts {5,8}
// drizzle.config.ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql",
});
```
```shell
npx drizzle-kit up
```
</Section>
```shell
npx drizzle-kit up --dialect=postgresql
```
</CodeTabs>

### 一个项目中的多个配置文件
您可以在项目中拥有多个配置文件，这在您有多个数据库环境或在同一项目中使用多个数据库时非常有用：
<Npx>
  drizzle-kit migrate --config=drizzle-dev.config.ts
  drizzle-kit migrate --config=drizzle-prod.config.ts
</Npx>
```plaintext {5-6}
📦 <项目根目录>
 ├ 📂 drizzle
 ├ 📂 src
 ├ 📜 .env
 ├ 📜 drizzle-dev.config.ts
 ├ 📜 drizzle-prod.config.ts
 ├ 📜 package.json
 └ 📜 tsconfig.json
```

### 扩展的配置选项列表
我们推荐通过 [drizzle.config.ts](/docs/drizzle-config-file) 文件配置 `drizzle-kit`，
但是如果需要，您也可以通过 CLI 提供所有配置选项，例如在 CI/CD 流水线中等。
<rem025/>
|           |            |                                                                         |
| :-------- | :--------- | :---------------------------------------------------------------------- |
| `dialect` | `必需`    | 您正在使用的数据库方言。可以是 `postgresql`, `mysql` 或 `sqlite`      |
| `out`     |            | 迁移文件夹，默认=`./drizzle`                                          |
| `config`  |            | 配置文件路径，默认=`drizzle.config.ts`                               |
<br/>
<Npx>
drizzle-kit up --dialect=postgresql
drizzle-kit up --dialect=postgresql --out=./migrations-folder
</Npx>

![](@/assets/gifs/up_mysql.gif)



Source: https://drizzle.zhcndoc.com/docs/dynamic-query-building

import Callout from '@mdx/Callout.astro';

# 动态查询构建

默认情况下，Drizzle 中的所有查询构建器尽量遵循 SQL，因此大多数方法只能调用一次。
例如，在 `SELECT` 语句中，可能只有一个 `WHERE` 子句，因此你只能调用一次 `.where()`：

```ts
const query = db
	.select()
	.from(users)
	.where(eq(users.id, 1))
	.where(eq(users.name, 'John')); // ❌ 类型错误 - where() 只能调用一次
```

在以前的 ORM 版本中，由于没有实现这些限制，特别是这个例子对许多用户来说是个困惑，因为他们期望查询构建器能够“合并”多个 `.where()` 调用成为一个条件。

这种行为对于传统查询构建很有用，即在一次性创建整个查询时。
然而，当你想动态构建查询时，比如拥有一个接收查询构建器并进行增强的共享函数时，这就成了一个问题。
为了解决这个问题，Drizzle 提供了一个特殊的“动态”模式，用于查询构建器，这消除了只能调用方法一次的限制。
要启用它，你需要在查询构建器上调用 `.$dynamic()`。

让我们通过实现一个简单的 `withPagination` 函数来看看它是如何工作的，该函数根据提供的页码和可选的页面大小，为查询添加 `LIMIT` 和 `OFFSET` 子句：

```ts
function withPagination<T extends PgSelect>(
	qb: T,
	page: number = 1,
	pageSize: number = 10,
) {
	return qb.limit(pageSize).offset((page - 1) * pageSize);
}

const query = db.select().from(users).where(eq(users.id, 1));
withPagination(query, 1); // ❌ 类型错误 - 查询构建器未处于动态模式

const dynamicQuery = query.$dynamic();
withPagination(dynamicQuery, 1); // ✅ 正常
```

请注意，`withPagination` 函数是泛型的，这使你能够在其中修改查询构建器的结果类型，例如通过添加连接：

```ts
function withFriends<T extends PgSelect>(qb: T) {
	return qb.leftJoin(friends, eq(friends.userId, users.id));
}

let query = db.select().from(users).where(eq(users.id, 1)).$dynamic();
query = withFriends(query);
```

这可能是因为 `PgSelect` 和其他类似类型专门设计用于动态查询构建。它们只能在动态模式下使用。

以下是可以作为泛型参数用于动态查询构建的所有类型列表：

{

<table>
	<thead align='center'>
		<tr>
			<td>
				<b>方言</b>
			</td>
			<td colspan='4'>
				<b>类型</b>
			</td>
		</tr>
		<tr>
			<td>
				<b>查询</b>
			</td>
			<td>
				<b>选择</b>
			</td>
			<td>
				<b>插入</b>
			</td>
			<td>
				<b>更新</b>
			</td>
			<td>
				<b>删除</b>
			</td>
		</tr>
	</thead>
	<tbody>
		<tr align='center'>
			<td rowspan='2'>Postgres</td>
			<td>
				<code>PgSelect</code>
			</td>
			<td rowspan='2'>
				<code>PgInsert</code>
			</td>
			<td rowspan='2'>
				<code>PgUpdate</code>
			</td>
			<td rowspan='2'>
				<code>PgDelete</code>
			</td>
		</tr>
		<tr align='center'>
			<td>
				<code>PgSelectQueryBuilder</code>
			</td>
		</tr>
		<tr align='center'>
			<td rowspan='2'>MySQL</td>
			<td>
				<code>MySqlSelect</code>
			</td>
			<td rowspan='2'>
				<code>MySqlInsert</code>
			</td>
			<td rowspan='2'>
				<code>MySqlUpdate</code>
			</td>
			<td rowspan='2'>
				<code>MySqlDelete</code>
			</td>
		</tr>
		<tr align='center'>
			<td>
				<code>MySqlSelectQueryBuilder</code>
			</td>
		</tr>
		<tr align='center'>
			<td rowspan='2'>SQLite</td>
			<td>
				<code>SQLiteSelect</code>
			</td>
			<td rowspan='2'>
				<code>SQLiteInsert</code>
			</td>
			<td rowspan='2'>
				<code>SQLiteUpdate</code>
			</td>
			<td rowspan='2'>
				<code>SQLiteDelete</code>
			</td>
		</tr>
		<tr align='center'>
			<td>
				<code>SQLiteSelectQueryBuilder</code>
			</td>
		</tr>
	</tbody>
</table>

}

<Callout type='info'>
	`...QueryBuilder` 类型用于与 [独立查询构建器实例](/docs/goodies#standalone-query-builder) 一起使用。
	数据库查询构建器是它们的子类，
	因此你也可以使用它们。

    ```ts
    	import { QueryBuilder } from 'drizzle-orm/pg-core';

    	function withFriends<T extends PgSelectQueryBuilder>(qb: T) {
    		return qb.leftJoin(friends, eq(friends.userId, users.id));
    	}

    	const qb = new QueryBuilder();
    	let query = qb.select().from(users).where(eq(users.id, 1)).$dynamic();
    	query = withFriends(query);
    ```

</Callout>


Source: https://drizzle.zhcndoc.com/docs/eslint-plugin

import Tabs from '@mdx/Tabs.astro';
import Tab from '@mdx/Tab.astro';
import Npm from '@mdx/Npm.astro';

# ESLint Drizzle 插件

对于无法进行特定场景类型检查的情况，或者虽然可以进行但错误消息难以理解的情况，我们决定创建一个包含推荐规则的 ESLint 包。这个包旨在帮助开发人员在开发中处理关键场景。

## 安装

<Npm>
eslint-plugin-drizzle
@typescript-eslint/eslint-plugin @typescript-eslint/parser
</Npm>

## 用法

**`.eslintrc.yml` 示例**
```yml
root: true
parser: '@typescript-eslint/parser'
parserOptions:
  project: './tsconfig.json'
plugins:
  - drizzle
rules:
  'drizzle/enforce-delete-with-where': "error"
  'drizzle/enforce-update-with-where': "error"
```

**所有配置**

此插件导出一个 `all`，它使用所有规则（除已弃用的规则外）。

```yml
root: true
extends:
  - "plugin:drizzle/all"
parser: '@typescript-eslint/parser'
parserOptions:
  project: './tsconfig.json'
plugins:
  - drizzle
```

**推荐配置**

目前，`all` 等同于 `recommended`。

```yml
root: true
extends:
  - "plugin:drizzle/recommended"
parser: '@typescript-eslint/parser'
parserOptions:
  project: './tsconfig.json'
plugins:
  - drizzle
```

## 规则

### **enforce-delete-with-where**

强制在 `.delete()` 语句中使用 `delete` 和 `.where()` 子句。
大多数情况下，您不需要删除表中的所有行，需要某种 `WHERE` 条件。

可选地，您可以在插件选项中定义一个 `drizzleObjectName`，它可以接受一个 `string` 或 `string[]`。
这在您有删除方法的对象或类时很有用，而该删除方法不是来自 Drizzle。
这样的 `delete` 方法将触发 ESLint 规则。
为了避免这种情况，您可以定义您在代码库中使用的 Drizzle 对象的名称（例如 db），
这样规则仅在删除方法来自此对象时才会触发：

示例，配置 1:
```yml
rules:
  'drizzle/enforce-delete-with-where': "error"
```

```ts
class MyClass {
  public delete() {
    return {}
  }
}

const myClassObj = new MyClass();

// ---> 将被 ESLint 规则触发
myClassObj.delete()

const db = drizzle(...)
// ---> 将被 ESLint 规则触发
db.delete()
```

示例，配置 2:
```yml
rules:
  'drizzle/enforce-delete-with-where':
    - "error"
    - "drizzleObjectName": 
      - "db"
```
```ts
class MyClass {
  public delete() {
    return {}
  }
}

const myClassObj = new MyClass();

// ---> 不会被 ESLint 规则触发
myClassObj.delete()

const db = drizzle(...)
// ---> 将被 ESLint 规则触发
db.delete()
```

### **enforce-update-with-where**: 

强制在 `.update()` 语句中使用 `update` 和 `.where()` 子句。
大多数情况下，您不需要更新表中的所有行，
并需要某种 `WHERE` 语句。

可选地，您可以在插件选项中定义一个 `drizzleObjectName`，它可以接受一个 `string` 或 `string[]`。
这在您有更新方法的对象或类时很有用，而该更新方法不是来自 Drizzle。
这样的 `update` 方法将触发 ESLint 规则。
为了避免这种情况，您可以定义您在代码库中使用的 Drizzle 对象的名称（例如 db），
这样规则仅在更新方法来自此对象时才会触发：

示例，配置 1:
```yml
rules:
  'drizzle/enforce-update-with-where': "error"
```

```ts
class MyClass {
  public update() {
    return {}
  }
}

const myClassObj = new MyClass();

// ---> 将被 ESLint 规则触发
myClassObj.update()

const db = drizzle(...)
// ---> 将被 ESLint 规则触发
db.update()
```

示例，配置 2:
```yml
rules:
  'drizzle/enforce-update-with-where':
    - "error"
    - "drizzleObjectName": 
      - "db"
```
```ts
class MyClass {
  public update() {
    return {}
  }
}

const myClassObj = new MyClass();

// ---> 不会被 ESLint 规则触发
myClassObj.update()

const db = drizzle(...)
// ---> 将被 ESLint 规则触发
db.update()
```

Source: https://drizzle.zhcndoc.com/docs/extensions/mysql


import Callout from '@mdx/Callout.astro';

<Callout>
目前，Drizzle 不支持任何原生的 MySQL 扩展。一旦添加了这些扩展，我们将在这里更新！
</Callout>

Source: https://drizzle.zhcndoc.com/docs/extensions/pg


import Callout from '@mdx/Callout.astro';
import Section from '@mdx/Section.astro';

### `pg_vector`

<Callout>
在 Drizzle 模式下，没有特定的代码用于创建扩展。我们假设您正在使用向量类型、索引和查询，
并且您有一个安装了 pg_vector 扩展的 PostgreSQL 数据库。
</Callout>

[`pg_vector`](https://github.com/pgvector/pgvector) 是用于 Postgres 的开源向量相似性搜索

将向量与其他数据一起存储。支持：

- 精确和近似最近邻搜索
- 单精度、半精度、二进制和稀疏向量
- L2 距离、内积、余弦距离、L1 距离、汉明距离和杰卡德距离

#### 列类型

**`vector`**

将向量与其他数据一起存储

有关更多信息，请参阅官方 pg_vector 文档 **[docs.](https://github.com/pgvector/pgvector)**


<Section>
```ts
const table = pgTable('table', {
    embedding: vector({ dimensions: 3 })
})
```

```sql
CREATE TABLE IF NOT EXISTS "table" (
	"embedding" vector(3)
);
```
</Section>

#### 索引

现在您可以为 `pg_vector` 指定索引，并利用 `pg_vector` 函数进行查询、排序等。

让我们从 `pg_vector` 文档中获取几个 `pg_vector` 索引的示例并翻译成 Drizzle

#### L2 距离、内积和余弦距离

```ts
// CREATE INDEX ON items USING hnsw (embedding vector_l2_ops);
// CREATE INDEX ON items USING hnsw (embedding vector_ip_ops);
// CREATE INDEX ON items USING hnsw (embedding vector_cosine_ops);

const table = pgTable('items', {
    embedding: vector({ dimensions: 3 })
}, (table) => [
  index('l2_index').using('hnsw', table.embedding.op('vector_l2_ops'))
  index('ip_index').using('hnsw', table.embedding.op('vector_ip_ops'))
  index('cosine_index').using('hnsw', table.embedding.op('vector_cosine_ops'))
])
```

#### L1 距离、汉明距离和杰卡德距离 - 在 pg_vector 0.7.0 版本中添加

```ts
// CREATE INDEX ON items USING hnsw (embedding vector_l1_ops);
// CREATE INDEX ON items USING hnsw (embedding bit_hamming_ops);
// CREATE INDEX ON items USING hnsw (embedding bit_jaccard_ops);

const table = pgTable('table', {
    embedding: vector({ dimensions: 3 })
}, (table) => [
  index('l1_index').using('hnsw', table.embedding.op('vector_l1_ops')),
  index('hamming_index').using('hnsw', table.embedding.op('bit_hamming_ops')),
  index('bit_jaccard_index').using('hnsw', table.embedding.op('bit_jaccard_ops'))
])
```

#### 辅助函数

对于查询，您可以使用预定义的向量函数，或使用 SQL 模板运算符创建自定义函数。

您还可以使用以下辅助功能：

```ts
import { l2Distance, l1Distance, innerProduct, 
          cosineDistance, hammingDistance, jaccardDistance } from 'drizzle-orm'

l2Distance(table.column, [3, 1, 2]) // table.column <-> '[3, 1, 2]'
l1Distance(table.column, [3, 1, 2]) // table.column <+> '[3, 1, 2]'

innerProduct(table.column, [3, 1, 2]) // table.column <#> '[3, 1, 2]'
cosineDistance(table.column, [3, 1, 2]) // table.column <=> '[3, 1, 2]'

hammingDistance(table.column, '101') // table.column <~> '101'
jaccardDistance(table.column, '101') // table.column <%> '101'
```

如果 `pg_vector` 有其他函数可用，您可以复制现有的实现。以下是如何实现它。

```ts
export function l2Distance(
  column: SQLWrapper | AnyColumn,
  value: number[] | string[] | TypedQueryBuilder<any> | string,
): SQL {
  if (is(value, TypedQueryBuilder<any>) || typeof value === 'string') {
    return sql`${column} <-> ${value}`;
  }
  return sql`${column} <-> ${JSON.stringify(value)}`;
}
```

您可以随意命名并更改运算符。此示例允许数字数组、字符串数组、字符串，或甚至选择查询。请随意创建其他类型，或甚至贡献并提交 PR。

#### 示例

让我们从 `pg_vector` 文档中获取几个 `pg_vector` 查询的示例并翻译成 Drizzle。

```ts
import { l2Distance } from 'drizzle-orm';

// SELECT * FROM items ORDER BY embedding <-> '[3,1,2]' LIMIT 5;
db.select().from(items).orderBy(l2Distance(items.embedding, [3,1,2]))

// SELECT embedding <-> '[3,1,2]' AS distance FROM items;
db.select({ distance: l2Distance(items.embedding, [3,1,2]) })

// SELECT * FROM items ORDER BY embedding <-> (SELECT embedding FROM items WHERE id = 1) LIMIT 5;
const subquery = db.select({ embedding: items.embedding }).from(items).where(eq(items.id, 1));
db.select().from(items).orderBy(l2Distance(items.embedding, subquery)).limit(5)

// SELECT (embedding <#> '[3,1,2]') * -1 AS inner_product FROM items;
db.select({ innerProduct: sql`(${maxInnerProduct(items.embedding, [3,1,2])}) * -1` }).from(items)

// 还有更多！
```

### `postgis`

<Callout>
在 Drizzle 模式下，没有特定的代码用于创建扩展。我们假设您正在使用 postgis 类型、索引和查询，并且您有一个安装了 `postgis` 扩展的 PostgreSQL 数据库。
</Callout>

正如 [PostGIS](https://postgis.net/) 网站所提到的：

> PostGIS 通过增加对存储、索引和查询地理空间数据的支持，扩展了 PostgreSQL 关系数据库的功能。

<Callout type="info">
如果您在使用 PostGIS 扩展时使用 `introspect` 或 `push` 命令且不希望包含 PostGIS 表，您可以使用 [`extensionsFilters`](/docs/drizzle-config-file#extensionsfilters) 来忽略所有 PostGIS 表。
</Callout>

#### 列类型

**`geometry`**

将您的几何数据与其他数据一起存储。

有关更多信息，请参阅官方 PostGIS 文档 **[docs.](https://postgis.net/workshops/postgis-intro/geometries.html)**

```ts
const items = pgTable('items', {
  geo: geometry('geo', { type: 'point' }),
  geoObj: geometry('geo_obj', { type: 'point', mode: 'xy' }),
  geoSrid: geometry('geo_options', { type: 'point', mode: 'xy', srid: 4000 }),
});
```

**mode**

`geometry` 类型有 2 种模式可用于数据库映射：`tuple` 和 `xy`。

- `tuple` 将被接受用于插入，并在选择时映射到元组。因此，数据库几何将被视为 [1,2] 与 drizzle。
- `xy` 将被接受用于插入，并在选择时映射到具有 x、y 坐标的对象。因此，数据库几何将被视为 `{ x: 1, y: 2 }` 与 drizzle。

**type**

当前版本有一个预定义类型：`point`，这是 PostgreSQL PostGIS 扩展中的 `geometry(Point)` 类型。如果想使用其他类型，可以指定任何字符串。

#### 索引

使用可用的 Drizzle 索引 API，您应该能够为 PostGIS 编写任何索引。

**示例**

```ts
// CREATE INDEX custom_idx ON table USING GIST (geom);

const table = pgTable('table', {
  	geo: geometry({ type: 'point' }),
}, (table) => [
  index('custom_idx').using('gist', table.geo)
])
```

Source: https://drizzle.zhcndoc.com/docs/extensions/singlestore


import Callout from '@mdx/Callout.astro';

<Callout>
目前，Drizzle 原生不支持任何 SingleStore 扩展。一旦添加，我们会在这里展示！
</Callout>

Source: https://drizzle.zhcndoc.com/docs/extensions/sqlite


import Callout from '@mdx/Callout.astro';

<Callout>
目前，Drizzle 原生不支持任何 SQLite 扩展。一旦这些扩展被添加，我们会在这里提供它们！
</Callout>

Source: https://drizzle.zhcndoc.com/docs/faq

import Callout from '@mdx/Callout.astro';

# 常见问题与故障排除

## **我应该使用 `generate` 还是 `push`？**

这两个命令在逻辑上是不同的。`generate` 用于创建一个 SQL 文件，
并附带 `drizzle-kit` （或任何其他迁移工具）所需的额外信息。

在生成这些迁移后，它们不会被应用到数据库。 你需要在下一步中执行此操作。
你可以在 **[这里](/docs/migrations)** 了解更多信息。

另一方面，`push` 不需要生成任何迁移。
它会简单地将你的模式与数据库模式同步。
使用时请小心；我们建议仅在本地开发和本地数据库中使用。要了解更多信息，请查看 **[`drizzle-kit push`](/docs/drizzle-kit-push)**。

## `push` 和 `generate` 在 PostgreSQL 索引中的工作原理

### 限制

1. **如果在至少一个表达式上有索引，你应该手动指定索引名称**

示例

```ts
index().on(table.id, table.email) // 将正常工作，名称将被自动生成
index('my_name').on(table.id, table.email) // 将正常工作

// 但是

index().on(sql`lower(${table.email})`) // 错误
index('my_name').on(sql`lower(${table.email})`) // 将正常工作
```

2. **如果以下字段在现有索引中发生了更改，Push 将不会生成语句：**

- `.on()` 和 `.using()` 中的表达式
- `.where()` 语句
- 列上的操作符类 `.op()`

如果你使用 `push` 工作流并想更改索引中的这些字段，你需要：

1. 注释掉索引
2. Push
3. 取消注释索引并更改这些字段
4. 再次 Push

对于 `generate` 命令，任何在新 drizzle 索引 API 中对索引的任何属性的更改都会触发 `drizzle-kit`，因此在这里没有限制。

Source: https://drizzle.zhcndoc.com/docs/generated-columns

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import CodeTabs from '@mdx/CodeTabs.astro';
import CodeTab from '@mdx/CodeTab.astro';
import Callout from '@mdx/Callout.astro';

# 生成列

<Callout type="info">
要使用此功能，您需要安装 `drizzle-orm@0.32.0` 或更高版本，以及 `drizzle-kit@0.23.0` 或更高版本
</Callout>

SQL 中的生成列是一项功能，允许您在表中创建列，其值基于同一表中其他列的表达式自动计算。这有助于确保数据一致性，简化数据库设计，提高查询性能。

生成列有两种类型：

1. 虚拟（或非持久性）生成列：这些列在查询时动态计算。它们在数据库中不占用存储空间。

2. 存储（或持久性）生成列：这些列在插入或更新行时计算，并将其值存储在数据库中。这使它们可以被索引，并且可以提高查询性能，因为值不需要在每个查询中重新计算。

生成列对于以下情况特别有用：

- 从现有列派生新数据
- 自动化计算以避免手动更新
- 强制数据完整性和一致性
- 通过将复杂计算保留在数据库架构中简化应用逻辑

<Callout type="info">
    生成列的实现和使用在不同的 SQL 数据库中可能有显著差异。PostgreSQL、MySQL 和 SQLite 在生成列方面各自有独特的特性、能力和限制。在这一部分中，我们将详细探讨这些差异，以帮助您了解如何在每个数据库系统中最好地利用生成列。
</Callout>

<Tabs items={["PostgreSQL", "MySQL", "SQLite", "SingleStore(WIP)"]}>
  <Tab>
    #### 数据库端
    **类型**: `STORED` 仅

    **工作原理**
    - 在插入或更新时自动计算基于其他列的值。

    **能力**
    - 通过预计算复杂表达式简化数据访问。
    - 通过生成列的索引支持增强查询性能。

    **限制**
    - 不能指定默认值。
    - 表达式不能引用其他生成列或包含子查询。
    - 修改生成列表达式需要更改架构。
    - 不能直接用于主键、外键或唯一约束。

    欲了解更多信息，请查看 [PostgreSQL](https://www.postgresql.org/docs/current/ddl-generated-columns.html) 文档。

    #### Drizzle 端
    在 Drizzle 中，你可以在任何列类型上指定 `.generatedAlwaysAs()` 函数，并添加一个支持的 SQL 查询，这将为你生成该列的数据。

    #### 特性 
    此函数可以以三种方式接受生成表达式：

    **`string`**
    <CodeTab>
    ```ts
    export const test = pgTable("test", {
        generatedName: text("gen_name").generatedAlwaysAs(`hello world!`),
    });
    ```
    ```sql
    CREATE TABLE IF NOT EXISTS "test" (
	    "gen_name" text GENERATED ALWAYS AS (hello world!) STORED
    );
    ```
    </CodeTab>

    **`sql`** 标签 - 如果您希望 Drizzle 为您转义一些值

    <CodeTab>
    ```ts
    export const test = pgTable("test", {
        generatedName: text("gen_name").generatedAlwaysAs(sql`hello "world"!`),
    });
    ```
    ```sql
    CREATE TABLE IF NOT EXISTS "test" (
	    "gen_name" text GENERATED ALWAYS AS (hello "world"!) STORED
    );
    ```
    </CodeTab>

    **`callback`** - 如果您需要引用表中的列
    <CodeTab>
    ```ts
    export const test = pgTable("test", {
        name: text("first_name"),
        generatedName: text("gen_name").generatedAlwaysAs(
          (): SQL => sql`hi, ${test.name}!`
        ),
    });
    ```
    ```sql
    CREATE TABLE IF NOT EXISTS "test" (
	    "first_name" text,
	    "gen_name" text GENERATED ALWAYS AS (hi, "test"."first_name"!) STORED
    );
    ```
    </CodeTab>

    **示例** 生成列与全文搜索
   <CodeTabs items={["schema.ts"]}>
	<CodeTab>
	```typescript copy {17-19}
    import { SQL, sql } from "drizzle-orm";
    import { customType, index, integer, pgTable, text } from "drizzle-orm/pg-core";

    const tsVector = customType<{ data: string }>({
      dataType() {
        return "tsvector";
      },
    });

    export const test = pgTable(
      "test",
      {
        id: integer("id").primaryKey().generatedAlwaysAsIdentity(),
        content: text("content"),
        contentSearch: tsVector("content_search", {
          dimensions: 3,
        }).generatedAlwaysAs(
          (): SQL => sql`to_tsvector('english', ${test.content})`
        ),
      },
      (t) => [
        index("idx_content_search").using("gin", t.contentSearch)
      ]
    );
    ```
    ```sql {4}
    CREATE TABLE IF NOT EXISTS "test" (
    	"id" integer PRIMARY KEY GENERATED ALWAYS AS IDENTITY (sequence name "test_id_seq" INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START WITH 1 CACHE 1),
    	"content" text,
    	"content_search" "tsvector" GENERATED ALWAYS AS (to_tsvector('english', "test"."content")) STORED
    );
    --> statement-breakpoint
    CREATE INDEX IF NOT EXISTS "idx_content_search" ON "test" USING gin ("content_search");
    ```
    </CodeTab>
   </CodeTabs>
  </Tab> 
  <Tab>
    #### 数据库端
    **类型**: `STORED`, `VIRTUAL`

    **工作原理**
    - 通过表架构中的表达式定义。
    - 虚拟列在读取操作时计算。
    - 存储列在写入操作时计算并存储。

    **能力**
    - 可用于 SELECT、INSERT、UPDATE 和 DELETE 语句。
    - 可以被索引，包括虚拟和存储列。
    - 可以指定 NOT NULL 和其他约束。
    
    **限制**
    - 无法直接插入或更新生成列中的值。

    欲了解更多信息，请查看 [MySQL Alter Generated](https://dev.mysql.com/doc/refman/8.4/en/alter-table-generated-columns.html) 文档和 [MySQL create generated](https://dev.mysql.com/doc/refman/8.4/en/create-table-generated-columns.html) 文档。

    #### Drizzle 端

    #### 特性 

    **`string`**
    <CodeTab>
    ```ts
    export const test = mysqlTable("test", {
        generatedName: text("gen_name").generatedAlwaysAs(`hello world!`),
    });
    ```
    ```sql
    CREATE TABLE `test` (
	    `gen_name` text GENERATED ALWAYS AS (hello world!) VIRTUAL
    );
    ```
    </CodeTab>

    **`sql`** 标签 - 如果您希望 Drizzle 为您转义一些值

    <CodeTab>
    ```ts
    export const test = mysqlTable("test", {
        generatedName: text("gen_name").generatedAlwaysAs(sql`hello "world"!`),
    });
    ```
    ```sql
    CREATE TABLE `test` (
	    `gen_name` text GENERATED ALWAYS AS (hello "world"!) VIRTUAL
    );
    ```
    </CodeTab>

    **`callback`** - 如果您需要引用表中的列

    <CodeTab>
    ```ts
    export const test = mysqlTable("test", {
        name: text("first_name"),
        generatedName: text("gen_name").generatedAlwaysAs(
          (): SQL => sql`hi, ${test.name}!`
        ),
    });
    ```
    ```sql
    CREATE TABLE `test` (
    	`first_name` text,
    	`gen_name` text GENERATED ALWAYS AS (hi, `test`.`first_name`!) VIRTUAL
    );
    ```
    </CodeTab>
    #### 限制
    Drizzle Kit 也将在 `push` 命令中有限制：
    1. 您不能使用 `push` 更改生成约束表达式和类型。Drizzle-kit 会忽略此更改。要使其工作，您需要先 `drop` 列，`push`，然后 `add` 带有新表达式的列。这是由于数据库端复杂的映射，其中架构表达式将在数据库端被修改，而在反向工程时，我们将得到不同的字符串。我们无法确定您是更改了此表达式，还是它被数据库更改和格式化。由于这些是生成列且 `push` 通常用于本地数据库的原型，`drop` 和 `create` 生成列应该是快速的。由于这些列是 `generated`，所有数据将会被恢复。
    2. `generate` 应该没有限制。

  <CodeTabs items={["schema.ts"]}>
	<CodeTab>
	```typescript copy
    export const users = mysqlTable("users", {
        id: int("id"),
        id2: int("id2"),
        name: text("name"),
        storedGenerated: text("stored_gen").generatedAlwaysAs(
          (): SQL => sql`${users.name} || 'hello'`,
          { mode: "stored" }
        ),
        virtualGenerated: text("virtual_gen").generatedAlwaysAs(
          (): SQL => sql`${users.name} || 'hello'`,
          { mode: "virtual" }
        ),
    })
    ```
    ```sql
    CREATE TABLE `users` (
	    `id` int,
	    `id2` int,
	    `name` text,
	    `stored_gen` text GENERATED ALWAYS AS (`users`.`name` || 'hello') STORED,
	    `virtual_gen` text GENERATED ALWAYS AS (`users`.`name` || 'hello') VIRTUAL
    );
    ```
    </CodeTab>
  </CodeTabs>
  </Tab> 
  <Tab>
    #### 数据库端
    **类型**: `STORED`, `VIRTUAL`

    **工作原理**
    - 通过表架构中的表达式定义。
    - 虚拟列在读取操作时计算。
    - 存储列在写入操作时计算并存储。

    **能力**
    - 可用于 SELECT、INSERT、UPDATE 和 DELETE 语句。
    - 可以被索引，包括虚拟和存储列。
    - 可以指定 NOT NULL 和其他约束。
    
    **限制**
    - 无法直接插入或更新生成列中的值。

    欲了解更多信息，请查看 [SQLite](https://www.sqlite.org/gencol.html) 文档。

    #### Drizzle 端

    #### 特性
    **`string`**
    ```ts
    export const test = sqliteTable("test", {
        generatedName: text("gen_name").generatedAlwaysAs(`hello world!`),
    });
    ```
    ```sql
    CREATE TABLE `test` (
	    `gen_name` text GENERATED ALWAYS AS (hello world!) VIRTUAL
    );
    ```

    **`sql`** 标签 - 如果您希望 Drizzle 为您转义一些值

    ```ts
    export const test = sqliteTable("test", {
        generatedName: text("gen_name").generatedAlwaysAs(sql`hello "world"!`),
    });
    ```
    ```sql
    CREATE TABLE `test` (
	    `gen_name` text GENERATED ALWAYS AS (hello "world"!) VIRTUAL
    );
    ```

    **`callback`** - 如果您需要引用表中的列

    ```ts
    export const test = sqliteTable("test", {
        name: text("first_name"),
        generatedName: text("gen_name").generatedAlwaysAs(
          (): SQL => sql`hi, ${test.name}!`
        ),
    });
    ```
    ```sql
    CREATE TABLE `test` (
	    `first_name` text,
	    `gen_name` text GENERATED ALWAYS AS (hi, "first_name"!) VIRTUAL
    );
    ```

    #### 限制
    Drizzle Kit 也将在 `push` 和 `generate` 命令中有限制：
    1. 您不能使用存储类型更改现有表中的生成约束表达式。您需要删除此表并重新创建。这是由于 SQLite 对此类操作的限制。我们将在未来的版本中处理此情况（这将涉及创建一个新表并进行数据迁移）。
    2. 您不能将 `stored` 生成表达式添加到现有列中，由于以上原因。但是，您可以向现有列添加 `virtual` 表达式。
    3. 您不能更改现有列中的 `stored` 生成表达式，由于以上原因。但是，您可以更改 `virtual` 表达式。
    4. 您不能将生成约束类型从 `virtual` 更改为 `stored`，由于以上原因。但是，您可以从 `stored` 更改为 `virtual`。

   <CodeTabs items={["index.ts", "schema.ts"]}>
	<CodeTab>
	```typescript copy
    export const users = sqliteTable("users", {
      id: int("id"),
      name: text("name"),
      storedGenerated: text("stored_gen").generatedAlwaysAs(
        (): SQL => sql`${users.name} || 'hello'`,
        { mode: "stored" }
      ),
      virtualGenerated: text("virtual_gen").generatedAlwaysAs(
        (): SQL => sql`${users.name} || 'hello'`,
        { mode: "virtual" }
      ),
    });
    ```
    ```sql
    CREATE TABLE `users` (
	    `id` integer,
	    `name` text,
	    `stored_gen` text GENERATED ALWAYS AS ("name" || 'hello') STORED,
	    `virtual_gen` text GENERATED ALWAYS AS ("name" || 'hello') VIRTUAL
    );
    ```
    </CodeTab>
  </CodeTabs>
  </Tab> 
  <Tab>
  Work in Progress
  </Tab>
</Tabs>


Source: https://drizzle.zhcndoc.com/docs/get-started-gel

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import Steps from '@mdx/Steps.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";

# Drizzle \<\> Gel
<Prerequisites>
- 使用 Drizzle 的数据库[连接基础](/docs/connect-overview)
- gel-js 的[基础](https://github.com/geldata/gel-js)
</Prerequisites>

Drizzle 对 `gel-js` 客户端的 Gel 连接提供了原生支持。

#### 第 1 步 - 安装包
<Npm>
drizzle-orm gel
-D drizzle-kit
</Npm>

#### 第 2 步 - 初始化驱动并执行查询
<CodeTabs items={["gel", "带配置的 gel"]}>
```typescript copy
// 确保已安装 'gel' 包
import { drizzle } from 'drizzle-orm/gel';

const db = drizzle(process.env.DATABASE_URL);
 
const result = await db.execute('select 1');
```
```typescript copy
// 确保已安装 'gel' 包
import { drizzle } from "drizzle-orm/gel";

// 可以指定 gel 连接选项中的任意属性
const db = drizzle({
  connection: {
    dsn: process.env.DATABASE_URL,
    tlsSecurity: "default",
  },
});

const result = await db.execute("select 1");
```
</CodeTabs>

如果需要提供已有的驱动：

```typescript copy
// 确保已安装 'gel' 包 
import { drizzle } from "drizzle-orm/gel";
import { createClient } from "gel";

const gelClient = createClient();
const db = drizzle({ client: gelClient });

const result = await db.execute('select 1');
```

#### 下一步是什么？

<WhatsNextPostgres/>

Source: https://drizzle.zhcndoc.com/docs/get-started-mysql

import Npm from '@mdx/Npm.astro';
import Callout from '@mdx/Callout.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";

# Drizzle \<\> MySQL

要在 MySQL 数据库中使用 Drizzle，您应该使用 `mysql2` 驱动程序。

根据 **[官方网站](https://github.com/sidorares/node-mysql2)**， 
`mysql2` 是一个专注于性能的 Node.js MySQL 客户端。

Drizzle ORM 原生支持 `mysql2`，使用 `drizzle-orm/mysql2` 包。

#### 第一步 - 安装包
<Npm>
drizzle-orm mysql2
-D drizzle-kit
</Npm>

#### 第二步 - 初始化驱动并进行查询
<CodeTabs items={['mysql2', 'mysql with config']}>
```typescript copy
import { drizzle } from "drizzle-orm/mysql2";

const db = drizzle(process.env.DATABASE_URL);

const response = await db.select().from(...)
```
```typescript copy
import { drizzle } from "drizzle-orm/mysql2";

// 您可以指定 mysql2 连接选项中的任何属性
const db = drizzle({ connection:{ uri: process.env.DATABASE_URL }});

const response = await db.select().from(...)
```
</CodeTabs>

如果您需要提供现有的驱动程序：

<CodeTabs items={['Client connection', 'Pool connection']}>
  ```typescript copy
  import { drizzle } from "drizzle-orm/mysql2";
  import mysql from "mysql2/promise";

  const connection = await mysql.createConnection({
    host: "host",
    user: "user",
    database: "database",
    ...
  });

  const db = drizzle({ client: connection });
  ```
  ```typescript copy
  import { drizzle } from "drizzle-orm/mysql2";
  import mysql from "mysql2/promise";

  const poolConnection = mysql.createPool({
    host: "host",
    user: "user",
    database: "database",
    ...
  });

  const db = drizzle({ client: poolConnection });
  ```
</CodeTabs>

<Callout type="warning" emoji="⚙️">
  对于内置的 `migrate` 函数以及 DDL 迁移，我们强烈建议您使用单个 `client` 连接。

  对于查询目的，可以根据您的业务需求使用 `client` 或 `pool`。
</Callout>

#### 接下来是什么？

<WhatsNextPostgres/>

Source: https://drizzle.zhcndoc.com/docs/get-started-postgresql

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import Steps from '@mdx/Steps.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";

# Drizzle \<\> PostgreSQL
<Prerequisites>
- 使用 Drizzle 的数据库 [连接基础](https://docs/connect-overview)
- node-postgres [基础](https://node-postgres.com/)
- postgres.js [基础](https://github.com/porsager/postgres?tab=readme-ov-file#usage)
</Prerequisites>

Drizzle 原生支持使用 `node-postgres` 和 `postgres.js` 驱动程序连接 PostgreSQL。

在我们使用这两者并将它们与 Drizzle ORM 集成时，发现了它们之间的一些差异。例如：

- 使用 `node-postgres`，您可以安装 `pg-native`，将 `node-postgres` 和 Drizzle 的速度提高约 10%。
- `node-postgres` 支持按查询提供类型解析器，而无需全局修改。有关更多详细信息，请参见 [类型文档](https://node-postgres.com/features/queries#types)。
- `postgres.js` 默认使用预编译语句，您可能需要选择不使用。在 AWS 环境等中，这可能是一个潜在问题，因此请记住这一点。
- 如果您有其他想要贡献的内容，我们欢迎您在 [这里](https://github.com/drizzle-team/drizzle-orm-docs/pulls)提交 PR。

## node-postgres
#### 第一步 - 安装包
<Npm>
drizzle-orm pg
-D drizzle-kit @types/pg
</Npm>

#### 第二步 - 初始化驱动程序并进行查询
<CodeTabs items={["node-postgres", "node-postgres with config"]}>
```typescript copy
// 确保安装 'pg' 包 
import { drizzle } from 'drizzle-orm/node-postgres';

const db = drizzle(process.env.DATABASE_URL);
 
const result = await db.execute('select 1');
```
```typescript copy
// 确保安装 'pg' 包 
import { drizzle } from 'drizzle-orm/node-postgres';

// 您可以指定 node-postgres 连接选项中的任何属性
const db = drizzle({ 
  connection: { 
    connectionString: process.env.DATABASE_URL,
    ssl: true
  }
});
 
const result = await db.execute('select 1');
```
</CodeTabs>

如果您需要提供现有的驱动程序：

```typescript copy
// 确保安装 'pg' 包 
import { drizzle } from "drizzle-orm/node-postgres";
import { Pool } from "pg";

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});
const db = drizzle({ client: pool });
 
const result = await db.execute('select 1');
```

## postgres.js
#### 第一步 - 安装包
<Npm>
drizzle-orm postgres
-D drizzle-kit
</Npm>

#### 第二步 - 初始化驱动程序并进行查询
<CodeTabs items={["postgres.js", "postgres.js with config"]}>
```typescript copy
import { drizzle } from 'drizzle-orm/postgres-js';

const db = drizzle(process.env.DATABASE_URL);

const result = await db.execute('select 1');
```
```typescript copy
import { drizzle } from 'drizzle-orm/postgres-js';

// 您可以指定 postgres-js 连接选项中的任何属性
const db = drizzle({ 
  connection: { 
    url: process.env.DATABASE_URL, 
    ssl: true 
  }
});

const result = await db.execute('select 1');
```
</CodeTabs>

如果您需要提供现有的驱动程序：

```typescript copy
// 确保安装 'postgres' 包
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';

const queryClient = postgres(process.env.DATABASE_URL);
const db = drizzle({ client: queryClient });

const result = await db.execute('select 1');
```

#### 接下来是什么？

<WhatsNextPostgres/>

Source: https://drizzle.zhcndoc.com/docs/get-started-singlestore

import Npm from '@mdx/Npm.astro';
import Callout from '@mdx/Callout.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";

# Drizzle \<\> SingleStore

要在 SingleStore 数据库中使用 Drizzle，应该使用 `mysql2` 驱动。

Drizzle ORM 使用 `drizzle-orm/singlestore` 包原生支持 `mysql2`。

#### 第 1 步 - 安装包
<Npm>
drizzle-orm mysql2
-D drizzle-kit
</Npm>

#### 第 2 步 - 初始化驱动并执行查询
<CodeTabs items={['mysql2', '含配置的 mysql']}>
```typescript copy
import { drizzle } from "drizzle-orm/singlestore";

const db = drizzle(process.env.DATABASE_URL);

const response = await db.select().from(...)
```
```typescript copy
import { drizzle } from "drizzle-orm/singlestore";

// 你可以指定来自 mysql2 连接选项的任何属性
const db = drizzle({ connection:{ uri: process.env.DATABASE_URL }});

const response = await db.select().from(...)
```
</CodeTabs>

如果需要提供你现有的驱动：

<CodeTabs items={['客户端连接', '连接池连接']}>
  ```typescript copy
  import { drizzle } from "drizzle-orm/singlestore";
  import mysql from "mysql2/promise";

  const connection = await mysql.createConnection({
    host: "host",
    user: "user",
    database: "database",
    ...
  });

  const db = drizzle({ client: connection });
  ```
  ```typescript copy
  import { drizzle } from "drizzle-orm/singlestore";
  import mysql from "mysql2/promise";

  const poolConnection = mysql.createPool({
    host: "host",
    user: "user",
    database: "database",
    ...
  });

  const db = drizzle({ client: poolConnection });
  ```
</CodeTabs>

<Callout type="warning" emoji="⚙️">
  对于内置带有 DDL 迁移的 `migrate` 功能，我们和驱动强烈建议你使用单一的 `client` 连接。

  针对查询用途，可以根据业务需求自由选择使用 `client` 或 `pool`。
</Callout>

#### 限制

当前，SingleStore 方言存在一系列限制和特性，这些特性在 SingleStore 数据库端不可用：

- SingleStore 的 serial 列类型只保证列值的唯一性。
- `ORDER BY` 和 `LIMIT` 不能连锁使用。
- 不支持外键（正在检查中）。
- SingleStore 不支持 `INTERSECT ALL` 和 `EXCEPT ALL` 操作。
- SingleStore 不支持嵌套事务（详见[官方文档](https://docs.singlestore.com/cloud/reference/sql-reference/procedural-sql-reference/transactions-in-stored-procedures/)）。
- SingleStore [只支持](https://docs.singlestore.com/cloud/getting-started-with-singlestore-helios/about-singlestore-helios/singlestore-helios-faqs/durability/)一个 `isolationLevel`。
- `DATE`、`TIMESTAMP` 和 `DATETIME` 类型中的 FSP 选项不被支持。
- 关系型 API 不被支持，待 SingleStore 团队开发完所有必需的相关 API 后将实现。
- 由于 SingleStore 与 MySQL 并非 100% 兼容，可能存在更多限制。

#### 接下来是什么？

<WhatsNextPostgres/>

Source: https://drizzle.zhcndoc.com/docs/get-started-sqlite

import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Steps from '@mdx/Steps.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import LibsqlTable from '@mdx/LibsqlTable.mdx';
import LibsqlTabs from '@mdx/LibsqlTabs.mdx';

# Drizzle \<\> SQLite

Drizzle 原生支持使用 `libsql` 和 `better-sqlite3` 驱动程序连接 SQLite。

在使用这两种驱动程序并将其与 Drizzle ORM 集成时，我们发现它们之间有一些差异。例如：

在驱动程序层面，这两者之间可能没有太多差异，但主要的区别在于 `libSQL` 可以连接到 SQLite 文件和 `Turso` 远程数据库。LibSQL 是 SQLite 的一个分支，提供了比标准 SQLite 更多的功能，例如：

- `libSQL` 驱动程序支持更多的 ALTER 语句，使您能够比仅使用 `better-sqlite3` 更轻松地管理您的模式。
- 您可以原生配置静态加密功能。
- `libSQL` 还支持 SQLite 数据库支持的大量扩展。

## libsql
#### 第一步 - 安装包
<Npm>
drizzle-orm @libsql/client
-D drizzle-kit
</Npm>

#### 第二步 - 初始化驱动程序并执行查询
Drizzle 原生支持所有 @libsql/client 驱动程序变体：

<LibsqlTable />
<br/>
<LibsqlTabs />

#### Step 3 - make a query
<CodeTabs items={["libsql", "libsql with config"]}>
```typescript copy
import { drizzle } from 'drizzle-orm/libsql';

const db = drizzle(process.env.DATABASE_URL);
 
const result = await db.execute('select 1');
```
```typescript copy
import { drizzle } from 'drizzle-orm/libsql';

// 您可以指定 libsql 连接选项中的任何属性
const db = drizzle({ connection: { url:'', authToken: '' }});
 
const result = await db.execute('select 1');
```
</CodeTabs>

如果您需要同步连接，可以使用我们的额外连接 API，
在该 API 中您指定驱动程序连接并将其传递给 Drizzle 实例。

```typescript copy
import { drizzle } from 'drizzle-orm/libsql';
import { createClient } from '@libsql/client';

const client = createClient({ url: process.env.DATABASE_URL, authToken: process.env.DATABASE_AUTH_TOKEN });
const db = drizzle(client);

const result = await db.execute('select 1');
```

## better-sqlite3
#### 第一步 - 安装包
<Npm>
drizzle-orm better-sqlite3
-D drizzle-kit @types/better-sqlite3
</Npm>

#### 第二步 - 初始化驱动程序并执行查询
<CodeTabs items={["better-sqlite3", "better-sqlite3 with config"]}>
```typescript copy
import { drizzle } from 'drizzle-orm/better-sqlite3';

const db = drizzle(process.env.DATABASE_URL);

const result = await db.execute('select 1');
```
```typescript copy
import { drizzle } from 'drizzle-orm/better-sqlite3';

// 您可以指定 better-sqlite3 连接选项中的任何属性
const db =  drizzle({ connection: { source: process.env.DATABASE_URL }});

const result = await db.execute('select 1');
```
</CodeTabs>

如果您需要提供现有的驱动程序：
```typescript copy
import { drizzle } from 'drizzle-orm/better-sqlite3';
import Database from 'better-sqlite3';

const sqlite = new Database('sqlite.db');
const db = drizzle({ client: sqlite });

const result = await db.execute('select 1');
```

#### 下一步是什么？

<WhatsNextPostgres/>


Source: https://drizzle.zhcndoc.com/docs/get-started

import Callout from '@mdx/Callout.astro';
import CodeTabs from '@mdx/CodeTabs.astro';
import YoutubeCards from '@mdx/YoutubeCards.astro';
import GetStartedLinks from '@mdx/GetStartedLinks/index.astro';

# 开始使用 Drizzle
<GetStartedLinks />

Source: https://drizzle.zhcndoc.com/docs/get-started/bun-sql-existing

import Npm from '@mdx/Npm.astro';
import Npx from '@mdx/Npx.astro';
import Callout from '@mdx/Callout.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import TransferCode from '@mdx/get-started/TransferCode.mdx';
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import QueryDatabaseUpdated from '@mdx/get-started/QueryDatabaseUpdated.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';
import IntrospectPostgreSQL from '@mdx/get-started/postgresql/IntrospectPostgreSQL.mdx';
import ConnectBun from '@mdx/get-started/postgresql/ConnectBun.mdx';
import UpdateSchema from '@mdx/get-started/postgresql/UpdateSchema.mdx';

<Breadcrumbs/>

# 在现有项目中开始使用 Drizzle 和 SQLite

<Prerequisites>  
  - **dotenv** - 用于管理环境变量的包 - [阅读这里](https://www.npmjs.com/package/dotenv)
  - **bun** - JavaScript 一体化工具包 - [阅读这里](https://bun.sh/)
  - **Bun SQL** - 用于处理 PostgreSQL 数据库的原生绑定 - [阅读这里](https://bun.sh/docs/api/sql)
</Prerequisites>

<Callout type='error'>
在版本 `1.2.0` 中，Bun 在执行并发语句时存在问题，如果您尝试同时运行多个查询，可能会导致错误。
我们创建了一个 [github 问题](https://github.com/oven-sh/bun/issues/16774)，您可以跟踪。一旦修复，您在 Bun 的 SQL 方面将不再遇到此类错误。
</Callout>

<FileStructure />

#### 步骤 1 - 安装所需的包

<Npm>
  drizzle-orm dotenv
  -D drizzle-kit @types/bun
</Npm>

#### 步骤 2 - 设置连接变量

<SetupEnv env_variable='DATABASE_URL' />

#### 步骤 3 - 设置 Drizzle 配置文件

<SetupConfig dialect='postgresql' env_variable='DATABASE_URL'/>

#### 步骤 4 - 反思你的数据库

<IntrospectPostgreSQL/>

#### 步骤 5 - 将代码转移到您的实际模式文件中

<TransferCode/>

#### 步骤 6 - 将 Drizzle ORM 连接到数据库

<ConnectBun/>

#### 步骤 7 - 查询数据库

<QueryDatabase dialect='bun-sql' env_variable='DATABASE_URL' />

#### 步骤 8 - 运行 index.ts 文件

要使用 `bun` 运行脚本，请使用以下命令：
```bash copy
bun src/index.ts
```

#### 步骤 9 - 更新您的表架构（可选）

<UpdateSchema/>

#### 步骤 9 - 将更改应用于数据库（可选）

<ApplyChanges/>

#### 步骤 10 - 使用新字段查询数据库（可选）

<QueryDatabaseUpdated dialect='bun-sql' env_variable='DATABASE_URL' />

Source: https://drizzle.zhcndoc.com/docs/get-started/bun-sql-new

import Npm from '@mdx/Npm.astro';
import Npx from '@mdx/Npx.astro';
import Callout from '@mdx/Callout.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import TransferCode from '@mdx/get-started/TransferCode.mdx';
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import QueryDatabaseUpdated from '@mdx/get-started/QueryDatabaseUpdated.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';
import CreateTable from '@mdx/get-started/postgresql/CreateTable.mdx';
import ConnectBun from '@mdx/get-started/postgresql/ConnectBun.mdx';

<Breadcrumbs/>

# 开始使用 Drizzle 和 Bun:SQLite

<Prerequisites>  
  - **bun** - javaScript 一体化工具包 - [点击这里阅读](https://bun.sh/)
  - **Bun SQL** - 用于与 PostgreSQL 数据库进行交互的本机绑定 - [点击这里阅读](https://bun.sh/docs/api/sql)
</Prerequisites>

<Callout type='error'>
在版本 `1.2.0` 中，Bun 在执行并发语句时存在问题，如果您尝试同时运行多个查询，可能会导致错误。
我们已经创建了一个 [github 问题](https://github.com/oven-sh/bun/issues/16774) 供您跟踪。一旦修复，您应该不再在 Bun 的 SQL 方面遇到此类错误。
</Callout>

<FileStructure />

#### 步骤 1 - 安装所需的软件包
<Npm>
  drizzle-orm
  -D drizzle-kit @types/bun
</Npm>

#### 步骤 2 - 设置连接变量

<SetupEnv env_variable='DATABASE_URL' />

#### 步骤 3 - 将 Drizzle ORM 连接到数据库

<ConnectBun/>

#### 步骤 4 - 创建表格

<CreateTable/>

#### 步骤 5 - 设置 Drizzle 配置文件

<SetupConfig dialect='postgresql' env_variable='DATABASE_URL'/>

#### 步骤 6 - 将更改应用到数据库

<ApplyChanges />

#### 步骤 7 - 初始化并查询数据库

<QueryDatabase dialect='bun-sql' env_variable='DATABASE_URL'/>

#### 步骤 8 - 运行 index.ts 文件

要使用 `bun` 运行脚本，请使用以下命令：
```bash copy
bun src/index.ts
```

Source: https://drizzle.zhcndoc.com/docs/get-started/bun-sqlite-existing

import Npm from '@mdx/Npm.astro';
import Npx from '@mdx/Npx.astro';
import Callout from '@mdx/Callout.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import TransferCode from '@mdx/get-started/TransferCode.mdx';
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import QueryDatabaseUpdated from '@mdx/get-started/QueryDatabaseUpdated.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';
import IntrospectSqlite from '@mdx/get-started/sqlite/IntrospectSqlite.mdx';
import ConnectBun from '@mdx/get-started/sqlite/ConnectBun.mdx';
import UpdateSchema from '@mdx/get-started/sqlite/UpdateSchema.mdx';

<Breadcrumbs/>

# 在现有项目中使用 Drizzle 和 Bun:SQLite 入门

<Prerequisites>  
  - **dotenv** - 管理环境变量的包 - [在这里阅读](https://www.npmjs.com/package/dotenv)
  - **tsx** - 运行 TypeScript 文件的包 - [在这里阅读](https://tsx.is/)
  - **bun** - 一体化 JavaScript 工具包 - [在这里阅读](https://bun.sh/)
  - **bun:sqlite** - 高性能 SQLite3 驱动的原生实现 - [在这里阅读](https://bun.sh/docs/api/sqlite)
</Prerequisites>

<FileStructure />

#### 第一步 - 安装所需的包

<Npm>
  drizzle-orm dotenv
  -D drizzle-kit tsx @types/bun
</Npm>

#### 第二步 - 设置连接变量

<SetupEnv env_variable='DB_FILE_NAME' />

<Callout type='info' title='重要'>
例如，如果您的项目根目录中有一个 SQLite 数据库文件，可以使用以下示例：
```plaintext copy
DB_FILE_NAME=mydb.sqlite
```
</Callout>


#### 第三步 - 设置 Drizzle 配置文件

<SetupConfig dialect='sqlite' env_variable='DB_FILE_NAME'/>

#### 第四步 - 对您的数据库进行自省

<IntrospectSqlite/>

#### 第五步 - 将代码转移到您的实际架构文件中

<TransferCode/>

#### 第六步 - 将 Drizzle ORM 连接到数据库

<ConnectBun/>

#### 第七步 - 查询数据库

<QueryDatabase dialect='bun-sqlite' env_variable='DB_FILE_NAME' />

#### 第八步 - 运行 index.ts 文件

要使用 `bun` 运行脚本，请使用以下命令：
```bash copy
bun src/index.ts
```

#### 第九步 - 更新您的表架构（可选）

<UpdateSchema/>

#### 第九步 - 将更改应用到数据库（可选）

<ApplyChanges/>

#### 第十步 - 使用新字段查询数据库（可选）

<QueryDatabaseUpdated dialect='bun-sqlite' env_variable='DB_FILE_NAME' />

Source: https://drizzle.zhcndoc.com/docs/get-started/bun-sqlite-new

import Npm from '@mdx/Npm.astro';
import Npx from '@mdx/Npx.astro';
import Callout from '@mdx/Callout.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import TransferCode from '@mdx/get-started/TransferCode.mdx';
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import QueryDatabaseUpdated from '@mdx/get-started/QueryDatabaseUpdated.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';
import CreateTable from '@mdx/get-started/sqlite/CreateTable.mdx';
import ConnectBun from '@mdx/get-started/sqlite/ConnectBun.mdx';

<Breadcrumbs/>

# 使用 Drizzle 和 Bun:SQLite 入门

<Prerequisites>  
  - **bun** - JavaScript 一体化工具包 - [点击阅读](https://bun.sh/)
  - **bun:sqlite** - 高性能 SQLite3 驱动的原生实现 - [点击阅读](https://bun.sh/docs/api/sqlite)
</Prerequisites>

<FileStructure />

#### 步骤 1 - 安装所需的包
<Npm>
  drizzle-orm
  -D drizzle-kit @types/bun
</Npm>

#### 步骤 2 - 设置连接变量

<SetupEnv env_variable='DB_FILE_NAME' />

<Callout type='info' title='重要'>
例如，如果您想在项目根目录中创建一个 SQLite 数据库文件以进行测试，可以使用以下示例：
```plaintext copy
DB_FILE_NAME=mydb.sqlite
```
</Callout>

#### 步骤 3 - 将 Drizzle ORM 连接到数据库

<ConnectBun/>

#### 步骤 4 - 创建一个表

<CreateTable/>

#### 步骤 5 - 设置 Drizzle 配置文件

<SetupConfig dialect='sqlite' env_variable='DB_FILE_NAME' />

#### 步骤 6 - 将更改应用到数据库

<ApplyChanges />

#### 步骤 7 - 生成并查询数据库

<QueryDatabase dialect='bun-sqlite' env_variable='DB_FILE_NAME' />

#### 步骤 8 - 运行 index.ts 文件

要使用 `bun` 运行脚本，请使用以下命令：
```bash copy
bun src/index.ts
```

Source: https://drizzle.zhcndoc.com/docs/get-started/d1-existing



Source: https://drizzle.zhcndoc.com/docs/get-started/d1-new

import Npm from '@mdx/Npm.astro';
import Npx from '@mdx/Npx.astro';
import Callout from '@mdx/Callout.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import TransferCode from '@mdx/get-started/TransferCode.mdx';
import QueryTurso from '@mdx/get-started/sqlite/QueryTurso.mdx';
import QueryDatabaseUpdated from '@mdx/get-started/QueryDatabaseUpdated.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';
import CreateTable from '@mdx/get-started/sqlite/CreateTable.mdx';
import ConnectLibsql from '@mdx/get-started/sqlite/ConnectLibsql.mdx';

<Breadcrumbs/>

# 开始使用 Drizzle 和 D1

<Prerequisites>  
  - **dotenv** - 管理环境变量的包 - [查看这里](https://www.npmjs.com/package/dotenv)
  - **tsx** - 运行 TypeScript 文件的包 - [查看这里](https://tsx.is/)
  - **Cloudflare D1** - 用于从您的 Workers 和 Pages 项目中查询的无服务器 SQL 数据库 - [查看这里](https://developers.cloudflare.com/d1/)
  - **wrangler** - Cloudflare 开发者平台命令行界面 - [查看这里](https://developers.cloudflare.com/workers/wrangler)
</Prerequisites>

<FileStructure />

#### 第一步 - 安装所需的包
<InstallPackages lib=''/>

#### 第二步 - 设置 wrangler.toml

您需要一个 `wrangler.toml` 文件用于 D1 数据库，其内容大致如下：
```toml
name = "您的项目名称"
main = "src/index.ts"
compatibility_date = "2022-11-07"
node_compat = true

[[ d1_databases ]]
binding = "DB"
database_name = "您的数据库名称"
database_id = "您的数据库 ID"
migrations_dir = "drizzle"
```

#### 第三步 - 将 Drizzle ORM 连接到数据库

```typescript copy
import { drizzle } from 'drizzle-orm/d1';

export interface Env {
  <BINDING_NAME>: D1Database;
}
export default {
  async fetch(request: Request, env: Env) {
    const db = drizzle(env.<BINDING_NAME>);
  },
};
```

#### 第四步 - 创建一个表

<CreateTable/>

#### 第五步 - 设置 Drizzle 配置文件

**Drizzle 配置** - 一个供 [Drizzle Kit](/docs/kit-overview) 使用的配置文件，包含有关您的数据库连接、迁移文件夹和模式文件的所有信息。

在项目根目录创建一个 `drizzle.config.ts` 文件，并添加以下内容：

```typescript copy filename="drizzle.config.ts"
import 'dotenv/config';
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
  out: './drizzle',
  schema: './src/db/schema.ts',
  dialect: 'sqlite',
  driver: 'd1-http',
  dbCredentials: {
    accountId: process.env.CLOUDFLARE_ACCOUNT_ID!,
    databaseId: process.env.CLOUDFLARE_DATABASE_ID!,
    token: process.env.CLOUDFLARE_D1_TOKEN!,
  },
});
```
<Callout title='提示'>
您可以查看 [我们的教程](/docs/guides/d1-http-with-drizzle-kit)，了解如何从 CloudFlare 获取环境变量
</Callout>

#### 第六步 - 将更改应用于数据库

<ApplyChanges />

#### 第七步 - 初始化并查询数据库

```typescript copy
import { drizzle } from 'drizzle-orm/d1';

export interface Env {
  <BINDING_NAME>: D1Database;
}
export default {
  async fetch(request: Request, env: Env) {
    const db = drizzle(env.<BINDING_NAME>);
    const result = await db.select().from(users).all()
    return Response.json(result);
  },
};
```

#### 第八步 - 运行 index.ts 文件

<RunFile/>

Source: https://drizzle.zhcndoc.com/docs/get-started/do-existing



Source: https://drizzle.zhcndoc.com/docs/get-started/do-new

import Npm from '@mdx/Npm.astro';
import Npx from '@mdx/Npx.astro';
import Callout from '@mdx/Callout.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import TransferCode from '@mdx/get-started/TransferCode.mdx';
import QueryTurso from '@mdx/get-started/sqlite/QueryTurso.mdx';
import QueryDatabaseUpdated from '@mdx/get-started/QueryDatabaseUpdated.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';
import CreateTable from '@mdx/get-started/sqlite/CreateTable.mdx';
import ConnectLibsql from '@mdx/get-started/sqlite/ConnectLibsql.mdx';

<Breadcrumbs/>

# 使用 Drizzle 和 SQLite Durable Objects 快速入门

<Prerequisites>  
  - **dotenv** - 管理环境变量的包 - [阅读这里](https://www.npmjs.com/package/dotenv)
  - **tsx** - 运行 TypeScript 文件的包 - [阅读这里](https://tsx.is/)
  - **Cloudflare SQLite Durable Objects** - 嵌入于 Durable Object 中的 SQLite 数据库 - [阅读这里](https://developers.cloudflare.com/durable-objects/api/sql-storage/)
  - **wrangler** - Cloudflare 开发者平台命令行接口 - [阅读这里](https://developers.cloudflare.com/workers/wrangler)
</Prerequisites>

<FileStructure />

#### 第 1 步 - 安装必需的包
<Npm>
  drizzle-orm dotenv
  -D drizzle-kit wrangler @cloudflare/workers-types
</Npm>

#### 第 2 步 - 设置 wrangler.toml

你需要有一个用于 D1 数据库的 `wrangler.toml` 文件，内容大致如下：
```toml
#:schema node_modules/wrangler/config-schema.json
name = "sqlite-durable-objects"
main = "src/index.ts"
compatibility_date = "2024-11-12"
compatibility_flags = [ "nodejs_compat" ]

# 绑定一个 Durable Object。Durable Object 是基于 actor 模型的按需伸缩计算原语。
# Durable Object 可以持续存在。适用于需要长时间运行“服务器”的场景，如实时应用。
# 文档：https://developers.cloudflare.com/workers/wrangler/configuration/#durable-objects
[[durable_objects.bindings]]
name = "MY_DURABLE_OBJECT"
class_name = "MyDurableObject"

# Durable Object 迁移。
# 文档：https://developers.cloudflare.com/workers/wrangler/configuration/#migrations
[[migrations]]
tag = "v1"
new_sqlite_classes = ["MyDurableObject"]

# 需要规则以便在后续步骤中导入迁移
[[rules]] 
type = "Text"
globs = ["**/*.sql"]
fallthrough = true
```

#### 第 3 步 - 连接 Drizzle ORM 到数据库

```ts
/// <reference types="@cloudflare/workers-types" />
import { drizzle, type DrizzleSqliteDODatabase } from 'drizzle-orm/durable-sqlite';
import { DurableObject } from 'cloudflare:workers'

export class MyDurableObject extends DurableObject {
	storage: DurableObjectStorage;
	db: DrizzleSqliteDODatabase;

	constructor(ctx: DurableObjectState, env: Env) {
		super(ctx, env);
		this.storage = ctx.storage;
		this.db = drizzle(this.storage, { logger: false });
	}
}
```

#### 第 4 步 - 生成 wrangler 类型

<Npx>
wrangler types
</Npx>

<Callout>
该命令会输出一个 `worker-configuration.d.ts` 文件。
</Callout>

#### 第 5 步 - 创建一个表

<CreateTable/>

#### 第 6 步 - 设置 Drizzle 配置文件

**Drizzle 配置** 是一个由 [Drizzle Kit](/docs/kit-overview) 使用的配置文件，包含有关数据库连接、迁移文件夹和模式文件的所有信息。

在项目根目录下创建 `drizzle.config.ts` 文件，并添加以下内容：

```typescript copy filename="drizzle.config.ts"
import 'dotenv/config';
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
  out: './drizzle',
  schema: './src/db/schema.ts',
  dialect: 'sqlite',
  driver: 'durable-sqlite',
});
```

#### 第 7 步 - 应用数据库变更

生成迁移：
```bash copy
npx drizzle-kit generate
```

迁移只能从 Cloudflare Workers 应用。
为此，我们在 MyDurableObject 中定义迁移功能：
```ts copy {4-5,17-19}
/// <reference types="@cloudflare/workers-types" />
import { drizzle, type DrizzleSqliteDODatabase } from 'drizzle-orm/durable-sqlite';
import { DurableObject } from 'cloudflare:workers'
import { migrate } from 'drizzle-orm/durable-sqlite/migrator';
import migrations from '../drizzle/migrations';

export class MyDurableObject extends DurableObject {
	storage: DurableObjectStorage;
	db: DrizzleSqliteDODatabase;

	constructor(ctx: DurableObjectState, env: Env) {
		super(ctx, env);
		this.storage = ctx.storage;
		this.db = drizzle(this.storage, { logger: false });
	}

	async migrate() {
		migrate(this.db, migrations);
	}
}
```

#### 第 8 步 - 迁移并查询数据库

```typescript copy
/// <reference types="@cloudflare/workers-types" />
import { drizzle, DrizzleSqliteDODatabase } from 'drizzle-orm/durable-sqlite';
import { DurableObject } from 'cloudflare:workers'
import { migrate } from 'drizzle-orm/durable-sqlite/migrator';
import migrations from '../drizzle/migrations';
import { usersTable } from './db/schema';

export class MyDurableObject extends DurableObject {
	storage: DurableObjectStorage;
	db: DrizzleSqliteDODatabase<any>;

	constructor(ctx: DurableObjectState, env: Env) {
		super(ctx, env);
		this.storage = ctx.storage;
		this.db = drizzle(this.storage, { logger: false });

		// 确保所有迁移在接受查询前完成。
		// 否则你需要在任何访问 Drizzle 数据库 this.db 的函数中调用 `this.migrate()`。
		ctx.blockConcurrencyWhile(async () => {
			await this._migrate();
		});
	}

	async insertAndList(user: typeof usersTable.$inferInsert) {
		await this.insert(user);
		return this.select();
	}

	async insert(user: typeof usersTable.$inferInsert) {
		await this.db.insert(usersTable).values(user);
	}

	async select() {
		return this.db.select().from(usersTable);
	}

	async _migrate() {
		migrate(this.db, migrations);
	}
}

export default {
	/**
	 * 这是 Cloudflare Worker 的标准 fetch 处理器
	 *
	 * @param request - Client 发送到 Worker 的请求
	 * @param env - 用于引用 wrangler.toml 中声明绑定的接口
	 * @param ctx - Worker 的执行上下文
	 * @returns 返回给客户端的响应
	 */
	async fetch(request: Request, env: Env): Promise<Response> {
		const id: DurableObjectId = env.MY_DURABLE_OBJECT.idFromName('durable-object');
		const stub = env.MY_DURABLE_OBJECT.get(id);

		// 选项 A - 最大性能。
		// 优先将所有数据库交互封装在一次 Durable Object 调用中
		// 以获得最大性能，因为 DO 内的数据库访问非常快。
		const usersAll = await stub.insertAndList({
			name: 'John',
			age: 30,
			email: 'john@example.com',
		});
		console.log('新用户已创建。正在从数据库获取所有用户：', users);

		// 选项 B - 慢速，但在某些调试场景下可能有用。
		// 你也可以直接调用单个 Drizzle 查询（如果暴露了的话），
		// 但请记住每次查询都是对 Durable Object 实例的一次往返。
		await stub.insert({
			name: 'John',
			age: 30,
			email: 'john@example.com',
		});
		console.log('新用户已创建！');
	
		const users = await stub.select();
		console.log('正在从数据库获取所有用户：', users);

		return Response.json(users);
	}
}
```

Source: https://drizzle.zhcndoc.com/docs/get-started/expo-existing

import Breadcrumbs from '@mdx/Breadcrumbs.astro';

<Breadcrumbs/>

# 在现有项目中使用 Drizzle 和 Expo 入门

我们没有关于在现有项目中使用 Expo 的完整指南，但我们相信
来自这个 [入门指南](/docs/get-started/expo-new) 的所有信息应该足够了

Source: https://drizzle.zhcndoc.com/docs/get-started/expo-new

import Npm from '@mdx/Npm.astro';
import Npx from '@mdx/Npx.astro';
import Callout from '@mdx/Callout.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import TransferCode from '@mdx/get-started/TransferCode.mdx';
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import QueryDatabaseUpdated from '@mdx/get-started/QueryDatabaseUpdated.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';
import CreateTable from '@mdx/get-started/sqlite/CreateTable.mdx';
import ConnectLibsql from '@mdx/get-started/sqlite/ConnectLibsql.mdx';

<Breadcrumbs/>

# 开始使用 Drizzle 和 Expo

<Prerequisites>  
  - **Expo SQLite** - 一个可通过 SQLite API 查询的数据库访问库 - [在此阅读](https://docs.expo.dev/versions/latest/sdk/sqlite/)
</Prerequisites>


#### 步骤 1 - 从 Expo 模板设置项目
<Npx>
create expo-app --template blank-typescript
</Npx>

您可以在 [此处](https://docs.expo.dev/more/create-expo/#create-a-new-project) 了解更多关于此模板的信息。

#### 基本文件结构

安装模板并添加 `db` 文件夹后，您将找到以下内容：在 `db/schema.ts` 文件中定义的 drizzle 表。`drizzle` 文件夹包含 SQL 迁移文件和快照

```plaintext
📦 <项目根目录>
 ├ 📂 assets
 ├ 📂 drizzle
 ├ 📂 db
 │  └ 📜 schema.ts
 ├ 📜 .gitignore
 ├ 📜 .npmrc
 ├ 📜 app.json
 ├ 📜 App.tsx
 ├ 📜 babel.config.ts
 ├ 📜 drizzle.config.ts
 ├ 📜 package.json
 └ 📜 tsconfig.json
```

#### 步骤 2 - 安装 expo-sqlite 包
<Npx>
expo install expo-sqlite
</Npx>

#### 步骤 3 - 安装所需的包
<Npm>
  drizzle-orm
  -D drizzle-kit
</Npm>

#### 步骤 4 - 将 Drizzle ORM 连接到数据库

在根目录下创建一个 `App.tsx` 文件并初始化连接：

```ts
import * as SQLite from 'expo-sqlite';
import { drizzle } from 'drizzle-orm/expo-sqlite';

const expo = SQLite.openDatabaseSync('db.db');

const db = drizzle(expo);
```

#### 步骤 5 - 创建表

在 `db` 目录下创建一个 `schema.ts` 文件并声明您的表：

```typescript copy filename="src/db/schema.ts"
import { int, sqliteTable, text } from "drizzle-orm/sqlite-core";

export const usersTable = sqliteTable("users_table", {
  id: int().primaryKey({ autoIncrement: true }),
  name: text().notNull(),
  age: int().notNull(),
  email: text().notNull().unique(),
});
```

#### 步骤 6 - 设置 Drizzle 配置文件

**Drizzle 配置** - 一个用于 [Drizzle Kit](/docs/kit-overview) 的配置文件，包含有关您的数据库连接、迁移文件夹和架构文件的所有信息。

在项目根目录下创建一个 `drizzle.config.ts` 文件并添加以下内容：

```ts
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
  dialect: 'sqlite',
  driver: 'expo',
  schema: './db/schema.ts',
  out: './drizzle',
});
```

#### 步骤 7 - 设置 `metro` 配置

在根目录下创建一个文件 `metro.config.js` 并在其中添加以下代码：

```js copy filename="metro.config.js"
const { getDefaultConfig } = require('expo/metro-config');
/** @type {import('expo/metro-config').MetroConfig} */
const config = getDefaultConfig(__dirname);
config.resolver.sourceExts.push('sql');
module.exports = config;
```

#### 步骤 8 - 更新 `babel` 配置
```js copy filename="babel.config.js"
module.exports = function(api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
    plugins: [["inline-import", { "extensions": [".sql"] }]] // <-- 添加此行
  };
};
```

#### 步骤 9 - 对数据库应用更改

使用 Expo，您需要通过 `drizzle-kit generate` 命令生成迁移，并通过 `drizzle-orm` 的 `migrate()` 函数在运行时应用它们。

生成迁移：
```bash copy
npx drizzle-kit generate
```

#### 步骤 10 - 应用迁移并查询数据库：

让我们在 **App.tsx** 文件中执行迁移和查询，以创建、读取、更新和删除用户。

```ts copy
import { Text, View } from 'react-native';
import * as SQLite from 'expo-sqlite';
import { useEffect, useState } from 'react';
import { drizzle } from 'drizzle-orm/expo-sqlite';
import { usersTable } from './db/schema';
import { useMigrations } from 'drizzle-orm/expo-sqlite/migrator';
import migrations from './drizzle/migrations';

const expo = SQLite.openDatabaseSync('db.db');

const db = drizzle(expo);

export default function App() {
  const { success, error } = useMigrations(db, migrations);
  const [items, setItems] = useState<typeof usersTable.$inferSelect[] | null>(null);

  useEffect(() => {
    if (!success) return;

    (async () => {
      await db.delete(usersTable);

      await db.insert(usersTable).values([
        {
            name: 'John',
            age: 30,
            email: 'john@example.com',
        },
      ]);

      const users = await db.select().from(usersTable);
      setItems(users);
    })();
  }, [success]);

  if (error) {
    return (
      <View>
        <Text>迁移错误: {error.message}</Text>
      </View>
    );
  }

  if (!success) {
    return (
      <View>
        <Text>迁移进行中...</Text>
      </View>
    );
  }

  if (items === null || items.length === 0) {
    return (
      <View>
        <Text>空</Text>
      </View>
    );
  }

  return (
    <View
      style={{
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        width: '100%',
        height: '100%',
        justifyContent: 'center',
      }}
    >
      {items.map((item) => (
        <Text key={item.id}>{item.email}</Text>
      ))}
    </View>
  );
}
```

#### 步骤 11 - 预构建并运行 expo 应用

<CodeTabs items={['npm', 'yarn', 'pnpm', 'bun']}>
```bash copy
npx expo run:ios
```
```bash copy
yarn expo run:ios
```
```bash copy
pnpm expo run:ios
```
```bash copy
bun expo run:ios
```
</CodeTabs>


Source: https://drizzle.zhcndoc.com/docs/get-started/gel-existing

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from "@mdx/Npm.astro";
import Npx from "@mdx/Npx.astro";
import Callout from '@mdx/Callout.astro';
import Steps from '@mdx/Steps.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import ConnectPostgreSQL from '@mdx/get-started/postgresql/ConnectPostgreSQL.mdx'
import CreateTable from '@mdx/get-started/postgresql/CreateTable.mdx'
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';

<Breadcrumbs/>

# 在已有项目中使用 Drizzle 和 Gel 入门

<Prerequisites>
  - **tsx** - 用于运行 TypeScript 文件的包 - [查看这里](https://tsx.is/)
  - **gel-js** - 用于查询你的 Gel 数据库的包 - [查看这里](https://github.com/geldata/gel-js)
</Prerequisites>

Drizzle 原生支持使用 `gel` 客户端连接 Gel。

这是项目的基本文件结构。在 `src` 目录下，我们有 `index.ts` 中的表定义。在 `drizzle` 文件夹中是生成的 Gel 到 Drizzle 的 schema。

```plaintext
📦 <项目根目录>
 ├ 📂 drizzle
 ├ 📂 dbschema
 │ ├ 📂 migrations
 │ ├ 📜 default.esdl
 │ └ 📜 scoping.esdl
 ├ 📂 src
 │ └ 📜 index.ts
 ├ 📜 drizzle.config.ts
 ├ 📜 edgedb.toml
 ├ 📜 package.json
 └ 📜 tsconfig.json
```

#### 第 1 步 - 安装所需的包
<Npm>
  drizzle-orm gel
  -D drizzle-kit tsx
</Npm>

#### 第 2 步 - 设置 Drizzle 配置文件

**Drizzle 配置** - 这是一个由 [Drizzle Kit](/docs/kit-overview) 使用的配置文件，包含了关于你的数据库连接、迁移文件夹和 schema 文件的所有信息。

在项目根目录下创建一个 `drizzle.config.ts` 文件，并添加以下内容：

```typescript copy filename="drizzle.config.ts"
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
  dialect: 'gel',
});
```

#### 第 3 步 - 将 Gel 类型拉取到 Drizzle schema

拉取你的数据库 schema：
<Npx>
drizzle-kit pull
</Npx>

以下是生成的 schema.ts 文件示例：

```typescript filename="drizzle/schema.ts"
import { gelTable, uniqueIndex, uuid, smallint, text } from "drizzle-orm/gel-core"
import { sql } from "drizzle-orm"

export const users = gelTable("users", {
	id: uuid().default(sql`uuid_generate_v4()`).primaryKey().notNull(),
	age: smallint(),
	email: text().notNull(),
	name: text(),
}, (table) => [
	uniqueIndex("a8c6061c-f37f-11ef-9249-0d78f6c1807b;schemaconstr").using("btree", table.id.asc().nullsLast().op("uuid_ops")),
]);
```

#### 第 4 步 - 连接 Drizzle ORM 到数据库

在 `src` 目录中创建一个 `index.ts` 文件并初始化连接：

```typescript copy filename="src/index.ts"
import { drizzle } from "drizzle-orm/gel";
import { createClient } from "gel";

const gelClient = createClient();
const db = drizzle({ client: gelClient });
```

#### 第 5 步 - 查询数据库

```typescript copy filename="src/index.ts"
import { eq } from "drizzle-orm";
import { drizzle } from "drizzle-orm/gel";
import { createClient } from "gel";
import { users } from "../drizzle/schema";

const gelClient = createClient();
const db = drizzle({ client: gelClient });

async function main() {
  const user: typeof users.$inferInsert = {
    name: "John",
    age: 30,
    email: "john@example.com",
  };

  await db.insert(users).values(user);
  console.log("新用户已创建！");

  const usersResponse = await db.select().from(users);
  console.log("获取数据库中所有用户: ", usersResponse);
  /*
  const users: {
    id: number;
    name: string;
    age: number;
    email: string;
  }[]
  */

  await db
    .update(users)
    .set({
      age: 31,
    })
    .where(eq(users.email, user.email));
  console.log("用户信息已更新！");

  await db.delete(users).where(eq(users.email, user.email));
  console.log("用户已删除！");
}

main();
```

#### 第 6 步 - 运行 index.ts 文件

<RunFile/>

Source: https://drizzle.zhcndoc.com/docs/get-started/gel-new

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from "@mdx/Npm.astro";
import Npx from "@mdx/Npx.astro";
import Callout from '@mdx/Callout.astro';
import Steps from '@mdx/Steps.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import ConnectPostgreSQL from '@mdx/get-started/postgresql/ConnectPostgreSQL.mdx'
import CreateTable from '@mdx/get-started/postgresql/CreateTable.mdx'
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';

<Breadcrumbs/>

# 使用 Drizzle 和 Gel 快速入门

<Prerequisites>
  - **tsx** - 运行 TypeScript 文件的包 - [点击阅读](https://tsx.is/)
  - **gel-js** - 用于查询 Gel 数据库的包 - [点击阅读](https://github.com/geldata/gel-js)
</Prerequisites>

Drizzle 原生支持使用 `gel` 客户端连接 Gel。

这是项目的基础文件结构。在 `src` 目录中，我们有 `index.ts` 文件，用于表的定义。在 `drizzle` 文件夹中则存放了从 Gel 生成的 Drizzle schema。

```plaintext
📦 <项目根目录>
 ├ 📂 drizzle
 ├ 📂 src
 │ └ 📜 index.ts
 ├ 📜 drizzle.config.ts
 ├ 📜 package.json
 └ 📜 tsconfig.json
```

#### 第1步 - 安装并初始化 **Gel** 项目

<Npx>
gel project init
</Npx>

#### 第2步 - 定义基础 Gel schema

在 `dbschema/default.esdl` 文件中添加基础的 Gel schema

```esdl
module default {
    type user {
        name: str;
        required email: str;
        age: int16;
    }
}
```

#### 第3步 - 推送 Gel schema 到数据库

生成 Gel 迁移文件：
```bash
gel migration create
```

应用 Gel 迁移到数据库：
```bash
gel migration apply
```

<Callout>
现在你的文件结构应该是这样

```plaintext
📦 <项目根目录>
 ├ 📂 dbschema
 │ ├ 📂 migrations
 │ ├ 📜 default.esdl
 │ └ 📜 scoping.esdl
 ├ 📂 src
 │ └ 📜 index.ts
 ├ 📜 drizzle.config.ts
 ├ 📜 edgedb.toml
 ├ 📜 package.json
 └ 📜 tsconfig.json
```
</Callout>

#### 第4步 - 安装所需包
<Npm>
  drizzle-orm gel
  -D drizzle-kit tsx
</Npm>

#### 第5步 - 配置 Drizzle 配置文件

**Drizzle 配置文件** 是 [Drizzle Kit](/docs/kit-overview) 使用的配置文件，包含了数据库连接、迁移文件夹及 schema 文件的所有信息。

在项目根目录创建 `drizzle.config.ts` 文件，并添加如下内容：

```typescript copy filename="drizzle.config.ts"
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
  dialect: 'gel',
});
```

#### 第6步 - 从 Gel 同步类型到 Drizzle schema

同步你的数据库 schema：
<Npx>
drizzle-kit pull
</Npx>

这是示例生成的 schema.ts 文件：

```typescript filename="drizzle/schema.ts"
import { gelTable, uniqueIndex, uuid, smallint, text } from "drizzle-orm/gel-core"
import { sql } from "drizzle-orm"

export const users = gelTable("users", {
	id: uuid().default(sql`uuid_generate_v4()`).primaryKey().notNull(),
	age: smallint(),
	email: text().notNull(),
	name: text(),
}, (table) => [
	uniqueIndex("a8c6061c-f37f-11ef-9249-0d78f6c1807b;schemaconstr").using("btree", table.id.asc().nullsLast().op("uuid_ops")),
]);
```

#### 第7步 - 连接 Drizzle ORM 到数据库

在 `src` 目录下创建 `index.ts` 文件并初始化连接：

```typescript copy filename="src/index.ts"
import { drizzle } from "drizzle-orm/gel";
import { createClient } from "gel";

const gelClient = createClient();
const db = drizzle({ client: gelClient });
```

#### 第8步 - 查询数据库

```typescript copy filename="src/index.ts"
import { eq } from "drizzle-orm";
import { drizzle } from "drizzle-orm/gel";
import { createClient } from "gel";
import { users } from "../drizzle/schema";

const gelClient = createClient();
const db = drizzle({ client: gelClient });

async function main() {
  const user: typeof users.$inferInsert = {
    name: "John",
    age: 30,
    email: "john@example.com",
  };

  await db.insert(users).values(user);
  console.log("新用户已创建！");

  const usersResponse = await db.select().from(users);
  console.log("从数据库获取所有用户：", usersResponse);
  /*
  const users: {
    id: number;
    name: string;
    age: number;
    email: string;
  }[]
  */

  await db
    .update(users)
    .set({
      age: 31,
    })
    .where(eq(users.email, user.email));
  console.log("用户信息已更新！");

  await db.delete(users).where(eq(users.email, user.email));
  console.log("用户已删除！");
}

main();
```

#### 第9步 - 运行 index.ts 文件

<RunFile/>

Source: https://drizzle.zhcndoc.com/docs/get-started/mysql-existing

import Npm from '@mdx/Npm.astro';
import Callout from '@mdx/Callout.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';
import ConnectMySQL from '@mdx/get-started/mysql/ConnectMySQL.mdx';
import CreateTable from '@mdx/get-started/mysql/CreateTable.mdx';
import UpdateSchema from '@mdx/get-started/mysql/UpdateSchema.mdx';
import IntrospectMySQL from '@mdx/get-started/mysql/IntrospectMySQL.mdx';
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import QueryDatabaseUpdated from '@mdx/get-started/QueryDatabaseUpdated.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import TransferCode from '@mdx/get-started/TransferCode.mdx';

<Breadcrumbs/>

# 在现有项目中使用 Drizzle 和 MySQL 快速入门

<Prerequisites>  
  - **dotenv** - 管理环境变量的包 - [点击阅读](https://www.npmjs.com/package/dotenv)
  - **tsx** - 运行 TypeScript 文件的包 - [点击阅读](https://tsx.is/)
  - **mysql2** - 查询您的 MySQL 数据库的包 - [点击阅读](https://github.com/sidorares/node-mysql2)
</Prerequisites>

<FileStructure/>

#### 第 1 步 - 安装 `mysql2` 包

<InstallPackages lib='mysql2'/>

#### 第 2 步 - 设置连接变量

<SetupEnv env_variable='DATABASE_URL' />

#### 第 3 步 - 设置 Drizzle 配置文件

<SetupConfig dialect='mysql' env_variable='DATABASE_URL'/>

#### 第 4 步 - 内省您的数据库

<IntrospectMySQL/>

#### 第 5 步 - 将代码转移到您的实际模式文件

<TransferCode/>

#### 第 6 步 - 将 Drizzle ORM 连接到数据库

<ConnectMySQL/>

#### 第 7 步 - 查询数据库

<QueryDatabase dialect='mysql2' env_variable='DATABASE_URL'/>

#### 第 8 步 - 运行 index.ts 文件

<RunFile/>

#### 第 9 步 - 更新您的表模式（可选）

<UpdateSchema/>

#### 第 10 步 - 将更改应用于数据库（可选）

<ApplyChanges/>

#### 第 11 步 - 使用新字段查询数据库（可选）

<QueryDatabaseUpdated dialect='mysql2' env_variable='DATABASE_URL' />

Source: https://drizzle.zhcndoc.com/docs/get-started/mysql-new

import Npm from '@mdx/Npm.astro';
import Callout from '@mdx/Callout.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';
import ConnectMySQL from '@mdx/get-started/mysql/ConnectMySQL.mdx';
import CreateTable from '@mdx/get-started/mysql/CreateTable.mdx';
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';

<Breadcrumbs/>

# 开始使用 Drizzle 和 MySQL

<Prerequisites>  
  - **dotenv** - 管理环境变量的包 - [查看这里](https://www.npmjs.com/package/dotenv)
  - **tsx** - 运行 TypeScript 文件的包 - [查看这里](https://tsx.is/)
  - **mysql2** - 查询您的 MySQL 数据库的包 - [查看这里](https://github.com/sidorares/node-mysql2)
</Prerequisites>

要使用 Drizzle 与 MySQL 数据库，您应使用 `mysql2` 驱动

根据 **[官方网站](https://github.com/sidorares/node-mysql2)**， 
`mysql2` 是一个专注于性能的 Node.js MySQL 客户端。  

Drizzle ORM 原生支持 `mysql2`，使用 `drizzle-orm/mysql2` 包。

<FileStructure/>

#### 步骤 1 - 安装 **mysql2** 包

<InstallPackages lib='mysql2'/>

#### 步骤 2 - 设置连接变量

<SetupEnv env_variable='DATABASE_URL' />

<Callout title='提示'>
如果您还没有 MySQL 数据库并想要创建一个用于测试，您可以使用我们关于如何在 Docker 中设置 MySQL 的指南。

Docker 中的 MySQL 指南可以在 [这里](/docs/guides/mysql-local-setup) 找到。去设置一下，生成一个数据库 URL（指南中有解释），然后回来进行下一步
</Callout>

#### 步骤 3 - 将 Drizzle ORM 连接到数据库

<ConnectMySQL/>

#### 步骤 4 - 创建一个表

<CreateTable/>

#### 步骤 5 - 设置 Drizzle 配置文件

<SetupConfig dialect='mysql' env_variable='DATABASE_URL'/>

#### 步骤 6 - 将更改应用到数据库

<ApplyChanges />

#### 步骤 7 - 填充和查询数据库

<QueryDatabase dialect='mysql2' env_variable='DATABASE_URL'/>

#### 步骤 8 - 运行 index.ts 文件

<RunFile/>

Source: https://drizzle.zhcndoc.com/docs/get-started/neon-existing

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import Steps from '@mdx/Steps.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import CodeTabs from "@mdx/CodeTabs.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import IntrospectPostgreSQL from '@mdx/get-started/postgresql/IntrospectPostgreSQL.mdx';
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';
import TransferCode from '@mdx/get-started/TransferCode.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import ConnectNeon from '@mdx/get-started/postgresql/ConnectNeon.mdx'
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import QueryDatabaseUpdated from '@mdx/get-started/QueryDatabaseUpdated.mdx';
import UpdateSchema from '@mdx/get-started/postgresql/UpdateSchema.mdx';

<Breadcrumbs/>

# 在现有项目中开始使用 Drizzle 和 Neon

<Prerequisites>
  - **dotenv** - 管理环境变量的包 - [点击这里阅读](https://www.npmjs.com/package/dotenv)
  - **tsx** - 运行 TypeScript 文件的包 - [点击这里阅读](https://tsx.is/)
  - **Neon** - 无服务器的 Postgres 平台 - [点击这里阅读](https://neon.tech/docs/introduction)
</Prerequisites>

<FileStructure/>

#### 步骤 1 - 安装 **@neondatabase/serverless** 包
<InstallPackages lib='@neondatabase/serverless'/>

#### 步骤 2 - 设置连接变量

<SetupEnv env_variable='DATABASE_URL' />

#### 步骤 3 - 设置 Drizzle 配置文件

<SetupConfig dialect='postgresql' env_variable='DATABASE_URL'/>

#### 步骤 4 - 对数据库进行探测

<IntrospectPostgreSQL/>

#### 步骤 5 - 将代码转移到实际的模式文件

<TransferCode/>

#### 步骤 6 - 将 Drizzle ORM 连接到数据库

<ConnectNeon/>

#### 步骤 7 - 查询数据库

<QueryDatabase dialect='neon-http' env_variable='DATABASE_URL'/>

#### 步骤 8 - 运行 index.ts 文件

<RunFile/>

#### 步骤 9 - 更新你的表结构（可选）

<UpdateSchema/>

#### 步骤 10 - 将更改应用于数据库（可选）

<ApplyChanges />

#### 步骤 11 - 用新字段查询数据库（可选）

<QueryDatabaseUpdated dialect='neon-http' env_variable='DATABASE_URL' />

Source: https://drizzle.zhcndoc.com/docs/get-started/neon-new

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import Steps from '@mdx/Steps.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import ConnectNeon from '@mdx/get-started/postgresql/ConnectNeon.mdx'
import CreateTable from '@mdx/get-started/postgresql/CreateTable.mdx'
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';

<Breadcrumbs/>

# 开始使用 Drizzle 和 Neon

<Prerequisites>
  - **dotenv** - 管理环境变量的包 - [阅读这里](https://www.npmjs.com/package/dotenv)
  - **tsx** - 运行 TypeScript 文件的包 - [阅读这里](https://tsx.is/)
  - **Neon** - 无服务器的 Postgres 平台 - [阅读这里](https://neon.tech/docs/introduction)
</Prerequisites>

Drizzle 对 Neon 连接有原生支持，使用 `neon-http` 和 `neon-websockets` 驱动。这些驱动在底层使用 **neon-serverless** 驱动。  
  
通过 `neon-http` 和 `neon-websockets` 驱动，您可以通过 HTTP 或 WebSockets 从无服务器环境访问 Neon 数据库，而不是使用 TCP。通过 HTTP 查询对于单个非交互式事务而言速度更快。  
  
如果您需要会话或交互式事务支持，或者完全兼容的 `pg` 驱动替代品，您可以使用基于 WebSocket 的 `neon-serverless` 驱动。您可以直接使用 [Postgres](/docs/get-started/postgresql-new) 连接到 Neon 数据库。

<FileStructure/>

#### 步骤 1 - 安装 **@neondatabase/serverless** 包
<InstallPackages lib='@neondatabase/serverless'/>

#### 步骤 2 - 设置连接变量

<SetupEnv env_variable='DATABASE_URL' />

#### 步骤 3 - 将 Drizzle ORM 连接到数据库

<ConnectNeon/>

#### 步骤 4 - 创建表

<CreateTable />

#### 步骤 5 - 设置 Drizzle 配置文件

<SetupConfig dialect='postgresql' env_variable='DATABASE_URL'/>

#### 步骤 6 - 将更改应用到数据库

<ApplyChanges />

#### 步骤 7 - 种子并查询数据库

<QueryDatabase dialect='neon-http' env_variable='DATABASE_URL'/>

#### 步骤 8 - 运行 index.ts 文件

<RunFile/>

Source: https://drizzle.zhcndoc.com/docs/get-started/nile-existing

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import Steps from '@mdx/Steps.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import CodeTabs from "@mdx/CodeTabs.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import IntrospectPostgreSQL from '@mdx/get-started/postgresql/IntrospectPostgreSQL.mdx';
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';
import TransferCode from '@mdx/get-started/TransferCode.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import ConnectNile from '@mdx/get-started/postgresql/ConnectNile.mdx';
import QueryNile from '@mdx/get-started/postgresql/QueryNile.mdx';
import QueryDatabaseUpdated from '@mdx/get-started/QueryDatabaseUpdated.mdx';
import UpdateSchema from '@mdx/get-started/postgresql/UpdateSchema.mdx';

<Breadcrumbs/>

# 在现有项目中开始使用 Drizzle 和 Nile

<Prerequisites>
  - **dotenv** - 管理环境变量的包 - [阅读这里](https://www.npmjs.com/package/dotenv)
  - **tsx** - 运行 TypeScript 文件的包 - [阅读这里](https://tsx.is/)
  - **Nile** - 针对多租户应用重新设计的 PostgreSQL - [阅读这里](https://thenile.dev/)
</Prerequisites>

<FileStructure/>

#### 步骤 1 - 安装 **postgres** 包
<InstallPackages lib='pg' devlib=' @types/pg'/>

#### 步骤 2 - 设置连接变量

<SetupEnv env_variable='NILEDB_URL' />

#### 步骤 3 - 设置 Drizzle 配置文件

<SetupConfig dialect='postgresql' env_variable='NILEDB_URL'/>

#### 步骤 4 - 探查数据库

Drizzle Kit 提供了一个 CLI 命令来探查你的数据库，并生成一个包含迁移的模式文件。模式文件包含数据库表、列、关系和索引的所有信息。

例如, 你的数据库中有这样一张表:

```sql copy
CREATE TABLE IF NOT EXISTS "todos" (
  "id" uuid DEFAULT gen_random_uuid(),
  "tenant_id" uuid,
  "title" varchar(256),
  "estimate" varchar(256),
  "embedding" vector(3),
  "complete" boolean
);
```

拉取你的数据库模式:

```bash copy
npx drizzle-kit pull
```

探查的结果将是一个 `schema.ts` 文件, `meta` 文件夹中包含数据库模式的快照, 一个包含迁移的 sql 文件和一个用于 [关系查询](/docs/rqb) 的 `relations.ts` 文件。

<Callout title='内置表'>
Nile 有几个内置表，它们是每个数据库的一部分。当你探查一个 Nile 数据库时，内置表将被包含在内。
例如，下面示例中看到的 `tenants` 表。这将使你能够轻松创建新租户、列出租户和进行其他操作。
</Callout>

以下是生成的 `schema.ts` 文件的示例:

```typescript copy filename="src/db/schema.ts"
// 通过探查生成的表模式
import { pgTable, uuid, text, timestamp, varchar, vector, boolean } from "drizzle-orm/pg-core"
import { sql } from "drizzle-orm"

export const tenants = pgTable("tenants", {
	id: uuid().default(sql`public.uuid_generate_v7()`).primaryKey().notNull(),
	name: text(),
	created: timestamp({ mode: 'string' }).default(sql`LOCALTIMESTAMP`).notNull(),
	updated: timestamp({ mode: 'string' }).default(sql`LOCALTIMESTAMP`).notNull(),
	deleted: timestamp({ mode: 'string' }),
});

export const todos = pgTable("todos", {
	id: uuid().defaultRandom(),
	tenantId: uuid("tenant_id"),
	title: varchar({ length: 256 }),
	estimate: varchar({ length: 256 }),
	embedding: vector({ dimensions: 3 }),
	complete: boolean(),
});
```

了解更多关于探查的信息，请查看 [文档](/docs/drizzle-kit-pull)。

#### 步骤 5 - 将代码转移到您的实际模式文件

<TransferCode/>

#### 步骤 6 - 将 Drizzle ORM 连接到数据库

<ConnectNile/>

#### 步骤 7 - 查询数据库

<QueryNile />

#### 步骤 8 - 运行 index.ts 文件

<RunFile/>

#### 步骤 9 - 更新您的表模式 (可选)

如果你想更新表模式，可以在 `schema.ts` 文件中进行。例如，我们来给 `todos` 表添加一个新列 `deadline`:

```typescript copy filename="src/db/schema.ts" {19}
import { pgTable, uuid, text, timestamp, varchar, vector, boolean } from "drizzle-orm/pg-core"
import { sql } from "drizzle-orm"

export const tenants = pgTable("tenants", {
	id: uuid().default(sql`public.uuid_generate_v7()`).primaryKey().notNull(),
	name: text(),
	created: timestamp({ mode: 'string' }).default(sql`LOCALTIMESTAMP`).notNull(),
	updated: timestamp({ mode: 'string' }).default(sql`LOCALTIMESTAMP`).notNull(),
	deleted: timestamp({ mode: 'string' }),
});

export const todos = pgTable("todos", {
	id: uuid().defaultRandom(),
	tenantId: uuid("tenant_id"),
	title: varchar({ length: 256 }),
	estimate: varchar({ length: 256 }),
	embedding: vector({ dimensions: 3 }),
	complete: boolean(),
  deadline: timestamp({ mode: 'string' })
});
```

#### 步骤 10 - 将更改应用到数据库 (可选)

<ApplyChanges />

#### 步骤 11 - 使用新字段查询数据库 (可选)

如果你再次运行 `index.ts` 文件，你将能够看到你刚刚添加的新字段。
该字段将为 `null`，因为我们在之前插入 todos 时没有填充截止日期。

<RunFile/>

Source: https://drizzle.zhcndoc.com/docs/get-started/nile-new

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import Steps from '@mdx/Steps.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import ConnectNile from '@mdx/get-started/postgresql/ConnectNile.mdx'
import CreateTable from '@mdx/get-started/postgresql/CreateTable.mdx'
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import QueryNile from '@mdx/get-started/postgresql/QueryNile.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';


<Breadcrumbs/>

# 使用 Drizzle 和 Nile 开始入门

<Prerequisites>
  - **dotenv** - 用于管理环境变量的包 - [阅读此处](https://www.npmjs.com/package/dotenv)
  - **tsx** - 用于运行 TypeScript 文件的包 - [阅读此处](https://tsx.is/)
  - **Nile** - 针对多租户应用重新设计的 PostgreSQL - [阅读此处](https://thenile.dev/)
</Prerequisites>

<FileStructure/>

#### 第 1 步 - 安装 **postgres** 包
<InstallPackages lib='pg' devlib=' @types/pg'/>

#### 第 2 步 - 设置连接变量

<SetupEnv env_variable='NILEDB_URL' />

#### 第 3 步 - 将 Drizzle ORM 连接到数据库

<ConnectNile />

#### 第 4 步 - 创建一个表

在 `src/db` 目录中创建一个 `schema.ts` 文件并声明你的表。由于 Nile 是多租户应用的 PostgreSQL，我们的模式包括一个用于租户的表和一个带有 `tenant_id` 列的待办事项表（我们称之为租户感知表）：

```typescript copy filename="src/db/schema.ts"
import { pgTable, uuid, text, timestamp, varchar, vector, boolean } from "drizzle-orm/pg-core"
import { sql } from "drizzle-orm"

export const tenantsTable = pgTable("tenants", {
	id: uuid().default(sql`public.uuid_generate_v7()`).primaryKey().notNull(),
	name: text(),
	created: timestamp({ mode: 'string' }).default(sql`LOCALTIMESTAMP`).notNull(),
	updated: timestamp({ mode: 'string' }).default(sql`LOCALTIMESTAMP`).notNull(),
	deleted: timestamp({ mode: 'string' }),
});

export const todos = pgTable("todos", {
	id: uuid().defaultRandom(),
	tenantId: uuid("tenant_id"),
	title: varchar({ length: 256 }),
	estimate: varchar({ length: 256 }),
	embedding: vector({ dimensions: 3 }),
	complete: boolean(),
});
```

#### 第 5 步 - 设置 Drizzle 配置文件

<SetupConfig dialect='postgresql' env_variable='NILEDB_URL'/>

#### 第 6 步 - 将更改应用到数据库

<ApplyChanges dialect='postgresql'/>

#### 第 7 步 - 填充和查询数据库

<QueryNile />

#### 第 8 步 - 运行 index.ts 文件

<RunFile/>

Source: https://drizzle.zhcndoc.com/docs/get-started/op-sqlite-existing

import Breadcrumbs from '@mdx/Breadcrumbs.astro';

<Breadcrumbs/>

# 在现有项目中使用 Drizzle 和 OP-SQLite 开始

我们没有关于在现有项目中使用 OP-SQLite 的正式指南，我们相信
来自 [入门指南](/docs/get-started/op-sqlite-new) 的所有信息应该足够了。

Source: https://drizzle.zhcndoc.com/docs/get-started/op-sqlite-new

import Npm from '@mdx/Npm.astro';
import Npx from '@mdx/Npx.astro';
import Callout from '@mdx/Callout.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import TransferCode from '@mdx/get-started/TransferCode.mdx';
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import QueryDatabaseUpdated from '@mdx/get-started/QueryDatabaseUpdated.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';
import CreateTable from '@mdx/get-started/sqlite/CreateTable.mdx';
import ConnectLibsql from '@mdx/get-started/sqlite/ConnectLibsql.mdx';

<Breadcrumbs/>

# 使用 Drizzle 和 OP-SQLite 开始

<Prerequisites>  
  - **OP-SQLite** - React-native 的 SQLite 库 - [在此阅读](https://github.com/OP-Engineering/op-sqlite)
</Prerequisites>


#### 第一步 - 从 Expo 模板设置项目
<Npx>
create expo-app --template blank-typescript
</Npx>

您可以在 [这里](https://docs.expo.dev/more/create-expo/#create-a-new-project) 阅读更多关于此模板的信息。

#### 基本文件结构

安装模板并添加 `db` 文件夹后，您将找到以下内容：在 `db/schema.ts` 文件中的 drizzle 表定义。 `drizzle` 文件夹包含 SQL 迁移文件和快照

```plaintext
📦 <项目根目录>
 ├ 📂 assets
 ├ 📂 drizzle
 ├ 📂 db
 │  └ 📜 schema.ts
 ├ 📜 .gitignore
 ├ 📜 .npmrc
 ├ 📜 app.json
 ├ 📜 App.tsx
 ├ 📜 babel.config.ts
 ├ 📜 drizzle.config.ts
 ├ 📜 package.json
 └ 📜 tsconfig.json
```

#### 第二步 - 安装所需包
<Npm>
  drizzle-orm @op-engineering/op-sqlite
  -D drizzle-kit
</Npm>

#### 第三步 - 将 Drizzle ORM 连接到数据库

在根目录创建一个 `App.tsx` 文件并初始化连接：

```ts
import { open } from '@op-engineering/op-sqlite';
import { drizzle } from 'drizzle-orm/op-sqlite';

const opsqliteDb = open({
  name: 'db',
});

const db = drizzle(opsqliteDb);
```

#### 第四步 - 创建一个表

在 `db` 目录中创建一个 `schema.ts` 文件并声明您的表：

```typescript copy filename="src/db/schema.ts"
import { int, sqliteTable, text } from "drizzle-orm/sqlite-core";

export const usersTable = sqliteTable("users_table", {
  id: int().primaryKey({ autoIncrement: true }),
  name: text().notNull(),
  age: int().notNull(),
  email: text().notNull().unique(),
});
```

#### 第五步 - 设置 Drizzle 配置文件

**Drizzle 配置** - 这是一个配置文件，用于 [Drizzle Kit](/docs/kit-overview)，包含有关您的数据库连接、迁移文件夹和架构文件的所有信息。

在项目的根目录创建一个 `drizzle.config.ts` 文件并添加以下内容：

```ts
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
  dialect: 'sqlite',
  driver: 'expo',
  schema: './db/schema.ts',
  out: './drizzle',
});
```

#### 第六步 - 设置 `metro` 配置

在根目录创建一个 `metro.config.js` 文件并添加此代码：

```js copy filename="metro.config.js"
const { getDefaultConfig } = require('expo/metro-config');
/** @type {import('expo/metro-config').MetroConfig} */
const config = getDefaultConfig(__dirname);
config.resolver.sourceExts.push('sql');
module.exports = config;
```

#### 第七步 - 更新 `babel` 配置
```js copy filename="babel.config.js"
module.exports = function(api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
    plugins: [["inline-import", { "extensions": [".sql"] }]] // <-- 添加这一行
  };
};
```

#### 第八步 - 将更改应用到数据库

在 Expo 中，您需要使用 `drizzle-kit generate` 命令生成迁移，并使用 `drizzle-orm` 的 `migrate()` 函数在运行时应用它们。

生成迁移：
```bash copy
npx drizzle-kit generate
```

#### 第九步 - 应用迁移并查询您的数据库：

让我们在 **App.tsx** 文件中添加迁移和查询以创建、读取、更新和删除用户

```ts copy
import { Text, View } from 'react-native';
import { open } from '@op-engineering/op-sqlite';
import { useEffect, useState } from 'react';
import { drizzle } from 'drizzle-orm/op-sqlite';
import { usersTable } from './db/schema';
import { useMigrations } from 'drizzle-orm/op-sqlite/migrator';
import migrations from './drizzle/migrations';

const opsqliteDb = open({
  name: 'db',
});

const db = drizzle(opsqliteDb);

export default function App() {
  const { success, error } = useMigrations(db, migrations);
  const [items, setItems] = useState<typeof usersTable.$inferSelect[] | null>(null);

  useEffect(() => {
    if (!success) return;

    (async () => {
      await db.delete(usersTable);

      await db.insert(usersTable).values([
        {
            name: 'John',
            age: 30,
            email: 'john@example.com',
        },
      ]);

      const users = await db.select().from(usersTable);
      setItems(users);
    })();
  }, [success]);

  if (error) {
    return (
      <View>
        <Text>Migration error: {error.message}</Text>
      </View>
    );
  }

  if (!success) {
    return (
      <View>
        <Text>Migration is in progress...</Text>
      </View>
    );
  }

  if (items === null || items.length === 0) {
    return (
      <View>
        <Text>Empty</Text>
      </View>
    );
  }

  return (
    <View
      style={{
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        width: '100%',
        height: '100%',
        justifyContent: 'center',
      }}
    >
      {items.map((item) => (
        <Text key={item.id}>{item.email}</Text>
      ))}
    </View>
  );
}
```

#### 第十步 - 预构建并运行 Expo 应用

<CodeTabs items={['npm', 'yarn', 'pnpm', 'bun']}>
```bash copy
npx expo run:ios
```
```bash copy
yarn expo run:ios
```
```bash copy
pnpm expo run:ios
```
```bash copy
bun expo run:ios
```
</CodeTabs>

Source: https://drizzle.zhcndoc.com/docs/get-started/pglite-existing

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import Steps from '@mdx/Steps.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import CodeTabs from "@mdx/CodeTabs.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import IntrospectPostgreSQL from '@mdx/get-started/postgresql/IntrospectPostgreSQL.mdx';
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';
import TransferCode from '@mdx/get-started/TransferCode.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import ConnectPgLite from '@mdx/get-started/postgresql/ConnectPgLite.mdx';
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import QueryDatabaseUpdated from '@mdx/get-started/QueryDatabaseUpdated.mdx';
import UpdateSchema from '@mdx/get-started/postgresql/UpdateSchema.mdx';

<Breadcrumbs/>

# 在现有项目中开始使用 Drizzle 和 PGLite

<Prerequisites>
  - **dotenv** - 管理环境变量的包 - [阅读这里](https://www.npmjs.com/package/dotenv)
  - **tsx** - 运行 TypeScript 文件的包 - [阅读这里](https://tsx.is/)
  - **ElectricSQL** - [网站](https://electric-sql.com/)
  - **pglite 驱动** - [文档](https://pglite.dev/) 和 [GitHub](https://github.com/electric-sql/pglite)
</Prerequisites>

<FileStructure/>

#### 第一步 - 安装所有需要的包
<InstallPackages lib='@electric-sql/pglite' />

#### 第二步 - 设置连接变量

<SetupEnv env_variable='DATABASE_URL' />

#### 第三步 - 设置 Drizzle 配置文件

<SetupConfig dialect='postgresql' env_variable='DATABASE_URL'/>

#### 第四步 - 直观化你的数据库

<IntrospectPostgreSQL/>

#### 第五步 - 转移代码到你的实际模式文件

<TransferCode/>

#### 第六步 - 将 Drizzle ORM 连接到数据库

<ConnectPgLite/>

#### 第七步 - 查询数据库

<QueryDatabase dialect='pglite' env_variable='DATABASE_URL'/>

#### 第八步 - 运行 index.ts 文件

<RunFile/>

#### 第九步 - 更新你的表模式（可选）

<UpdateSchema/>

#### 第十步 - 将更改应用于数据库（可选）

<ApplyChanges />

#### 第十一步 - 使用新字段查询数据库（可选）

<QueryDatabaseUpdated dialect='pglite' env_variable='DATABASE_URL' />

Source: https://drizzle.zhcndoc.com/docs/get-started/pglite-new

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import Steps from '@mdx/Steps.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import ConnectPgLite from '@mdx/get-started/postgresql/ConnectPgLite.mdx'
import CreateTable from '@mdx/get-started/postgresql/CreateTable.mdx'
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';

<Breadcrumbs/>

# 快速开始 Drizzle 和 PGlite

<Prerequisites>
  - **dotenv** - 用于管理环境变量的包 - [阅读这里](https://www.npmjs.com/package/dotenv)
  - **tsx** - 运行 TypeScript 文件的包 - [阅读这里](https://tsx.is/)
  - **ElectricSQL** - [官网](https://electric-sql.com/)
  - **pglite 驱动** - [文档](https://pglite.dev/) & [GitHub](https://github.com/electric-sql/pglite)
</Prerequisites>

<FileStructure/>

#### 步骤 1 - 安装所有所需的包
<InstallPackages lib='@electric-sql/pglite' />

#### 步骤 2 - 设置连接变量

<SetupEnv env_variable='DATABASE_URL' />

#### 步骤 3 - 将 Drizzle ORM 连接到数据库

<ConnectPgLite/>

#### 步骤 4 - 创建一个表

<CreateTable />

#### 步骤 5 - 设置 Drizzle 配置文件

<SetupConfig dialect='postgresql' env_variable='DATABASE_URL'/>

#### 步骤 6 - 将更改应用到数据库

<ApplyChanges />

#### 步骤 7 - 添加数据并查询数据库

<QueryDatabase dialect='pglite' env_variable='DATABASE_URL'/>

#### 步骤 8 - 运行 index.ts 文件

<RunFile/>

Source: https://drizzle.zhcndoc.com/docs/get-started/planetscale-existing

import Npm from '@mdx/Npm.astro';
import Callout from '@mdx/Callout.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';
import ConnectPlanetScale from '@mdx/get-started/mysql/ConnectPlanetScale.mdx';
import CreateTable from '@mdx/get-started/mysql/CreateTable.mdx';
import UpdateSchema from '@mdx/get-started/mysql/UpdateSchema.mdx';
import IntrospectMySQL from '@mdx/get-started/mysql/IntrospectMySQL.mdx';
import QueryPlanetScale from '@mdx/get-started/mysql/QueryPlanetScale.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import TransferCode from '@mdx/get-started/TransferCode.mdx';

<Breadcrumbs/>

# 在现有项目中开始使用 Drizzle 和 PlanetScale

<Prerequisites>  
  - **dotenv** - 管理环境变量的软件包 - [查看这里](https://www.npmjs.com/package/dotenv)
  - **tsx** - 运行 TypeScript 文件的软件包 - [查看这里](https://tsx.is)
  - **PlanetScale** - MySQL 数据库平台 - [查看这里](https://planetscale.com)
  - **database-js** - PlanetScale 无服务器驱动 - [查看这里](https://github.com/planetscale/database-js)
</Prerequisites>

<Callout title='重要' type='warning'>
在本教程中，我们将使用 `database-js` 驱动程序通过 **HTTP** 调用 PlanetScale 数据库。如果您需要
通过 TCP 连接到 PlanetScale，您可以参考我们的 [MySQL 开始使用](/docs/get-started/mysql-new) 页面。
</Callout>

<FileStructure/>

#### 第一步 - 安装 **@planetscale/database** 软件包

<InstallPackages lib='@planetscale/database'/>

#### 第二步 - 设置连接变量

<SetupEnv env_variable='DATABASE_URL' />

#### 第三步 - 设置 Drizzle 配置文件

<SetupConfig dialect='mysql' env_variable='DATABASE_URL'/>

#### 第四步 - 审视你的数据库

<IntrospectMySQL/>

#### 第五步 - 将代码转移到你的实际架构文件

<TransferCode/>

#### 第六步 - 将 Drizzle ORM 连接到数据库

<ConnectPlanetScale/>

#### 第七步 - 查询数据库

<QueryPlanetScale />

#### 第八步 - 运行 index.ts 文件

<RunFile/>

#### 第九步 - 更新你的表架构（可选）

<UpdateSchema/>

#### 第十步 - 将更改应用到数据库（可选）

<ApplyChanges/>

#### 第十一步 - 使用新字段查询数据库（可选）

```typescript copy filename="src/index.ts"
import 'dotenv/config';
import { eq } from 'drizzle-orm';
import { drizzle } from 'drizzle-orm/planetscale-serverless';
import { usersTable } from './db/schema';

async function main() {
  const db = drizzle({ connection: {
      host: process.env.DATABASE_HOST!,
      username: process.env.DATABASE_USERNAME!,
      password: process.env.DATABASE_PASSWORD!,
    }});

  const user: typeof usersTable.$inferInsert = {
    name: 'John',
    age: 30,
    email: 'john@example.com',
    phone: '123-456-7890',
  };

  await db.insert(usersTable).values(user);
  console.log('新用户已创建！')

  const users = await db.select().from(usersTable);
  console.log('从数据库获取所有用户: ', users)
  /*
  const users: {
    id: number;
    name: string;
    age: number;
    email: string;
    phone: string | null;
  }[]
  */

  await db
    .update(usersTable)
    .set({
      age: 31,
    })
    .where(eq(usersTable.email, user.email));
  console.log('用户信息已更新！')

  await db.delete(usersTable).where(eq(usersTable.email, user.email));
  console.log('用户已删除！')
}

main();
```

Source: https://drizzle.zhcndoc.com/docs/get-started/planetscale-new

import Npm from '@mdx/Npm.astro';
import Callout from '@mdx/Callout.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';
import ConnectPlanetScale from '@mdx/get-started/mysql/ConnectPlanetScale.mdx';
import CreateTable from '@mdx/get-started/mysql/CreateTable.mdx';
import QueryPlanetScale from '@mdx/get-started/mysql/QueryPlanetScale.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';

<Breadcrumbs/>

# 开始使用 Drizzle 和 PlanetScale

<Prerequisites>  
  - **dotenv** - 管理环境变量的包 - [点击这里阅读](https://www.npmjs.com/package/dotenv)
  - **tsx** - 运行 TypeScript 文件的包 - [点击这里阅读](https://tsx.is)
  - **PlanetScale** - MySQL 数据库平台 - [点击这里阅读](https://planetscale.com)
  - **database-js** - PlanetScale 无服务器驱动程序 - [点击这里阅读](https://github.com/planetscale/database-js)
</Prerequisites>

<Callout title='重要' type='warning'>
在本教程中，我们将使用 `database-js` 驱动程序通过 **HTTP** 调用 PlanetScale 数据库。如果您需要通过 TCP 连接到 PlanetScale，可以参考我们的 [MySQL 入门](/docs/get-started/mysql-new) 页面。
</Callout>

<FileStructure/>

#### 步骤 1 - 安装 **@planetscale/database** 包

<InstallPackages lib='@planetscale/database'/>

#### 步骤 2 - 设置连接变量

在项目根目录下创建一个 `.env` 文件，并添加您的数据库连接变量：

```plaintext copy
DATABASE_HOST=
DATABASE_USERNAME=
DATABASE_PASSWORD=
```

<Callout title='提示'>
要获取通过 `database-js` 驱动程序连接所需的所有环境变量，请查看 [PlanetScale 文档](https://planetscale.com/docs/tutorials/planetscale-serverless-driver-node-example#use-the-sample-repository)
</Callout>

#### 步骤 3 - 将 Drizzle ORM 连接到数据库

<ConnectPlanetScale/>

#### 步骤 4 - 创建一个表

<CreateTable/>

#### 步骤 5 - 设置 Drizzle 配置文件

<SetupConfig dialect='mysql' env_variable='DATABASE_URL'/>

#### 步骤 6 - 将更改应用到数据库

<ApplyChanges />

#### 步骤 7 - 种子数据并查询数据库

<QueryPlanetScale />

#### 步骤 8 - 运行 index.ts 文件

<RunFile/>

Source: https://drizzle.zhcndoc.com/docs/get-started/postgresql-existing

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import Steps from '@mdx/Steps.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import CodeTabs from "@mdx/CodeTabs.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import IntrospectPostgreSQL from '@mdx/get-started/postgresql/IntrospectPostgreSQL.mdx';
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';
import TransferCode from '@mdx/get-started/TransferCode.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import ConnectPostgreSQL from '@mdx/get-started/postgresql/ConnectPostgreSQL.mdx';
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import QueryDatabaseUpdated from '@mdx/get-started/QueryDatabaseUpdated.mdx';
import UpdateSchema from '@mdx/get-started/postgresql/UpdateSchema.mdx';

<Breadcrumbs/>

# 在现有项目中开始使用 Drizzle 和 PostgreSQL

<Prerequisites>
  - **dotenv** - 用于管理环境变量的包 - [查看这里](https://www.npmjs.com/package/dotenv)
  - **tsx** - 用于运行 TypeScript 文件的包 - [查看这里](https://tsx.is/)
  - **node-postgres** - 用于查询 PostgreSQL 数据库的包 - [查看这里](https://node-postgres.com/)
</Prerequisites>

<FileStructure/>

#### 第 1 步 - 安装 **node-postgres** 包
<InstallPackages lib='pg' devlib=' @types/pg'/>

#### 第 2 步 - 设置连接变量

<SetupEnv env_variable='DATABASE_URL' />

<Callout title='提示'>
如果您还没有 PostgreSQL 数据库并想创建一个用于测试，您可以参考我们的指南，了解如何在 Docker 中设置 PostgreSQL。

Docker 中的 PostgreSQL 指南可在 [这里](/docs/guides/postgresql-local-setup) 获取。去设置它，生成数据库 URL（在指南中有说明），然后回来进行下一步。
</Callout>

#### 第 3 步 - 设置 Drizzle 配置文件

<SetupConfig dialect='postgresql' env_variable='DATABASE_URL'/>

#### 第 4 步 - 直观检查您的数据库

<IntrospectPostgreSQL/>

#### 第 5 步 - 将代码转移到您的实际模式文件

<TransferCode/>

#### 第 6 步 - 将 Drizzle ORM 连接到数据库

<ConnectPostgreSQL/>

#### 第 7 步 - 查询数据库

<QueryDatabase dialect='node-postgres' env_variable='DATABASE_URL'/>

#### 第 8 步 - 运行 index.ts 文件

<RunFile/>

#### 第 9 步 - 更新您的表模式（可选）

<UpdateSchema/>

#### 第 10 步 - 将更改应用于数据库（可选）

<ApplyChanges />

#### 第 11 步 - 使用新字段查询数据库（可选）

<QueryDatabaseUpdated dialect='node-postgres' env_variable='DATABASE_URL' />

Source: https://drizzle.zhcndoc.com/docs/get-started/postgresql-new

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import Steps from '@mdx/Steps.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import ConnectPostgreSQL from '@mdx/get-started/postgresql/ConnectPostgreSQL.mdx'
import CreateTable from '@mdx/get-started/postgresql/CreateTable.mdx'
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';

<Breadcrumbs/>

# 使用 Drizzle 和 PostgreSQL 开始

<Prerequisites>
  - **dotenv** - 管理环境变量的包 - [点击这里阅读](https://www.npmjs.com/package/dotenv)
  - **tsx** - 运行 TypeScript 文件的包 - [点击这里阅读](https://tsx.is/)
  - **node-postgres** - 查询 PostgreSQL 数据库的包 - [点击这里阅读](https://node-postgres.com/)
</Prerequisites>

Drizzle 对 `node-postgres` 和 `postgres.js` 驱动程序的 PostgreSQL 连接提供原生支持。

我们将在这个入门示例中使用 `node-postgres`。但如果你想找到更多连接 PostgreSQL 的方式，可以查看我们的 [PostgreSQL 连接](/docs/get-started-postgresql) 页面。

<FileStructure/>

#### 第 1 步 - 安装 **node-postgres** 包
<InstallPackages lib='pg' devlib=' @types/pg'/>

#### 第 2 步 - 设置连接变量

<SetupEnv env_variable='DATABASE_URL' />

<Callout title='提示'>
如果你还没有 PostgreSQL 数据库并想创建一个进行测试，你可以查看我们的指南，了解如何在 Docker 中设置 PostgreSQL。

Docker 中的 PostgreSQL 设置指南可以在 [这里](/docs/guides/postgresql-local-setup) 找到。去设置它，生成一个数据库 URL（在指南中有说明），然后回来进行下一步。
</Callout>

#### 第 3 步 - 将 Drizzle ORM 连接到数据库

<ConnectPostgreSQL/>

#### 第 4 步 - 创建一个表

<CreateTable />

#### 第 5 步 - 设置 Drizzle 配置文件

<SetupConfig dialect='postgresql' env_variable='DATABASE_URL'/>

#### 第 6 步 - 将更改应用到数据库

<ApplyChanges />

#### 第 7 步 - 向数据库填充数据并查询

<QueryDatabase dialect='node-postgres' env_variable='DATABASE_URL'/>

#### 第 8 步 - 运行 index.ts 文件

<RunFile/>

Source: https://drizzle.zhcndoc.com/docs/get-started/singlestore-existing

import Npm from '@mdx/Npm.astro';
import Callout from '@mdx/Callout.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';
import ConnectSingleStore from '@mdx/get-started/singlestore/ConnectSingleStore.mdx';
import UpdateSchema from '@mdx/get-started/singlestore/UpdateSchema.mdx';
import IntrospectSingleStore from '@mdx/get-started/singlestore/IntrospectSingleStore.mdx';
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import QueryDatabaseUpdated from '@mdx/get-started/QueryDatabaseUpdated.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import TransferCode from '@mdx/get-started/TransferCode.mdx';

<Breadcrumbs/>

# Get Started with Drizzle and SingleStore in existing project

<Prerequisites>  
  - **dotenv** - package for managing environment variables - [read here](https://www.npmjs.com/package/dotenv)
  - **tsx** - package for running TypeScript files - [read here](https://tsx.is/)
  - **mysql2** - package for querying your SingleStore database - [read here](https://github.com/sidorares/node-mysql2)
</Prerequisites>

<FileStructure/>

#### Step 1 - Install the `mysql2` package

<InstallPackages lib='mysql2'/>

#### Step 2 - Setup connection variables

<SetupEnv env_variable='DATABASE_URL' />

#### Step 3 - Setup Drizzle config file

<SetupConfig dialect='singlestore' env_variable='DATABASE_URL'/>

#### Step 4 - Introspect your database

<IntrospectSingleStore/>

#### Step 5 - Transfer code to your actual schema file

<TransferCode/>

#### Step 6 - Connect Drizzle ORM to the database

<ConnectSingleStore/>

#### Step 7 - Query the database

<QueryDatabase dialect='singlestore' env_variable='DATABASE_URL'/>

#### Step 8 - Run index.ts file

<RunFile/>

#### Step 9 - Update your table schema (optional)

<UpdateSchema/>

#### Step 10 - Applying changes to the database (optional)

<ApplyChanges/>

#### Step 11 - Query the database with a new field (optional)

<QueryDatabaseUpdated dialect='singlestore' env_variable='DATABASE_URL' />

Source: https://drizzle.zhcndoc.com/docs/get-started/singlestore-new

import Npm from '@mdx/Npm.astro';
import Callout from '@mdx/Callout.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';
import ConnectSingleStore from '@mdx/get-started/singlestore/ConnectSingleStore.mdx';
import CreateSingleStoreTable from '@mdx/get-started/singlestore/CreateSingleStoreTable.mdx';
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';

<Breadcrumbs/>

# 使用 Drizzle 和 SingleStore 入门

<Prerequisites>  
  - **dotenv** —— 用于管理环境变量的包 —— [点击查看](https://www.npmjs.com/package/dotenv)
  - **tsx** —— 用于运行 TypeScript 文件的包 —— [点击查看](https://tsx.is/)
  - **mysql2** —— 用于查询 MySQL 数据库的包 —— [点击查看](https://github.com/sidorares/node-mysql2)
</Prerequisites>

要将 Drizzle 用于 SingleStore 数据库，您应使用 `singlestore` 驱动。

根据 **[官方网站](https://github.com/sidorares/node-mysql2)**，  
`mysql2` 是一个专注于性能的 Node.js MySQL 客户端。

Drizzle ORM 原生支持 `mysql2`，并提供了用于 SingleStore 数据库的 `drizzle-orm/singlestore` 包。

<FileStructure/>

#### 第 1 步 - 安装 **mysql2** 包

<InstallPackages lib='mysql2'/>

#### 第 2 步 - 设置连接变量

<SetupEnv env_variable='DATABASE_URL' />

#### 第 3 步 - 连接 Drizzle ORM 到数据库

<ConnectSingleStore/>

#### 第 4 步 - 创建一个表

<CreateSingleStoreTable/>

#### 第 5 步 - 设置 Drizzle 配置文件

<SetupConfig dialect='singlestore' env_variable='DATABASE_URL'/>

#### 第 6 步 - 应用数据库更改

<ApplyChanges />

#### 第 7 步 - 填充并查询数据库

<QueryDatabase dialect='singlestore' env_variable='DATABASE_URL'/>

#### 第 8 步 - 运行 index.ts 文件

<RunFile/>

Source: https://drizzle.zhcndoc.com/docs/get-started/sqlite-existing

import Npm from '@mdx/Npm.astro';
import Npx from '@mdx/Npx.astro';
import Callout from '@mdx/Callout.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import TransferCode from '@mdx/get-started/TransferCode.mdx';
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import QueryDatabaseUpdated from '@mdx/get-started/QueryDatabaseUpdated.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';
import IntrospectSqlite from '@mdx/get-started/sqlite/IntrospectSqlite.mdx';
import ConnectLibsql from '@mdx/get-started/sqlite/ConnectLibsql.mdx';
import UpdateSchema from '@mdx/get-started/sqlite/UpdateSchema.mdx';

<Breadcrumbs/>

# 在现有项目中使用 Drizzle 和 SQLite 开始

<Prerequisites>  
  - **dotenv** - 用于管理环境变量的软件包 - [了解更多](https://www.npmjs.com/package/dotenv)
  - **tsx** - 用于运行 TypeScript 文件的软件包 - [了解更多](https://tsx.is/)
  - **libsql** - 一个针对低查询延迟进行优化的 SQLite 分支，适合全球应用 - [了解更多](https://docs.turso.tech/libsql)
</Prerequisites>

<FileStructure />

#### 第 1 步 - 安装所需的软件包

<InstallPackages lib='@libsql/client'/>

#### 第 2 步 - 设置连接变量

<SetupEnv env_variable='DB_FILE_NAME' />

<Callout type='info' title='重要'>
例如，如果你想在项目根目录创建一个 SQLite 数据库文件用于测试，你需要在实际文件名之前使用 `file:`，因为这是 `LibSQL` 所需的格式，如下所示：
```plaintext copy
DB_FILE_NAME=file:local.db
```
你可以查看 **[LibSQL 文档](https://docs.turso.tech/sdk/ts/reference#local-development)** 获取更多信息。
</Callout>

#### 第 3 步 - 设置 Drizzle 配置文件

<SetupConfig dialect='sqlite' env_variable='DB_FILE_NAME'/>

#### 第 4 步 - 检查你的数据库

<IntrospectSqlite/>

#### 第 5 步 - 将代码转移到你的实际模式文件

<TransferCode/>

#### 第 6 步 - 将 Drizzle ORM 连接到数据库

<ConnectLibsql/>

#### 第 7 步 - 查询数据库

<QueryDatabase dialect='libsql' env_variable='DB_FILE_NAME' />

#### 第 8 步 - 运行 index.ts 文件

<RunFile/>

#### 第 9 步 - 更新你的表模式（可选）

<UpdateSchema/>

#### 第 10 步 - 在数据库中应用更改（可选）

<ApplyChanges/>

#### 第 11 步 - 使用新字段查询数据库（可选）

<QueryDatabaseUpdated dialect='libsql' env_variable='DB_FILE_NAME' />

Source: https://drizzle.zhcndoc.com/docs/get-started/sqlite-new

import Npm from '@mdx/Npm.astro';
import Npx from '@mdx/Npx.astro';
import Callout from '@mdx/Callout.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import TransferCode from '@mdx/get-started/TransferCode.mdx';
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import QueryDatabaseUpdated from '@mdx/get-started/QueryDatabaseUpdated.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';
import CreateTable from '@mdx/get-started/sqlite/CreateTable.mdx';
import ConnectLibsql from '@mdx/get-started/sqlite/ConnectLibsql.mdx';

<Breadcrumbs/>

# 开始使用 Drizzle 和 SQLite

<Prerequisites>  
  - **dotenv** - 管理环境变量的包 - [阅读这里](https://www.npmjs.com/package/dotenv)
  - **tsx** - 运行 TypeScript 文件的包 - [阅读这里](https://tsx.is/)
  - **libsql** - 针对低查询延迟优化的 SQLite 分支，使其适合全球应用 - [阅读这里](https://docs.turso.tech/libsql)
</Prerequisites>

Drizzle 对 `libsql` 和 `better-sqlite3` 驱动程序的 SQLite 连接提供原生支持。

我们将在这个入门示例中使用 `libsql`。但是如果想了解更多连接 SQLite 的方式，请查看我们的 [SQLite 连接](/docs/get-started-sqlite) 页面。

<FileStructure />

#### 第一步 - 安装所需的包
<InstallPackages lib='@libsql/client'/>

#### 第二步 - 设置连接变量

<SetupEnv env_variable='DB_FILE_NAME' />

<Callout type='info' title='重要'>
例如，如果您想在项目根目录中创建一个 SQLite 数据库文件以进行测试，您需要在实际文件名之前使用 `file:`，这是 `LibSQL` 要求的格式，如下所示：
```plaintext copy
DB_FILE_NAME=file:local.db
```
您可以查看 **[LibSQL 文档](https://docs.turso.tech/sdk/ts/reference#local-development)** 以获取更多信息。
</Callout>

#### 第三步 - 将 Drizzle ORM 连接到数据库

<ConnectLibsql/>

#### 第四步 - 创建表

<CreateTable/>

#### 第五步 - 设置 Drizzle 配置文件

<SetupConfig dialect='sqlite' env_variable='DB_FILE_NAME'/>

#### 第六步 - 将更改应用到数据库

<ApplyChanges />

#### 第七步 - 填充和查询数据库

<QueryDatabase dialect='libsql' env_variable='DB_FILE_NAME'/>

#### 第八步 - 运行 index.ts 文件

<RunFile/>

Source: https://drizzle.zhcndoc.com/docs/get-started/supabase-existing

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import Steps from '@mdx/Steps.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import CodeTabs from "@mdx/CodeTabs.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import IntrospectPostgreSQL from '@mdx/get-started/postgresql/IntrospectPostgreSQL.mdx';
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';
import TransferCode from '@mdx/get-started/TransferCode.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import ConnectSupabase from '@mdx/get-started/postgresql/ConnectSupabase.mdx'
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import QueryDatabaseUpdated from '@mdx/get-started/QueryDatabaseUpdated.mdx';
import UpdateSchema from '@mdx/get-started/postgresql/UpdateSchema.mdx';

<Breadcrumbs/>

# 在现有项目中开始使用 Drizzle 和 Supabase

<Prerequisites>
  - **dotenv** - 用于管理环境变量的包 - [阅读这里](https://www.npmjs.com/package/dotenv)
  - **tsx** - 用于运行 TypeScript 文件的包 - [阅读这里](https://tsx.is/)
  - **Supabase** - 开源的 Firebase 替代方案 - [阅读这里](https://supabase.com/)
</Prerequisites>

<FileStructure/>

#### 第 1 步 - 安装 **postgres** 包
<InstallPackages lib='postgres'/>

#### 第 2 步 - 设置连接变量

<SetupEnv env_variable='DATABASE_URL' />

#### 第 3 步 - 设置 Drizzle 配置文件

<SetupConfig dialect='postgresql' env_variable='DATABASE_URL'/>

#### 第 4 步 - 内省你的数据库

<IntrospectPostgreSQL/>

#### 第 5 步 - 将代码转移到你的实际架构文件

<TransferCode/>

#### 第 6 步 - 将 Drizzle ORM 连接到数据库

<ConnectSupabase/>

#### 第 7 步 - 查询数据库

<QueryDatabase dialect='postgres-js' env_variable='DATABASE_URL'/>

#### 第 8 步 - 运行 index.ts 文件

<RunFile/>

#### 第 9 步 - 更新你的表架构（可选）

<UpdateSchema/>

#### 第 10 步 - 将更改应用于数据库（可选）

<ApplyChanges />

#### 第 11 步 - 使用新字段查询数据库（可选）

<QueryDatabaseUpdated dialect='postgres-js' env_variable='DATABASE_URL' />

Source: https://drizzle.zhcndoc.com/docs/get-started/supabase-new

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import Steps from '@mdx/Steps.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import ConnectSupabase from '@mdx/get-started/postgresql/ConnectSupabase.mdx'
import CreateTable from '@mdx/get-started/postgresql/CreateTable.mdx'
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';

<Breadcrumbs/>

# 开始使用 Drizzle 和 Supabase

<Prerequisites>
  - **dotenv** - 管理环境变量的包 - [在这里阅读](https://www.npmjs.com/package/dotenv)
  - **tsx** - 运行 TypeScript 文件的包 - [在这里阅读](https://tsx.is/)
  - **Supabase** - 开源的 Firebase 替代品 - [在这里阅读](https://supabase.com/)
</Prerequisites>

<FileStructure/>

#### 第一步 - 安装 **postgres** 包
<InstallPackages lib='postgres'/>

#### 第二步 - 设置连接变量

<SetupEnv env_variable='DATABASE_URL' />

#### 第三步 - 将 Drizzle ORM 连接到数据库

<ConnectSupabase/>

#### 第四步 - 创建一个表

<CreateTable />

#### 第五步 - 设置 Drizzle 配置文件

<SetupConfig dialect='postgresql' env_variable='DATABASE_URL'/>

#### 第六步 - 将更改应用到数据库

<ApplyChanges />

#### 第七步 - 填充和查询数据库

<QueryDatabase dialect='postgres-js' env_variable='DATABASE_URL'/>

#### 第八步 - 运行 index.ts 文件

<RunFile/>

Source: https://drizzle.zhcndoc.com/docs/get-started/tidb-existing

import Npm from '@mdx/Npm.astro';
import Callout from '@mdx/Callout.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';
import ConnectTiDB from '@mdx/get-started/mysql/ConnectTiDB.mdx';
import CreateTable from '@mdx/get-started/mysql/CreateTable.mdx';
import UpdateSchema from '@mdx/get-started/mysql/UpdateSchema.mdx';
import IntrospectMySQL from '@mdx/get-started/mysql/IntrospectMySQL.mdx';
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import QueryDatabaseUpdated from '@mdx/get-started/QueryDatabaseUpdated.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import TransferCode from '@mdx/get-started/TransferCode.mdx';

<Breadcrumbs/>

# 在现有项目中开始使用 Drizzle 和 TiDB

<Prerequisites>  
  - **dotenv** - 用于管理环境变量的包 - [详细阅读](https://www.npmjs.com/package/dotenv)
  - **tsx** - 用于运行 TypeScript 文件的包 - [详细阅读](https://tsx.is/)
  - **TiDB** - PingCAP 提供的分布式 SQL 数据库 - [详细阅读](https://www.pingcap.com/)
  - **serverless-js** - 用于需要 HTTP 外部连接的无服务器和边缘计算平台的包 - [详细阅读](https://github.com/tidbcloud/serverless-js)
</Prerequisites>

<FileStructure/>

#### 第一步 - 安装 **@tidbcloud/serverless** 包

<InstallPackages lib='@tidbcloud/serverless'/>

#### 第二步 - 设置连接变量

<SetupEnv env_variable='DATABASE_URL' />

#### 第三步 - 设置 Drizzle 配置文件

<SetupConfig dialect='mysql' env_variable='DATABASE_URL'/>

#### 第四步 - 反向工程数据库

<IntrospectMySQL/>

#### 第五步 - 将代码转移到实际的模式文件

<TransferCode/>

#### 第六步 - 将 Drizzle ORM 连接到数据库

<ConnectTiDB/>

#### 第七步 - 查询数据库

<QueryDatabase dialect='tidb-serverless' env_variable='DATABASE_URL'/>

#### 第八步 - 运行 index.ts 文件

<RunFile/>

#### 第九步 - 更新你的表模式（可选）

<UpdateSchema/>

#### 第十步 - 将更改应用到数据库（可选）

<ApplyChanges/>

#### 第十一步 - 使用新字段查询数据库（可选）

<QueryDatabaseUpdated dialect='tidb-serverless' env_variable='DATABASE_URL' />

Source: https://drizzle.zhcndoc.com/docs/get-started/tidb-new

import Npm from '@mdx/Npm.astro';
import Callout from '@mdx/Callout.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';
import ConnectTiDB from '@mdx/get-started/mysql/ConnectTiDB.mdx';
import CreateTable from '@mdx/get-started/mysql/CreateTable.mdx';
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';

<Breadcrumbs/>

# 开始使用 Drizzle 和 TiDB

<Prerequisites>  
  - **dotenv** - 管理环境变量的包 - [查看这里](https://www.npmjs.com/package/dotenv)
  - **tsx** - 运行 TypeScript 文件的包 - [查看这里](https://tsx.is/)
  - **TiDB** - PingCAP 的分布式 SQL 数据库 - [查看这里](https://www.pingcap.com/)
  - **serverless-js** - 用于需要 HTTP 外部连接的无服务器和边缘计算平台的包 - [查看这里](https://github.com/tidbcloud/serverless-js)
</Prerequisites>

<Callout title='重要' type='warning'>
在本教程中，我们将使用 `@tidbcloud/serverless` 驱动程序进行 **HTTP** 调用。如果您需要通过 TCP 连接到 TiDB，可以参考我们的 [MySQL 开始使用](/docs/get-started/mysql-new) 页面
</Callout>

<FileStructure/>

#### 第一步 - 安装 **@tidbcloud/serverless** 包

<InstallPackages lib='@tidbcloud/serverless'/>

#### 第二步 - 设置连接变量

<SetupEnv env_variable='DATABASE_URL' />

#### 第三步 - 将 Drizzle ORM 连接到数据库

<ConnectTiDB/>

#### 第四步 - 创建一个表

<CreateTable/>

#### 第五步 - 设置 Drizzle 配置文件

<SetupConfig dialect='mysql' env_variable='DATABASE_URL'/>

#### 第六步 - 将更改应用到数据库

<ApplyChanges />

#### 第七步 - 填充并查询数据库

<QueryDatabase dialect='tidb-serverless' env_variable='DATABASE_URL'/>

#### 第八步 - 运行 index.ts 文件

<RunFile/>

Source: https://drizzle.zhcndoc.com/docs/get-started/turso-existing

import Npm from '@mdx/Npm.astro';
import Npx from '@mdx/Npx.astro';
import Callout from '@mdx/Callout.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import TransferCode from '@mdx/get-started/TransferCode.mdx';
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import QueryDatabaseUpdated from '@mdx/get-started/QueryDatabaseUpdated.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';
import IntrospectSqlite from '@mdx/get-started/sqlite/IntrospectSqlite.mdx';
import ConnectLibsql from '@mdx/get-started/sqlite/ConnectLibsql.mdx';
import UpdateSchema from '@mdx/get-started/sqlite/UpdateSchema.mdx';
import QueryTurso from '@mdx/get-started/sqlite/QueryTurso.mdx';
import QueryTursoUpdated from '@mdx/get-started/sqlite/QueryTursoUpdated.mdx';
import LibsqlTable from '@mdx/LibsqlTable.mdx';
import LibsqlTabs from '@mdx/LibsqlTabs.mdx';

<Breadcrumbs/>

# 在现有项目中使用 Drizzle 和 Turso 开始

<Prerequisites>  
  - **dotenv** - 用于管理环境变量的包 - [阅读这里](https://www.npmjs.com/package/dotenv)
  - **tsx** - 运行 TypeScript 文件的包 - [阅读这里](https://tsx.is/)
  - **turso** - 生产环境中的 SQLite - [阅读这里](https://turso.tech/)
  - **libsql** - 性能优化的 SQLite 分支，适合全球应用 - [阅读这里](https://docs.turso.tech/libsql)
</Prerequisites>

<FileStructure />

#### 第一步 - 安装所需的包

<InstallPackages lib='@libsql/client'/>

#### 第二步 - 设置连接变量

在你的项目根目录创建一个 `.env` 文件，并添加你的 Turso 数据库 URL 和认证令牌：

```plaintext copy
TURSO_DATABASE_URL=
TURSO_AUTH_TOKEN=
```

<Callout type='info' title='重要'>
如果你不知道你的 `TURSO_DATABASE_URL` 和 `TURSO_AUTH_TOKEN` 值，可以参考 LibSQL Driver SDK 教程。 
查看 [这里](https://docs.turso.tech/sdk/ts/quickstart)，完成后再回来将所有生成的值添加到 `.env` 文件中
</Callout>

#### 第三步 - 设置 Drizzle 配置文件

**Drizzle 配置** - 用于 [Drizzle Kit](/docs/kit-overview) 的配置文件，包含你的数据库连接、迁移文件夹和模式文件的信息。

在项目根目录创建一个 `drizzle.config.ts` 文件，并添加以下内容：

```typescript copy filename="drizzle.config.ts"
import 'dotenv/config';
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
  out: './drizzle',
  schema: './src/db/schema.ts',
  dialect: 'turso',
  dbCredentials: {
    url: process.env.TURSO_DATABASE_URL,
    authToken: process.env.TURSO_AUTH_TOKEN,
  },
});
```

#### 第四步 - 反向工程你的数据库

<IntrospectSqlite/>

#### 第五步 - 将代码转移到你的实际模式文件

<TransferCode/>

#### 第六步 - 连接 Drizzle ORM 到数据库
Drizzle 原生支持所有 @libsql/client 驱动程序变体：

<LibsqlTable />
<br/>
<LibsqlTabs />

在 `src` 目录创建一个 `index.ts` 文件并初始化连接：

```typescript copy
import 'dotenv/config';
import { drizzle } from 'drizzle-orm/libsql';

// 你可以指定 libsql 连接选项中的任何属性
const db = drizzle({ 
  connection: { 
    url: process.env.TURSO_DATABASE_URL!, 
    authToken: process.env.TURSO_AUTH_TOKEN!
  }
});
```

如果您需要提供您现有的驱动程序：

```typescript copy
import 'dotenv/config';
import { drizzle } from 'drizzle-orm/libsql';
import { createClient } from '@libsql/client';

const client = createClient({ 
  url: process.env.TURSO_DATABASE_URL!, 
  authToken: process.env.TURSO_AUTH_TOKEN!
});

const db = drizzle({ client });
```

#### 第七步 - 查询数据库

<QueryTurso/>

#### 第八步 - 运行 index.ts 文件

<RunFile/>

#### 第九步 - 更新你的表模式（可选）

<UpdateSchema/>

#### 第九步 - 将更改应用到数据库（可选）

<ApplyChanges/>

#### 第十步 - 使用新字段查询数据库（可选）

<QueryTursoUpdated />

Source: https://drizzle.zhcndoc.com/docs/get-started/turso-new

import Npm from '@mdx/Npm.astro';
import Npx from '@mdx/Npx.astro';
import Callout from '@mdx/Callout.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import WhatsNextPostgres from "@mdx/WhatsNextPostgres.astro";
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import TransferCode from '@mdx/get-started/TransferCode.mdx';
import QueryTurso from '@mdx/get-started/sqlite/QueryTurso.mdx';
import QueryDatabaseUpdated from '@mdx/get-started/QueryDatabaseUpdated.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';
import CreateTable from '@mdx/get-started/sqlite/CreateTable.mdx';
import ConnectLibsql from '@mdx/get-started/sqlite/ConnectLibsql.mdx';
import LibsqlTable from '@mdx/LibsqlTable.mdx';
import LibsqlTabs from '@mdx/LibsqlTabs.mdx';

<Breadcrumbs/>

# 使用 Drizzle 和 Turso 开始

<Prerequisites>  
  - **dotenv** - 管理环境变量的包 - [在这里阅读](https://www.npmjs.com/package/dotenv)
  - **tsx** - 运行 TypeScript 文件的包 - [在这里阅读](https://tsx.is/)
  - **turso** - 用于生产的 SQLite - [在这里阅读](https://turso.tech/)
  - **libsql** - 优化了低查询延迟的 SQLite 分支，适合全球应用 - [在这里阅读](https://docs.turso.tech/libsql)
</Prerequisites>

<FileStructure />

#### 步骤 1 - 安装所需的包
<InstallPackages lib='@libsql/client'/>

#### 步骤 2 - 设置连接变量

在项目根目录创建一个 `.env` 文件，并添加你的 Turso 数据库 URL 和授权令牌：

```plaintext copy
TURSO_DATABASE_URL=
TURSO_AUTH_TOKEN=
```

<Callout type='info' title='重要'>
如果你不知道 `TURSO_DATABASE_URL` 和 `TURSO_AUTH_TOKEN` 的值，可以参考 LibSQL 驱动 SDK 教程。 
查看 [这里](https://docs.turso.tech/sdk/ts/quickstart)，然后带着生成的所有值返回并添加到 `.env` 文件中
</Callout>

#### 步骤 3 - 将 Drizzle ORM 连接到数据库
Drizzle 原生支持所有 @libsql/client 驱动程序变体：

<LibsqlTable />
<br/>
<LibsqlTabs />

在 `src` 目录创建一个 `index.ts` 文件并初始化连接：

```typescript copy
import 'dotenv/config';
import { drizzle } from 'drizzle-orm/libsql';

// 你可以指定 libsql 连接选项中的任何属性
const db = drizzle({ 
  connection: { 
    url: process.env.TURSO_DATABASE_URL!, 
    authToken: process.env.TURSO_AUTH_TOKEN!
  }
});
```

如果您需要提供您现有的驱动程序：
```typescript copy
import 'dotenv/config';
import { drizzle } from 'drizzle-orm/libsql';
import { createClient } from '@libsql/client';

const client = createClient({ 
  url: process.env.TURSO_DATABASE_URL!, 
  authToken: process.env.TURSO_AUTH_TOKEN!
});
const db = drizzle({ client });
```

#### 步骤 4 - 创建一个表

<CreateTable/>

#### 步骤 5 - 设置 Drizzle 配置文件

**Drizzle 配置** - 由 [Drizzle Kit](/docs/kit-overview) 使用的配置文件，包含有关你的数据库连接、迁移文件夹和模式文件的所有信息。

在项目根目录创建一个 `drizzle.config.ts` 文件，并添加以下内容：

```typescript copy filename="drizzle.config.ts"
import 'dotenv/config';
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
  out: './drizzle',
  schema: './src/db/schema.ts',
  dialect: 'turso',
  dbCredentials: {
    url: process.env.TURSO_DATABASE_URL,
    authToken: process.env.TURSO_AUTH_TOKEN,
  },
});
```

#### 步骤 6 - 将更改应用到数据库

<ApplyChanges />

#### 步骤 7 - 种子和查询数据库

<QueryTurso/>

#### 步骤 8 - 运行 index.ts 文件

<RunFile/>

Source: https://drizzle.zhcndoc.com/docs/get-started/vercel-existing

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import Steps from '@mdx/Steps.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import CodeTabs from "@mdx/CodeTabs.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import IntrospectPostgreSQL from '@mdx/get-started/postgresql/IntrospectPostgreSQL.mdx';
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';
import TransferCode from '@mdx/get-started/TransferCode.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import ConnectVercel from '@mdx/get-started/postgresql/ConnectVercel.mdx'
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import QueryDatabaseUpdated from '@mdx/get-started/QueryDatabaseUpdated.mdx';
import UpdateSchema from '@mdx/get-started/postgresql/UpdateSchema.mdx';

<Breadcrumbs/>

# 在现有项目中开始使用 Drizzle 和 Vercel Postgres

<Prerequisites>
  - **dotenv** - 管理环境变量的包 - [查看这里](https://www.npmjs.com/package/dotenv)
  - **tsx** - 运行 TypeScript 文件的包 - [查看这里](https://tsx.is/)
  - **Vercel Postgres 数据库** - [查看这里](https://vercel.com/docs/storage/vercel-postgres)
  - **Vercel Postgres 驱动** - [查看这里](https://vercel.com/docs/storage/vercel-postgres/sdk) & [GitHub](https://github.com/vercel/storage/tree/main/packages/postgres)
</Prerequisites>

<FileStructure/>

#### 步骤 1 - 安装所需包
<InstallPackages lib='@vercel/postgres'/>

#### 步骤 2 - 设置连接变量

<SetupEnv env_variable='POSTGRES_URL' />

<Callout title='警告'>
务必将变量命名为 `POSTGRES_URL`，以用于 Vercel Postgres。

在 Vercel Postgres 存储标签中，您可以找到 `.env.local` 标签并复制 `POSTGRES_URL` 变量。
</Callout>

#### 步骤 3 - 设置 Drizzle 配置文件

<SetupConfig dialect='postgresql' env_variable='POSTGRES_URL'/>

#### 步骤 4 - 反向工程您的数据库

<IntrospectPostgreSQL/>

#### 步骤 5 - 将代码转移到您的实际架构文件中

<TransferCode/>

#### 步骤 6 - 将 Drizzle ORM 连接到数据库

<ConnectVercel/>

#### 步骤 7 - 查询数据库

```typescript copy filename="src/index.ts"
import 'dotenv/config';
import { eq } from 'drizzle-orm';
import { drizzle } from 'drizzle-orm/vercel-postgres';
import { usersTable } from './db/schema';

async function main() {
  const db = drizzle();

  const user: typeof usersTable.$inferInsert = {
    name: 'John',
    age: 30,
    email: 'john@example.com',
  };

  await db.insert(usersTable).values(user);
  console.log('新用户已创建！')

  const users = await db.select().from(usersTable);
  console.log('从数据库获取所有用户: ', users)
  /*
  const users: {
    id: number;
    name: string;
    age: number;
    email: string;
  }[]
  */

  await db
    .update(usersTable)
    .set({
      age: 31,
    })
    .where(eq(usersTable.email, user.email));
  console.log('用户信息已更新！')

  await db.delete(usersTable).where(eq(usersTable.email, user.email));
  console.log('用户已删除！')
}

main();
```

#### 步骤 8 - 运行 index.ts 文件

<RunFile/>

#### 步骤 9 - 更新您的表架构（可选）

<UpdateSchema/>

#### 步骤 10 - 将更改应用到数据库（可选）

<ApplyChanges />

#### 步骤 11 - 使用新字段查询数据库（可选）

```typescript copy filename="src/index.ts"
import 'dotenv/config';
import { eq } from 'drizzle-orm';
import { drizzle } from 'drizzle-orm/vercel-postgres';
import { usersTable } from './db/schema';

async function main() {
  const db = drizzle();

  const user: typeof usersTable.$inferInsert = {
    name: 'John',
    age: 30,
    email: 'john@example.com',
    phone: '123-456-7890',
  };

  await db.insert(usersTable).values(user);
  console.log('新用户已创建！')

  const users = await db.select().from(usersTable);
  console.log('从数据库获取所有用户: ', users)
  /*
  const users: {
    id: number;
    name: string;
    age: number;
    email: string;
    phone: string | null;
  }[]
  */

  await db
    .update(usersTable)
    .set({
      age: 31,
    })
    .where(eq(usersTable.email, user.email));
  console.log('用户信息已更新！')

  await db.delete(usersTable).where(eq(usersTable.email, user.email));
  console.log('用户已删除！')
}

main();
```

Source: https://drizzle.zhcndoc.com/docs/get-started/vercel-new

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import Steps from '@mdx/Steps.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import ConnectVercel from '@mdx/get-started/postgresql/ConnectVercel.mdx'
import CreateTable from '@mdx/get-started/postgresql/CreateTable.mdx'
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';

<Breadcrumbs/>

# 使用 Drizzle 和 Vercel Postgres 开始

<Prerequisites>
  - **dotenv** - 管理环境变量的包 - [阅读这里](https://www.npmjs.com/package/dotenv)
  - **tsx** - 运行 TypeScript 文件的包 - [阅读这里](https://tsx.is/)
  - **Vercel Postgres 数据库** - [阅读这里](https://vercel.com/docs/storage/vercel-postgres)
  - **Vercel Postgres 驱动程序** - [阅读这里](https://vercel.com/docs/storage/vercel-postgres/sdk) & [GitHub](https://github.com/vercel/storage/tree/main/packages/postgres)
</Prerequisites>

<FileStructure/>

#### 第一步 - 安装必需的包
<InstallPackages lib='@vercel/postgres'/>

#### 第二步 - 设置连接变量

<SetupEnv env_variable='POSTGRES_URL' />

<Callout title='警告'>
将变量命名为 `POSTGRES_URL` 对于 Vercel Postgres 很重要。

在 Vercel Postgres 存储选项卡中，您可以找到 `.env.local` 选项卡并复制 `POSTGRES_URL` 变量。
</Callout>

#### 第三步 - 将 Drizzle ORM 连接到数据库

<ConnectVercel/>

#### 第四步 - 创建一个表

<CreateTable />

#### 第五步 - 设置 Drizzle 配置文件

<SetupConfig dialect='postgresql' env_variable='POSTGRES_URL'/>

#### 第六步 - 将更改应用到数据库

<ApplyChanges />

#### 第七步 - 填充并查询数据库

```typescript copy filename="src/index.ts"
import 'dotenv/config';
import { eq } from 'drizzle-orm';
import { drizzle } from 'drizzle-orm/vercel-postgres';
import { usersTable } from './db/schema';

async function main() {
  const db = drizzle();

  const user: typeof usersTable.$inferInsert = {
    name: 'John',
    age: 30,
    email: 'john@example.com',
  };

  await db.insert(usersTable).values(user);
  console.log('新用户已创建！')

  const users = await db.select().from(usersTable);
  console.log('从数据库获取所有用户: ', users)
  /*
  const users: {
    id: number;
    name: string;
    age: number;
    email: string;
  }[]
  */

  await db
    .update(usersTable)
    .set({
      age: 31,
    })
    .where(eq(usersTable.email, user.email));
  console.log('用户信息已更新！')

  await db.delete(usersTable).where(eq(usersTable.email, user.email));
  console.log('用户已删除！')
}

main();
```

#### 第八步 - 运行 index.ts 文件

<RunFile/>

Source: https://drizzle.zhcndoc.com/docs/get-started/xata-existing

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import Steps from '@mdx/Steps.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import CodeTabs from "@mdx/CodeTabs.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import IntrospectPostgreSQL from '@mdx/get-started/postgresql/IntrospectPostgreSQL.mdx';
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';
import TransferCode from '@mdx/get-started/TransferCode.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import ConnectXata from '@mdx/get-started/postgresql/ConnectXata.mdx'
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import QueryDatabaseUpdated from '@mdx/get-started/QueryDatabaseUpdated.mdx';
import UpdateSchema from '@mdx/get-started/postgresql/UpdateSchema.mdx';

<Breadcrumbs/>

# 在现有项目中开始使用 Drizzle 和 Xata

<Prerequisites>
  - **dotenv** - 管理环境变量的包 - [查看这里](https://www.npmjs.com/package/dotenv)
  - **tsx** - 运行 TypeScript 文件的包 - [查看这里](https://tsx.is/)
  - **Xata Postgres 数据库** - [查看这里](https://xata.io/documentation)
</Prerequisites>

<FileStructure/>

#### 第 1 步 - 安装 **postgres** 包
<InstallPackages lib='postgres'/>

#### 第 2 步 - 设置连接变量

<SetupEnv env_variable='DATABASE_URL' />

你可以通过参考 [Xata 文档](https://xata.io/documentation/getting-started) 来获取连接字符串。

#### 第 3 步 - 设置 Drizzle 配置文件

<SetupConfig dialect='postgresql' env_variable='DATABASE_URL'/>

#### 第 4 步 - 检查你的数据库

<IntrospectPostgreSQL/>

#### 第 5 步 - 将代码迁移到实际的架构文件

<TransferCode/>

#### 第 6 步 - 将 Drizzle ORM 连接到数据库

<ConnectXata/>

#### 第 7 步 - 查询数据库

<QueryDatabase dialect='postgres-js' env_variable='DATABASE_URL'/>

#### 第 8 步 - 运行 index.ts 文件

<RunFile/>

#### 第 9 步 - 更新你的表架构（可选）

<UpdateSchema/>

#### 第 10 步 - 将更改应用到数据库（可选）

<ApplyChanges />

#### 第 11 步 - 使用新字段查询数据库（可选）

<QueryDatabaseUpdated dialect='postgres-js' env_variable='DATABASE_URL' />

Source: https://drizzle.zhcndoc.com/docs/get-started/xata-new

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from "@mdx/Npm.astro";
import Callout from '@mdx/Callout.astro';
import Steps from '@mdx/Steps.astro';
import AnchorCards from '@mdx/AnchorCards.astro';
import Breadcrumbs from '@mdx/Breadcrumbs.astro';
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import FileStructure from '@mdx/get-started/FileStructure.mdx';
import InstallPackages from '@mdx/get-started/InstallPackages.mdx';
import ConnectXata from '@mdx/get-started/postgresql/ConnectXata.mdx'
import CreateTable from '@mdx/get-started/postgresql/CreateTable.mdx'
import SetupConfig from '@mdx/get-started/SetupConfig.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';
import QueryDatabase from '@mdx/get-started/QueryDatabase.mdx';
import SetupEnv from '@mdx/get-started/SetupEnv.mdx';

<Breadcrumbs/>

# 开始使用 Drizzle 和 Xata

<Prerequisites>
  - **dotenv** - 管理环境变量的包 - [阅读这里](https://www.npmjs.com/package/dotenv)
  - **tsx** - 运行 TypeScript 文件的包 - [阅读这里](https://tsx.is/)
  - **Xata Postgres 数据库** - [阅读这里](https://xata.io/documentation)
</Prerequisites>

<FileStructure/>

#### 第一步 - 安装 **postgres** 包
<InstallPackages lib='postgres'/>

#### 第二步 - 设置连接变量

<SetupEnv env_variable='DATABASE_URL' />

你可以通过遵循 [Xata 文档](https://xata.io/documentation/getting-started) 来获取连接字符串。

#### 第三步 - 连接 Drizzle ORM 到数据库

<ConnectXata/>

#### 第四步 - 创建一个表

<CreateTable />

#### 第五步 - 设置 Drizzle 配置文件

<SetupConfig dialect='postgresql' env_variable='DATABASE_URL'/>

#### 第六步 - 应用数据库变更

<ApplyChanges />

#### 第七步 - 填充数据并查询数据库

<QueryDatabase dialect='postgres-js' env_variable='DATABASE_URL'/>

#### 第八步 - 运行 index.ts 文件

<RunFile/>

Source: https://drizzle.zhcndoc.com/docs/goodies


import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Callout from '@mdx/Callout.astro';
import Section from '@mdx/Section.astro';
import CodeTabs from '@mdx/CodeTabs.astro';

## 类型 API
要从你的表架构中检索 `select` 和 `insert` 查询的类型，可以使用我们的类型辅助工具。

<Tabs items={["PostgreSQL", "MySQL", "SQLite", "SingleStore"]}>
<Tab>
```ts
import { serial, text, pgTable } from 'drizzle-orm/pg-core';
import { type InferSelectModel, type InferInsertModel } from 'drizzle-orm'

const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
});

type SelectUser = typeof users.$inferSelect;
type InsertUser = typeof users.$inferInsert;
// 或
type SelectUser = typeof users._.$inferSelect;
type InsertUser = typeof users._.$inferInsert;
// 或
type SelectUser = InferSelectModel<typeof users>;
type InsertUser = InferInsertModel<typeof users>;
```
</Tab>
<Tab>
```ts
import { int, text, mysqlTable } from 'drizzle-orm/mysql-core';
import { type InferSelectModel, type InferInsertModel } from 'drizzle-orm'

const users = mysqlTable('users', {
  id: int('id').primaryKey(),
  name: text('name').notNull(),
});

type SelectUser = typeof users.$inferSelect;
type InsertUser = typeof users.$inferInsert;
// 或
type SelectUser = typeof users._.$inferSelect;
type InsertUser = typeof users._.$inferInsert;
// 或
type SelectUser = InferSelectModel<typeof users>;
type InsertUser = InferInsertModel<typeof users>;
```
</Tab>
<Tab>
```ts
import { int, text, sqliteTable } from 'drizzle-orm/sqlite-core';
import { type InferSelectModel, type InferInsertModel } from 'drizzle-orm'

const users = sqliteTable('users', {
  id: int('id').primaryKey(),
  name: text('name').notNull(),
});

type SelectUser = typeof users.$inferSelect;
type InsertUser = typeof users.$inferInsert;
// 或
type SelectUser = typeof users._.$inferSelect;
type InsertUser = typeof users._.$inferInsert;
// 或
type SelectUser = InferSelectModel<typeof users>;
type InsertUser = InferInsertModel<typeof users>;
```
</Tab>
<Tab>
```ts
import { int, text, singlestoreTable } from 'drizzle-orm/singlestore-core';
import { type InferSelectModel, type InferInsertModel } from 'drizzle-orm'

const users = singlestoreTable('users', {
  id: int('id').primaryKey(),
  name: text('name').notNull(),
});

type SelectUser = typeof users.$inferSelect;
type InsertUser = typeof users.$inferInsert;
// 或
type SelectUser = typeof users._.$inferSelect;
type InsertUser = typeof users._.$inferInsert;
// 或
type SelectUser = InferSelectModel<typeof users>;
type InsertUser = InferInsertModel<typeof users>;
```
</Tab>
<Tab>
```ts
import { int, text, singlestoreTable } from 'drizzle-orm/singlestore-core';
import { type InferSelectModel, type InferInsertModel } from 'drizzle-orm'

const users = singlestoreTable('users', {
  id: int('id').primaryKey(),
  name: text('name').notNull(),
});

type SelectUser = typeof users.$inferSelect;
type InsertUser = typeof users.$inferInsert;
// 或
type SelectUser = typeof users._.$inferSelect;
type InsertUser = typeof users._.$inferInsert;
// 或
type SelectUser = InferSelectModel<typeof users>;
type InsertUser = InferInsertModel<typeof users>;
```
</Tab>
</Tabs>


## 日志记录
要启用默认的查询日志记录，只需将 `{ logger: true }` 传递给 `drizzle` 初始化函数：
```typescript copy
import { drizzle } from 'drizzle-orm/...'; // 驱动特定的

const db = drizzle({ logger: true });
```

你可以通过创建一个 `DefaultLogger` 实例并提供自定义的 `writer` 来更改日志的目的地：
```typescript copy
import { DefaultLogger, LogWriter } from 'drizzle-orm/logger';
import { drizzle } from 'drizzle-orm/...'; // 驱动特定的

class MyLogWriter implements LogWriter {
  write(message: string) {
    // 写入文件、标准输出等。
  }
}

const logger = new DefaultLogger({ writer: new MyLogWriter() });
const db = drizzle({ logger });
```

你还可以创建一个自定义的日志记录器：
```typescript copy
import { Logger } from 'drizzle-orm/logger';
import { drizzle } from 'drizzle-orm/...'; // 驱动特定的

class MyLogger implements Logger {
  logQuery(query: string, params: unknown[]): void {
    console.log({ query, params });
  }
}

const db = drizzle({ logger: new MyLogger() });
```


## 多项目架构
**表创建者** API 让你定义自定义表名。  
当你需要将不同项目的架构保存在同一个数据库中时，它非常有用。

<CodeTabs items={["PostgreSQL","MySQL","SQLite", "SingleStore"]}>
```ts {3}
import { serial, text, pgTableCreator } from 'drizzle-orm/pg-core';

const pgTable = pgTableCreator((name) => `project1_${name}`);

const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
});
```
```ts {3}
import { int, text, mysqlTableCreator } from 'drizzle-orm/mysql-core';

const mysqlTable = mysqlTableCreator((name) => `project1_${name}`);

const users = mysqlTable('users', {
  id: int('id').primaryKey(),
  name: text('name').notNull(),
});
```
```ts {3}
import { int, text, sqliteTableCreator } from 'drizzle-orm/sqlite-core';

const sqliteTable = sqliteTableCreator((name) => `project1_${name}`);

const users = sqliteTable('users', {
  id: int('id').primaryKey(),
  name: text('name').notNull(),
});
```
```ts {3}
import { int, text, singlestoreTableCreator } from 'drizzle-orm/singlestore-core';

const mysqlTable = singlestoreTableCreator((name) => `project1_${name}`);

const users = singlestoreTable('users', {
  id: int('id').primaryKey(),
  name: text('name').notNull(),
});
```
</CodeTabs>
```ts {10}
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  schema: "./src/schema/*",
  out: "./drizzle",
  dialect: "mysql", 
  dbCredentials: {
    url: process.env.DATABASE_URL,
  }
  tablesFilter: ["project1_*"],
});
```

你可以应用多个 `or` 过滤器：
```ts
tablesFilter: ["project1_*", "project2_*"]
```


## 打印 SQL 查询
你可以通过 `db` 实例或使用 **[`独立查询构建器`](#standalone-query-builder)** 打印 SQL 查询。
```typescript copy
const query = db
  .select({ id: users.id, name: users.name })
  .from(users)
  .groupBy(users.id)
  .toSQL();
// 查询：
{
  sql: 'select 'id', 'name' from 'users' group by 'users'.'id'',
  params: [],
}
```

## 原始 SQL 查询执行
如果你有一些复杂的查询需要执行，而 `drizzle-orm` 目前无法处理，
你可以使用 `db.execute` 方法执行原始的 `parametrized` 查询。

<Tabs items={['PostgreSQL', 'MySQL', 'SQLite', 'SingleStore']}>
    <Tab>
    ```ts
    const statement = sql`select * from ${users} where ${users.id} = ${userId}`;
    const res: postgres.RowList<Record<string, unknown>[]> = await db.execute(statement)
    ```
    </Tab>
    <Tab>
    ```typescript copy
    import { ..., MySqlQueryResult } from "drizzle-orm/mysql2";

    const statement = sql`select * from ${users} where ${users.id} = ${userId}`;
    const res: MySqlRawQueryResult = await db.execute(statement);
    ```
    </Tab>
    <Tab>
    ```ts
    const statement = sql`select * from ${users} where ${users.id} = ${userId}`;

    const res: unknown[] = db.all(statement)
    const res: unknown = db.get(statement)
    const res: unknown[][] = db.values(statement)
    const res: Database.RunResult = db.run(statement)
    ```
    </Tab>
    <Tab>
    ```typescript copy
    import { ..., SingleStoreQueryResult } from "drizzle-orm/singlestore";

    const statement = sql`select * from ${users} where ${users.id} = ${userId}`;
    const res: SingleStoreRawQueryResult = await db.execute(statement);
    ```
    </Tab>
</Tabs>


## 独立查询构建器
Drizzle ORM 提供了一个独立的查询构建器，
允许你在不创建数据库实例的情况下构建查询并获取生成的 SQL。
<Tabs items={['PostgreSQL', 'MySQL', 'SQLite', "SingleStore"]}>
    <Tab>
        ```typescript copy
        import { QueryBuilder } from 'drizzle-orm/pg-core';

        const qb = new QueryBuilder();

        const query = qb.select().from(users).where(eq(users.name, 'Dan'));
        const { sql, params } = query.toSQL();
        ```
    </Tab>
    <Tab>
        ```typescript copy
        import { QueryBuilder } from 'drizzle-orm/mysql-core';

        const qb = new QueryBuilder();

        const query = qb.select().from(users).where(eq(users.name, 'Dan'));
        const { sql, params } = query.toSQL();
        ```
    </Tab>
    <Tab>
        ```typescript copy
        import { QueryBuilder } from 'drizzle-orm/sqlite-core';

        const qb = new QueryBuilder();

        const query = qb.select().from(users).where(eq(users.name, 'Dan'));
        const { sql, params } = query.toSQL();
        ```
    </Tab>
    <Tab>
        ```typescript copy
        import { QueryBuilder } from 'drizzle-orm/singlestore-core';

        const qb = new QueryBuilder();

        const query = qb.select().from(users).where(eq(users.name, 'Dan'));
        const { sql, params } = query.toSQL();
        ```
    </Tab>
</Tabs>

## 获取类型化表字段
你可以获取一个类型化的表字段映射，
当你需要在选择时省略某些字段时非常有用。

<Tabs items={['PostgreSQL', 'MySQL', 'SQLite', "SingleStore"]}>
  <Tab>
      <CodeTabs items={["index.ts", "schema.ts"]}>
        ```ts
        import { getTableColumns } from "drizzle-orm";
        import { user } from "./schema";

        const { password, role, ...rest } = getTableColumns(user);

        await db.select({ ...rest }).from(users);
        ```
        ```ts
        import { serial, text, pgTable } from "drizzle-orm/pg-core";

        export const user = pgTable("user", {
          id: serial("id").primaryKey(),
          name: text("name"),
          email: text("email"),
          password: text("password"),
          role: text("role").$type<"admin" | "customer">(),
        });
        ```
      </CodeTabs>
  </Tab>
  <Tab>
      <CodeTabs items={["index.ts", "schema.ts"]}>
        ```ts
        import { getTableColumns } from "drizzle-orm";
        import { user } from "./schema";

        const { password, role, ...rest } = getTableColumns(user);

        await db.select({ ...rest }).from(users);
        ```
        ```ts
        import { int, text, mysqlTable } from "drizzle-orm/mysql-core";

        export const user = mysqlTable("user", {
          id: int("id").primaryKey().autoincrement(),
          name: text("name"),
          email: text("email"),
          password: text("password"),
          role: text("role").$type<"admin" | "customer">(),
        });
        ```
      </CodeTabs>
  </Tab>
  <Tab>
      <CodeTabs items={["index.ts", "schema.ts"]}>
        ```ts
        import { getTableColumns } from "drizzle-orm";
        import { user } from "./schema";

        const { password, role, ...rest } = getTableColumns(user);

        await db.select({ ...rest }).from(users);
        ```
        ```ts
        import { integer, text, sqliteTable } from "drizzle-orm/sqlite-core";

        export const user = sqliteTable("user", {
          id: integer("id").primaryKey({ autoIncrement: true }),
          name: text("name"),
          email: text("email"),
          password: text("password"),
          role: text("role").$type<"admin" | "customer">(),
        });
        ```
      </CodeTabs>
  </Tab>
  <Tab>
      <CodeTabs items={["index.ts", "schema.ts"]}>
        ```ts
        import { getTableColumns } from "drizzle-orm";
        import { user } from "./schema";

        const { password, role, ...rest } = getTableColumns(user);

        await db.select({ ...rest }).from(users);
        ```
        ```ts
        import { int, text, mysqlTable } from "drizzle-orm/singlestore-core";

        export const user = singlestoreTable("user", {
          id: int("id").primaryKey().autoincrement(),
          name: text("name"),
          email: text("email"),
          password: text("password"),
          role: text("role").$type<"admin" | "customer">(),
        });
        ```
      </CodeTabs>
  </Tab>
</Tabs>

## 获取表信息
<Tabs items={['PostgreSQL', 'MySQL', 'SQLite', "SingleStore"]}>
  <Tab>
    ```ts copy
    import { getTableConfig, pgTable } from 'drizzle-orm/pg-core';

    export const table = pgTable(...);

    const {
      columns,
      indexes,
      foreignKeys,
      checks,
      primaryKeys,
      name,
      schema,
    } = getTableConfig(table);
    ```
  </Tab>
  <Tab>
  ```ts copy
  import { getTableConfig, mysqlTable } from 'drizzle-orm/mysql-core';

  export const table = mysqlTable(...);

  const {
    columns,
    indexes,
    foreignKeys,
    checks,
    primaryKeys,
    name,
    schema,
  } = getTableConfig(table);
  ```
  </Tab>
  <Tab>
  ```ts copy
  import { getTableConfig, sqliteTable } from 'drizzle-orm/sqlite-core';

  export const table = sqliteTable(...);

  const {
    columns,
    indexes,
    foreignKeys,
    checks,
    primaryKeys,
    name,
    schema,
  } = getTableConfig(table);
  ```
  </Tab>
  <Tab>
  ```ts copy
  import { getTableConfig, mysqlTable } from 'drizzle-orm/singlestore-core';

  export const table = singlestoreTable(...);

  const {
    columns,
    indexes,
    checks,
    primaryKeys,
    name,
    schema,
  } = getTableConfig(table);
  ```
  </Tab>
</Tabs>

## 比较对象类型（`instanceof` 的替代方案）

你可以使用 `is()` 函数检查一个对象是否为特定的 Drizzle 类型。 
你可以与 Drizzle 中的任何可用类型一起使用。

<Callout type="warning" emoji="⭐️">
  你应该始终使用 `is()` 而不是 `instanceof`
</Callout>

**几个例子**
```ts
import { Column, is } from 'drizzle-orm';

if (is(value, Column)) {
  // value 的类型被缩小为 Column
}
```

### 模拟驱动程序
该 API 是一个继承于未定义的 `drizzle({} as any)` API 的后续版本，我们在 Drizzle 测试中内部使用过，并很少推荐给外部开发者。

我们决定构建并公开一个适当的 API，现在每个 `drizzle` 驱动程序都有 `drizzle.mock()`：
```ts
import { drizzle } from "drizzle-orm/node-postgres";

const db = drizzle.mock();
```

如果需要，您可以提供类型的架构。
```ts
import { drizzle } from "drizzle-orm/node-postgres";
import * as schema from "./schema"

const db = drizzle.mock({ schema });
```

Source: https://drizzle.zhcndoc.com/docs/gotchas

import CodeTab from "@mdx/CodeTab.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import Section from "@mdx/Section.astro";
import Tab from "@mdx/Tab.astro";
import Tabs from "@mdx/Tabs.astro";
import Callout from "@mdx/Callout.astro";

# Drizzle 注意事项

这将是一个关于 Drizzle 使用案例中的 `注意事项` 库

Source: https://drizzle.zhcndoc.com/docs/graphql

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Callout from '@mdx/Callout.astro';
import CodeTab from '@mdx/CodeTab.astro';
import CodeTabs from '@mdx/CodeTabs.astro';
import Npm from '@mdx/Npm.astro';

# drizzle-graphql

通过一行代码从 Drizzle 模式创建 GraphQL 服务器，并轻松增强自定义查询和变更。

## 快速开始

确保你的 `drizzle-orm` 版本至少为 `0.30.9`，如有需要请更新：
<Npm>drizzle-orm@latest</Npm>

### Apollo 服务器

<Npm>drizzle-graphql @apollo/server graphql</Npm>

<CodeTabs items={['server.ts', 'schema.ts']}>
<CodeTab>
```ts copy {1, 10}
import { buildSchema } from 'drizzle-graphql';
import { drizzle } from 'drizzle-orm/...';
import client from './db';
import { ApolloServer } from '@apollo/server';
import { startStandaloneServer } from '@apollo/server/standalone';

import * as dbSchema from './schema';

const db = drizzle({ client, schema: dbSchema });

const { schema } = buildSchema(db);

const server = new ApolloServer({ schema });
const { url } = await startStandaloneServer(server);

console.log(`🚀 服务器已准备好，地址为 ${url}`);
```
</CodeTab>
<CodeTab>
```typescript copy
import { integer, serial, text, pgTable } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';

export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
});

export const usersRelations = relations(users, ({ many }) => ({
  posts: many(posts),
}));

export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  content: text('content').notNull(),
  authorId: integer('author_id').notNull(),
});

export const postsRelations = relations(posts, ({ one }) => ({
  author: one(users, { fields: [posts.authorId], references: [users.id] }),
}));
```
</CodeTab>
</CodeTabs>

### GraphQL Yoga

<Npm>drizzle-graphql graphql-yoga graphql</Npm>

<CodeTabs items={['server.ts', 'schema.ts']}>
<CodeTab>
```ts copy {1, 10}
import { buildSchema } from 'drizzle-graphql';
import { drizzle } from 'drizzle-orm/...';
import { createYoga } from 'graphql-yoga';
import { createServer } from 'node:http';

import * as dbSchema from './schema';

const db = drizzle({ schema: dbSchema });

const { schema } = buildSchema(db);

const yoga = createYoga({ schema });
const server = createServer(yoga);

server.listen(4000, () => {
  console.info('服务器正在运行在 http://localhost:4000/graphql');
});
```
</CodeTab>
<CodeTab>
```typescript copy
import { integer, serial, text, pgTable } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';

export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
});

export const usersRelations = relations(users, ({ many }) => ({
  posts: many(posts),
}));

export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  content: text('content').notNull(),
  authorId: integer('author_id').notNull(),
});

export const postsRelations = relations(posts, ({ one }) => ({
  author: one(users, { fields: [posts.authorId], references: [users.id] }),
}));
```
</CodeTab>
</CodeTabs>

## 自定义模式

<Callout type='info' emoji='ℹ️'>
`buildSchema()` 使用标准的 `graphql` SDK 生成模式和类型，因此其输出与任何支持该输出的库兼容。
</Callout>

如果你想自定义你的模式，可以使用 `entities` 对象来构建你自己的新模式：

<CodeTabs items={['server.ts', 'schema.ts']}>
<CodeTab>
```ts {1, 11}
import { buildSchema } from 'drizzle-graphql';
import { drizzle } from 'drizzle-orm/...';
import { GraphQLList, GraphQLNonNull, GraphQLObjectType, GraphQLSchema } from 'graphql';
import { createYoga } from 'graphql-yoga';
import { createServer } from 'node:http';

import * as dbSchema from './schema';

const db = drizzle({ schema: dbSchema });

const { entities } = buildSchema(db);

// 你可以自定义查询或变更的部分
const schema = new GraphQLSchema({
  query: new GraphQLObjectType({
    name: 'Query',
    fields: {
      // 从所有生成的查询中选择所需的查询
      users: entities.queries.users,
      customer: entities.queries.customersSingle,

      // 创建一个自定义查询
      customUsers: {
        // 你可以重新使用并自定义来自原始模式的类型
        type: new GraphQLList(new GraphQLNonNull(entities.types.UsersItem)),
        args: {
          // 你也可以重新使用输入
          where: {
            type: entities.inputs.UsersFilters
          },
        },
        resolve: async (source, args, context, info) => {
          // 你的自定义逻辑在这里...
          const result = await db.select(schema.users).where()...

          return result;
        },
      },
    },
  }),
  // 相同的规则适用于变更
  mutation: new GraphQLObjectType({
    name: 'Mutation',
    fields: entities.mutations,
  }),
  // 如果你需要类型在你的模式内
  types: [...Object.values(entities.types), ...Object.values(entities.inputs)],
});

const yoga = createYoga({
  schema,
});

const server = createServer(yoga);

server.listen(4000, () => {
  console.info('服务器正在运行在 http://localhost:4000/graphql');
})
```
</CodeTab>
<CodeTab>
```typescript copy
import { integer, serial, text, pgTable } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';

export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
});

export const usersRelations = relations(users, ({ many }) => ({
  posts: many(posts),
}));

export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  content: text('content').notNull(),
  authorId: integer('author_id').notNull(),
});

export const postsRelations = relations(posts, ({ one }) => ({
  author: one(users, { fields: [posts.authorId], references: [users.id] }),
}));
```
</CodeTab>
</CodeTabs>


Source: https://drizzle.zhcndoc.com/docs/guides

import Guides from "@components/Guides.astro";

<Guides/>

Source: https://drizzle.zhcndoc.com/docs/conditional-filters-in-query

import Section from "@mdx/Section.astro";
import IsSupportedChipGroup from "@mdx/IsSupportedChipGroup.astro";
import Prerequisites from "@mdx/Prerequisites.astro";

<IsSupportedChipGroup chips={{PostgreSQL: true, MySQL: true, SQLite: true}}/>

<Prerequisites>
- 开始使用 [PostgreSQL](/docs/get-started-postgresql), [MySQL](/docs/get-started-mysql) 和 [SQLite](/docs/get-started-sqlite);
- [选择语句](/docs/select);
- [过滤](/docs/select#filtering) 和 [过滤操作符](/docs/operators);
</Prerequisites>

要在查询中传递条件过滤器，可以使用 `.where()` 方法和逻辑运算符，如下所示：

<Section>
```ts copy {9}
import { ilike } from 'drizzle-orm';

const db = drizzle(...)

const searchPosts = async (term?: string) => {
  await db
    .select()
    .from(posts)
    .where(term ? ilike(posts.title, term) : undefined);
};

await searchPosts();
await searchPosts('AI');
```


```sql
select * from posts;
select * from posts where title ilike 'AI';
```
</Section>

要组合条件过滤器，可以使用 `and()` 或 `or()` 运算符，如下所示：

<Section>
```ts copy {7,8,9,10,11,12,13}
import { and, gt, ilike, inArray } from 'drizzle-orm';

const searchPosts = async (term?: string, categories: string[] = [], views = 0) => {
  await db
    .select()
    .from(posts)
    .where(
      and(
        term ? ilike(posts.title, term) : undefined,
        categories.length > 0 ? inArray(posts.category, categories) : undefined,
        views > 100 ? gt(posts.views, views) : undefined,
      ),
    );
};

await searchPosts();
await searchPosts('AI', ['Tech', 'Art', 'Science'], 200);
```

```sql
select * from posts;
select * from posts
  where (
    title ilike 'AI'
    and category in ('Tech', 'Science', 'Art')
    and views > 200
  );
```
</Section>

如果你需要在项目的不同地方组合条件过滤器，可以创建一个变量，推入过滤器，然后在 `.where()` 方法中使用 `and()` 或 `or()` 运算符，如下所示：

```ts copy {7,10}
import { SQL, ... } from 'drizzle-orm';

const searchPosts = async (filters: SQL[]) => {
  await db
    .select()
    .from(posts)
    .where(and(...filters));
};

const filters: SQL[] = [];
filters.push(ilike(posts.title, 'AI'));
filters.push(inArray(posts.category, ['Tech', 'Art', 'Science']));
filters.push(gt(posts.views, 200));

await searchPosts(filters);
```

Drizzle 具有有用且灵活的 API，可以让你创建自定义解决方案。以下是你可以创建自定义过滤器操作符的方法：

<Section>

```ts copy {5,14}
import { AnyColumn, ... } from 'drizzle-orm';

// 长度小于
const lenlt = (column: AnyColumn, value: number) => {
  return sql`length(${column}) < ${value}`;
};

const searchPosts = async (maxLen = 0, views = 0) => {
  await db
    .select()
    .from(posts)
    .where(
      and(
        maxLen ? lenlt(posts.title, maxLen) : undefined,
        views > 100 ? gt(posts.views, views) : undefined,
      ),
    );
};

await searchPosts(8);
await searchPosts(8, 200);
```

```sql
select * from posts where length(title) < 8;
select * from posts where (length(title) < 8 and views > 200);
```
</Section>

Drizzle 的过滤器操作符在底层只是 SQL 表达式。这是 `lt` 操作符在 Drizzle 中实现的示例：

```js
const lt = (left, right) => {
  return sql`${left} < ${bindIfParam(right, left)}`; // bindIfParam 是内部魔法函数
};
```


Source: https://drizzle.zhcndoc.com/docs/count-rows

import Section from "@mdx/Section.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import IsSupportedChipGroup from "@mdx/IsSupportedChipGroup.astro";
import CodeTabs from '@mdx/CodeTabs.astro';
import CodeTab from '@mdx/CodeTab.astro';
import Callout from '@mdx/Callout.astro';

<IsSupportedChipGroup chips={{PostgreSQL: true, MySQL: true, SQLite: true}}/>

<Prerequisites>
- 开始使用 [PostgreSQL](/docs/get-started-postgresql)、[MySQL](/docs/get-started-mysql) 和 [SQLite](/docs/get-started-sqlite)
- [选择语句](/docs/select)
- [筛选器](/docs/operators) 和 [SQL 操作符](/docs/sql)
- [聚合](/docs/select#aggregations) 和 [聚合助手](/docs/select#aggregations-helpers)
- [连接](/docs/joins)
</Prerequisites>

要统计表中的所有行，可以使用 `count()` 函数或 `sql` 操作符，如下所示：

<CodeTabs items={["index.ts", "schema.ts"]}>
  <CodeTab>
    ```ts copy {6,9}
    import { count, sql } from 'drizzle-orm';
    import { products } from './schema';

    const db = drizzle(...);

    await db.select({ count: count() }).from(products);

    // 在底层，count() 函数会在运行时将其结果转换为数字。
    await db.select({ count: sql`count(*)`.mapWith(Number) }).from(products);
    ```

    ```ts
    // 结果类型
    type Result = {
      count: number;
    }[];
    ```

    ```sql
    select count(*) from products;
    ```
  </CodeTab>
  ```ts
  import { integer, pgTable, serial, text } from 'drizzle-orm/pg-core';

  export const products = pgTable('products', {
    id: serial('id').primaryKey(),
    name: text('name').notNull(),
    discount: integer('discount'),
    price: integer('price').notNull(),
  });
  ```
</CodeTabs>

要统计指定列包含非 NULL 值的行，可以使用带有列的 `count()` 函数：

<Section>
```ts copy {1}
await db.select({ count: count(products.discount) }).from(products);
```

```ts
// 结果类型
type Result = {
  count: number;
}[];
```

```sql
select count("discount") from products;
```
</Section>

Drizzle 拥有简单灵活的 API，可以让您创建自定义解决方案。在 PostgreSQL 和 MySQL 中，`count()` 函数返回 bigint，该值由其驱动程序解释为字符串，因此应转换为整数：

<Section>
```ts copy {5,7,11,12}
import { AnyColumn, sql } from 'drizzle-orm';

const customCount = (column?: AnyColumn) => {
  if (column) {
    return sql<number>`cast(count(${column}) as integer)`; // 在 MySQL 中转换为无符号整数
  } else {
    return sql<number>`cast(count(*) as integer)`; // 在 MySQL 中转换为无符号整数
  }
};

await db.select({ count: customCount() }).from(products);
await db.select({ count: customCount(products.discount) }).from(products);
```

```sql
select cast(count(*) as integer) from products;
select cast(count("discount") as integer) from products;
```
</Section>

在 SQLite 中，`count()` 的结果作为整数返回。

<Section>
```ts copy {3,4}
import { sql } from 'drizzle-orm';

await db.select({ count: sql<number>`count(*)` }).from(products);
await db.select({ count: sql<number>`count(${products.discount})` }).from(products);
```

```sql
select count(*) from products;
select count("discount") from products;
```
</Section>

<Callout type="warning">
通过指定 `sql<number>`，您告诉 Drizzle 字段的 **预期** 类型是 `number`。<br />
如果您指定错误（例如，对将以数字返回的字段使用 `sql<string>`），运行时值将不匹配预期类型。
Drizzle 不能根据提供的类型泛型执行任何类型转换，因为该信息在运行时不可用。

如果您需要对返回值应用运行时转换，可以使用 [`.mapWith()`](/docs/sql#sqlmapwith) 方法。
</Callout>

要统计匹配条件的行，可以使用 `.where()` 方法：

<Section>
```ts copy {4,6}
import { count, gt } from 'drizzle-orm';

await db
  .select({ count: count() })
  .from(products)
  .where(gt(products.price, 100));
```

```sql
select count(*) from products where price > 100
```
</Section>

以下是如何使用 `count()` 函数结合连接和聚合：

<CodeTabs items={["index.ts", "schema.ts"]}>
	<CodeTab>
    ```ts copy {8,11,12,13}
    import { count, eq } from 'drizzle-orm';
    import { countries, cities } from './schema';

    // 统计每个国家的城市数量
    await db
      .select({
        country: countries.name,
        citiesCount: count(cities.id),
      })
      .from(countries)
      .leftJoin(cities, eq(countries.id, cities.countryId))
      .groupBy(countries.id)
      .orderBy(countries.name);
    ```

    ```sql
    select countries.name, count("cities"."id") from countries
      left join cities on countries.id = cities.country_id
      group by countries.id
      order by countries.name;
    ```
  </CodeTab>
  ```ts
  import { integer, pgTable, serial, text } from 'drizzle-orm/pg-core';

  export const countries = pgTable('countries', {
    id: serial('id').primaryKey(),
    name: text('name').notNull(),
  });

  export const cities = pgTable('cities', {
    id: serial('id').primaryKey(),
    name: text('name').notNull(),
    countryId: integer('country_id').notNull().references(() => countries.id),
  });
  ```
</CodeTabs>


Source: https://drizzle.zhcndoc.com/docs/cursor-based-pagination


import CodeTabs from '@mdx/CodeTabs.astro';
import CodeTab from '@mdx/CodeTab.astro';
import IsSupportedChipGroup from "@mdx/IsSupportedChipGroup.astro";
import Section from "@mdx/Section.astro";
import Prerequisites from "@mdx/Prerequisites.astro";

<IsSupportedChipGroup chips={{PostgreSQL: true, MySQL: true, SQLite: true}}/>

<Prerequisites>
- 了解如何使用 [PostgreSQL](/docs/get-started-postgresql)、[MySQL](/docs/get-started-mysql) 和 [SQLite](/docs/get-started-sqlite) 
- 使用 [order by 子句](/docs/select#order-by) 的 [选择语句](/docs/select)
- 使用 [order by 子句](/docs/rqb#order-by) 的 [关系查询](/docs/rqb)
- [索引](/docs/indexes-constraints)
</Prerequisites>

本指南演示如何在 Drizzle 中实现 `基于游标` 的分页：

<CodeTabs items={["index.ts", "schema.ts"]}>
  <CodeTab>
  ```ts copy {10,11,12}
  import { asc, gt } from 'drizzle-orm';
  import { users } from './schema';

  const db = drizzle(...);

  const nextUserPage = async (cursor?: number, pageSize = 3) => {
    await db
      .select()
      .from(users)
      .where(cursor ? gt(users.id, cursor) : undefined) // 如果提供了游标，则获取其后的行
      .limit(pageSize) // 返回的行数
      .orderBy(asc(users.id)); // 排序
  };

  // 传递前一页最后一行的游标 (id)
  await nextUserPage(3);
  ```

  ```sql
  select * from users order by id asc limit 3;
  ```

  ```ts
  // 下一页，返回第 4-6 行
  [
    {
      id: 4,
      firstName: 'Brian',
      lastName: 'Brown',
      createdAt: 2024-03-08T12:34:55.182Z
    },
    {
      id: 5,
      firstName: 'Beth',
      lastName: 'Davis',
      createdAt: 2024-03-08T12:40:55.182Z
    },
    {
      id: 6,
      firstName: 'Charlie',
      lastName: 'Miller',
      createdAt: 2024-03-08T13:04:55.182Z
    }
  ]
  ```
  </CodeTab>
  <CodeTab>
  ```ts copy
  import { pgTable, serial, text, timestamp } from 'drizzle-orm/pg-core';

  export const users = pgTable('users', {
    id: serial('id').primaryKey(),
    firstName: text('first_name').notNull(),
    lastName: text('last_name').notNull(),
    createdAt: timestamp('created_at').notNull().defaultNow(),
  });
  ```

  ```plaintext
  +----+------------+------------+----------------------------+
  | id | first_name | last_name  |         created_at         |
  +----+------------+------------+----------------------------+
  |  1 | Alice      | Johnson    | 2024-03-08 12:23:55.251797 |
  +----+------------+------------+----------------------------+
  |  2 | Alex       | Smith      | 2024-03-08 12:25:55.182    |
  +----+------------+------------+----------------------------+
  |  3 | Aaron      | Williams   | 2024-03-08 12:28:55.182    |
  +----+------------+------------+----------------------------+
  |  4 | Brian      | Brown      | 2024-03-08 12:34:55.182    |
  +----+------------+------------+----------------------------+
  |  5 | Beth       | Davis      | 2024-03-08 12:40:55.182    |
  +----+------------+------------+----------------------------+
  |  6 | Charlie    | Miller     | 2024-03-08 13:04:55.182    |
  +----+------------+------------+----------------------------+
  |  7 | Clara      | Wilson     | 2024-03-08 13:22:55.182    |
  +----+------------+------------+----------------------------+
  |  8 | David      | Moore      | 2024-03-08 13:34:55.182    |
  +----+------------+------------+----------------------------+
  |  9 | Aaron      | Anderson   | 2024-03-08 12:40:33.677235 |
  +----+------------+------------+----------------------------+
  ```
  </CodeTab>

</CodeTabs>

如果需要动态排序，可以像下面这样做：

```ts copy {6,8}
const nextUserPage = async (order: 'asc' | 'desc' = 'asc', cursor?: number, pageSize = 3) => {
  await db
    .select()
    .from(users)
    // 游标比较
    .where(cursor ? (order === 'asc' ? gt(users.id, cursor) : lt(users.id, cursor)) : undefined)
    .limit(pageSize)
    .orderBy(order === 'asc' ? asc(users.id) : desc(users.id));
};

await nextUserPage();
await nextUserPage('asc', 3);
// 降序
await nextUserPage('desc');
await nextUserPage('desc', 7);
```

这种分页的主要思想是使用游标作为数据集中某一行的指针，表示上一页的结束。为了确保正确的排序和游标比较，游标应该是唯一的且是顺序的。

如果需要按非唯一且非顺序的列排序，可以使用多个列作为游标。以下是如何做的：

<Section>
```ts copy {14,15,16,17,18,19,22}
import { and, asc, eq, gt, or } from 'drizzle-orm';

const nextUserPage = async (
  cursor?: {
    id: number;
    firstName: string;
  },
  pageSize = 3,
) => {
  await db
    .select()
    .from(users)
    .where(
      cursor
        ? or(
            gt(users.firstName, cursor.firstName),
            and(eq(users.firstName, cursor.firstName), gt(users.id, cursor.id)),
          )
        : undefined,
    )
    .limit(pageSize)
    .orderBy(asc(users.firstName), asc(users.id));
};

// 传递来自前一页的游标 (id & firstName)
await nextUserPage({
  id: 2,
  firstName: 'Alex',
});
```

```sql
select * from users
  where (first_name > 'Alex' or (first_name = 'Alex' and id > 2))
  order by first_name asc, id asc limit 3;
```

```ts
// 下一页，返回第 4-6 行
[
  {
    id: 1,
    firstName: 'Alice',
    lastName: 'Johnson',
    createdAt: 2024-03-08T12:23:55.251Z
  },
  {
    id: 5,
    firstName: 'Beth',
    lastName: 'Davis',
    createdAt: 2024-03-08T12:40:55.182Z
  },
  {
    id: 4,
    firstName: 'Brian',
    lastName: 'Brown',
    createdAt: 2024-03-08T12:34:55.182Z
  }
]
```
</Section>

确保为用于游标的列创建索引，以提高查询效率。

<Section>
```ts copy {7,8}
import { index, ...imports } from 'drizzle-orm/pg-core';

export const users = pgTable('users', {
  // 列声明
},
(t) => [
  index('first_name_index').on(t.firstName).asc(),
  index('first_name_and_id_index').on(t.firstName, t.id).asc(),
]);
```

```sql
-- 目前 drizzle-kit 只支持索引名和 on() 参数，所以您需要手动添加顺序
CREATE INDEX IF NOT EXISTS "first_name_index" ON "users" ("first_name" ASC);
CREATE INDEX IF NOT EXISTS "first_name_and_id_index" ON "users" ("first_name" ASC,"id" ASC);
```
</Section>

如果您使用的是非顺序的主键（例如 `UUIDv4`），您应该添加一个顺序列（例如 `created_at` 列）并使用多个游标。
以下是如何做的：

<Section>
```ts copy {12,13,14,15,16,17,18,21}

const nextUserPage = async (
  cursor?: {
    id: string;
    createdAt: Date;
  },
  pageSize = 3,
) => {
  await db
    .select()
    .from(users)
    .where(
      // 确保为您用于游标的列添加索引
      cursor
        ? or(
            gt(users.createdAt, cursor.createdAt),
            and(eq(users.createdAt, cursor.createdAt), gt(users.id, cursor.id)),
          )
        : undefined,
    )
    .limit(pageSize)
    .orderBy(asc(users.createdAt), asc(users.id));
};

// 传递来自前一页的游标 (id & createdAt)
await nextUserPage({
  id: '66ed00a4-c020-4dfd-a1ca-5d2e4e54d174',
  createdAt: new Date('2024-03-09T17:59:36.406Z'),
});
```
</Section>

Drizzle 具有有用的关系查询 API，使您可以轻松实现 `基于游标` 的分页：

```ts copy {7,8,9}
import * as schema from './db/schema';

const db = drizzle(..., { schema });

const nextUserPage = async (cursor?: number, pageSize = 3) => {
  await db.query.users.findMany({
    where: (users, { gt }) => (cursor ? gt(users.id, cursor) : undefined),
    orderBy: (users, { asc }) => asc(users.id),
    limit: pageSize,
  });
};

// 下一页，前一页最后一行的游标 (id = 3)
await nextUserPage(3);
```

**基于游标的** 分页的 **优点**：一致的查询结果，没有因插入或删除操作导致的跳过或重复的行，并且相比于 `limit/offset` 分页效率更高，因为它不需要扫描和跳过先前的行来访问下一页。

**基于游标的** 分页的 **缺点**：无法直接导航到特定页面，且实现复杂。由于您将更多列添加到排序顺序中，则需要在 `where` 子句中添加更多过滤器以进行游标比较，以确保分页的一致性。

因此，如果您需要直接导航到特定页面或需要更简单的分页实现，您应该考虑使用 [offset/limit](/docs/guides/limit-offset-pagination) 分页。


Source: https://drizzle.zhcndoc.com/docs/d1-http-with-drizzle-kit


import Prerequisites from "@mdx/Prerequisites.astro";

<Prerequisites>
- [Drizzle Kit](/docs/kit-overview)
- [Drizzle Studio](/docs/kit-overview#drizzle-studio)
- [Drizzle Chrome 扩展程序](https://chromewebstore.google.com/detail/drizzle-studio/mjkojjodijpaneehkgmeckeljgkimnmd)
- 您应该已经安装 `drizzle-kit@0.21.3` 或更高版本
- 您应该拥有 [Cloudflare 账号](https://dash.cloudflare.com/login)，已部署 [D1 数据库](https://developers.cloudflare.com/d1/) 并获取具有 D1 编辑权限的令牌
</Prerequisites>

要将 Drizzle Kit 与 Cloudflare D1 HTTP API 一起使用，您需要像这样配置 `drizzle.config.ts` 文件：

```ts copy filename="drizzle.config.ts" {7, 9-11}
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
  schema: './src/schema.ts',
  out: './migrations',
  dialect: 'sqlite',
  driver: 'd1-http',
  dbCredentials: {
    accountId: process.env.CLOUDFLARE_ACCOUNT_ID!,
    databaseId: process.env.CLOUDFLARE_DATABASE_ID!,
    token: process.env.CLOUDFLARE_D1_TOKEN!,
  },
});
```

您可以在 [Cloudflare 仪表盘](https://dash.cloudflare.com/login?) 中找到 `accountId`、`databaseId` 和 `token`。

1. 要获取 `accountId`，请前往 **Workers & Pages** -> **Overview** -> 从右侧边栏复制 **Account ID**。
2. 要获取 `databaseId`，打开您要连接的 D1 数据库并复制 **Database ID**。
3. 要获取 `token`，前往 **My profile** -> **API Tokens** 并创建一个具有 D1 编辑权限的令牌。

配置完 `drizzle.config.ts` 文件后，Drizzle Kit 允许您使用 Cloudflare D1 HTTP API 运行 `migrate`、`push`、`introspect` 和 `studio` 命令。

您还可以使用 [Drizzle Chrome 扩展程序](https://chromewebstore.google.com/detail/drizzle-studio/mjkojjodijpaneehkgmeckeljgkimnmd) 直接在其管理面板中浏览 Cloudflare D1 数据库。




Source: https://drizzle.zhcndoc.com/docs/减少值

import Section from "@mdx/Section.astro";
import IsSupportedChipGroup from "@mdx/IsSupportedChipGroup.astro";
import Prerequisites from "@mdx/Prerequisites.astro";

<IsSupportedChipGroup chips={{PostgreSQL: true, MySQL: true, SQLite: true}}/>

<Prerequisites>
- 开始使用 [PostgreSQL](/docs/get-started-postgresql)，[MySQL](/docs/get-started-mysql) 和 [SQLite](/docs/get-started-sqlite)
- [更新语句](/docs/update)
- [过滤器](/docs/operators) 和 [SQL 操作符](/docs/sql)
</Prerequisites>

要减少列的值，可以使用 `update().set()` 方法，如下所示：

<Section>
```ts copy {8}
import { eq, sql } from 'drizzle-orm';

const db = drizzle(...)
  
await db
  .update(table)
  .set({
    counter: sql`${table.counter} - 1`,
  })
  .where(eq(table.id, 1));
```

```sql
update "table" set "counter" = "counter" - 1 where "id" = 1;
```
</Section>

Drizzle 具有简单灵活的 API，可以让你轻松创建自定义解决方案。以下是如何实现自定义减少函数的方法：

```ts copy {4,10,11}
import { AnyColumn } from 'drizzle-orm';

const decrement = (column: AnyColumn, value = 1) => {
  return sql`${column} - ${value}`;
};

await db
  .update(table)
  .set({
    counter1: decrement(table.counter1),
    counter2: decrement(table.counter2, 10),
  })
  .where(eq(table.id, 1));
```


Source: https://drizzle.zhcndoc.com/docs/empty-array-default-value


import Section from "@mdx/Section.astro";
import Prerequisites from "@mdx/Prerequisites.astro";

<Prerequisites>
- 开始使用 [PostgreSQL](/docs/get-started-postgresql)、[MySQL](/docs/get-started-mysql) 和 [SQLite](/docs/get-started-sqlite)
- 了解 [PostgreSQL](/docs/column-types/pg)、[MySQL](/docs/column-types/mysql) 和 [SQLite](/docs/column-types/sqlite) 的列数据类型
- [sql 操作符](/docs/sql)
</Prerequisites>

### PostgreSQL

要在 PostgreSQL 中将空数组设置为默认值，可以使用 `sql` 操作符和 `'{}'` 或 `ARRAY[]` 语法：

<Section>
```ts copy {10,14}
import { sql } from 'drizzle-orm';
import { pgTable, serial, text } from 'drizzle-orm/pg-core';

export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  tags1: text('tags1')
    .array()
    .notNull()
    .default(sql`'{}'::text[]`),
  tags2: text('tags2')
    .array()
    .notNull()
    .default(sql`ARRAY[]::text[]`),
});
```

```sql
CREATE TABLE IF NOT EXISTS "users" (
	"id" serial PRIMARY KEY NOT NULL,
	"name" text NOT NULL,
	"tags1" text[] DEFAULT '{}'::text[] NOT NULL,
	"tags2" text[] DEFAULT ARRAY[]::text[] NOT NULL
);
```
</Section>


### MySQL

MySQL 没有数组数据类型，但可以使用 `json` 数据类型来达到相同的目的。要在 MySQL 中将空数组设置为默认值，可以使用 `JSON_ARRAY()` 函数或 `sql` 操作符和 `('[]')` 语法：

<Section>
```ts copy {7,11,15}
import { sql } from 'drizzle-orm';
import { json, mysqlTable, serial, varchar } from 'drizzle-orm/mysql-core';

export const users = mysqlTable('users', {
  id: serial('id').primaryKey(),
  name: varchar('name', { length: 255 }).notNull(),
  tags1: json('tags1').$type<string[]>().notNull().default([]),
  tags2: json('tags2')
    .$type<string[]>()
    .notNull()
    .default(sql`('[]')`), // 与 default([]) 相同
  tags3: json('tags3')
    .$type<string[]>()
    .notNull()
    .default(sql`(JSON_ARRAY())`),
});
```

```sql
CREATE TABLE `users` (
	`id` serial AUTO_INCREMENT NOT NULL,
	`name` varchar(255) NOT NULL,
	`tags1` json NOT NULL DEFAULT ('[]'),
	`tags2` json NOT NULL DEFAULT ('[]'),
	`tags3` json NOT NULL DEFAULT (JSON_ARRAY()),
	CONSTRAINT `users_id` PRIMARY KEY(`id`)
);
```
</Section>

`mode` 选项定义了应用中如何处理值。在 `json` 模式下，值被视为 JSON 对象字面量。

您可以为 JSON 对象推断指定 `.$type<..>()`，它不会检查运行时值。它为默认值、插入和选择模式提供了编译时保护。

### SQLite

SQLite 没有数组数据类型，但可以使用 `text` 数据类型来达到相同目的。要在 SQLite 中将空数组设置为默认值，可以使用 `json_array()` 函数或 `sql` 操作符和 `'[]'` 语法：

<Section>
```ts copy {9,13}
import { sql } from 'drizzle-orm';
import { integer, sqliteTable, text } from 'drizzle-orm/sqlite-core';

export const users = sqliteTable('users', {
  id: integer('id').primaryKey(),
  tags1: text('tags1', { mode: 'json' })
    .notNull()
    .$type<string[]>()
    .default(sql`(json_array())`),
  tags2: text('tags2', { mode: 'json' })
    .notNull()
    .$type<string[]>()
    .default(sql`'[]'`),
});
```

```sql
CREATE TABLE `users` (
	`id` integer PRIMARY KEY NOT NULL,
	`tags1` text DEFAULT (json_array()) NOT NULL,
	`tags2` text DEFAULT '[]' NOT NULL
);
```
</Section>

`mode` 选项定义了应用中如何处理值。在 `json` 模式下，值被视为 JSON 对象字面量。

您可以为 JSON 对象推断指定 `.$type<..>()`，它不会检查运行时值。它为默认值、插入和选择模式提供了编译时保护。


Source: https://drizzle.zhcndoc.com/docs/full-text-search-with-generated-columns


import Section from "@mdx/Section.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from '@mdx/CodeTabs.astro';
import CodeTab from '@mdx/CodeTab.astro';

<Prerequisites>
- 开始使用 [PostgreSQL](/docs/get-started-postgresql)
- [选择语句](/docs/select)
- [索引](/docs/indexes-constraints#indexes)
- [sql 操作符](/docs/sql) 
- [全文搜索](/learn/guides/postgresql-full-text-search)
- [生成列](/docs/generated-columns)
</Prerequisites>

本指南演示了如何使用 Drizzle 和生成列在 PostgreSQL 中实现全文搜索。生成列是一个特殊的列，它总是从其他列计算得出。它的好处在于你不必每次查询表时都计算该列的值：

<CodeTabs items={["schema.ts", "migration.sql"]}>
  <CodeTab>
  ```ts copy {18,19,20,23}
import { SQL, sql } from 'drizzle-orm';
import { index, pgTable, serial, text, customType } from 'drizzle-orm/pg-core';

export const tsvector = customType<{
  data: string;
}>({
  dataType() {
    return `tsvector`;
  },
});

export const posts = pgTable(
  'posts',
  {
    id: serial('id').primaryKey(),
    title: text('title').notNull(),
    body: text('body').notNull(),
    bodySearch: tsvector('body_search')
      .notNull()
      .generatedAlwaysAs((): SQL => sql`to_tsvector('english', ${posts.body})`),
  },
  (t) => [
    index('idx_body_search').using('gin', t.bodySearch),
  ]
);
  ```
  </CodeTab>
  ```sql
CREATE TABLE "posts" (
	"id" serial PRIMARY KEY NOT NULL,
	"title" text NOT NULL,
	"body" text NOT NULL,
	"body_search" "tsvector" GENERATED ALWAYS AS (to_tsvector('english', "posts"."body")) STORED NOT NULL
);
--> statement-breakpoint
CREATE INDEX "idx_body_search" ON "posts" USING gin ("body_search");
  ```
</CodeTabs>

当你向表中插入一行时，生成列的值是从创建列时提供的表达式计算得出的：

<Section>
```ts 
import { posts } from './schema';

const db = drizzle(...);

const body = "金色的树叶覆盖了宁静的街道，清脆的微风充满空气，带来了雨的气息和变化的承诺"

await db.insert(posts).values({
    body,
    title: "秋天的美丽",
  }
).returning();
```

```json
[
  {
    id: 1,
    title: '秋天的美丽',
    body: '金色的树叶覆盖了宁静的街道，清脆的微风充满空气，带来了雨的气息和变化的承诺',
    bodySearch: "'air':13 'breez':10 'bring':14 'chang':23 'cover':3 'crisp':9 'fill':11 'golden':1 'leav':2 'promis':21 'quiet':5 'rain':18 'scent':16 'street':6"
  }
]
```
</Section>

这就是如何通过生成列在 PostgreSQL 中使用 Drizzle ORM 实现全文搜索的方法。`@@` 操作符用于直接匹配：

<Section>
```ts copy {6}
const searchParam = "bring";

await db
  .select()
  .from(posts)
  .where(sql`${posts.bodySearch} @@ to_tsquery('english', ${searchParam})`);
```

```sql
select * from posts where body_search @@ to_tsquery('english', 'bring');
```
</Section>

这是一个更高级的模式，其中有一个生成列。`search` 列是由 `title` 和 `body` 列生成的，`setweight()` 函数用于为全文搜索分配不同的权重。这通常用于标记来自文档不同部分的条目，如标题与正文。

<CodeTabs items={["schema.ts", "migration.sql"]}>
  <CodeTab>
  ```ts copy {18,19,20,21,22,23,24,28}
import { SQL, sql } from 'drizzle-orm';
import { index, pgTable, serial, text, customType } from 'drizzle-orm/pg-core';

export const tsvector = customType<{
  data: string;
}>({
  dataType() {
    return `tsvector`;
  },
});

export const posts = pgTable(
 'posts',
 {
   id: serial('id').primaryKey(),
   title: text('title').notNull(),
   body: text('body').notNull(),
   search: tsvector('search')
     .notNull()
     .generatedAlwaysAs(
        (): SQL =>
         sql`setweight(to_tsvector('english', ${posts.title}), 'A')
          ||
          setweight(to_tsvector('english', ${posts.body}), 'B')`,
     ),
  },
  (t) => [
    index('idx_search').using('gin', t.search),
  ],
);
  ```
  </CodeTab>
  ```sql
CREATE TABLE "posts" (
	"id" serial PRIMARY KEY NOT NULL,
	"title" text NOT NULL,
	"body" text NOT NULL,
	"search" "tsvector" GENERATED ALWAYS AS (setweight(to_tsvector('english', "posts"."title"), 'A')
          ||
          setweight(to_tsvector('english', "posts"."body"), 'B')) STORED NOT NULL
);
--> statement-breakpoint
CREATE INDEX "idx_search" ON "posts" USING gin ("search");
  ```
</CodeTabs>

这就是如何使用全文搜索查询表的方法：

<Section>
```ts copy {6}
const search = 'travel';

await db
  .select()
  .from(posts)
  .where(sql`${posts.search} @@ to_tsquery('english', ${search})`);
```

```sql
select * from posts where search @@ to_tsquery('english', 'travel');
```
</Section>

Source: https://drizzle.zhcndoc.com/docs/gel-ext-auth

import Prerequisites from "@mdx/Prerequisites.astro";
import Callout from "@mdx/Callout.astro";
import Npx from "@mdx/Npx.astro";

<Prerequisites>
- 开始使用 [Gel](/docs/get-started-gel)
- 使用 [drizzle-kit pull](/docs/drizzle-kit-pull)
</Prerequisites>

#### 第一步 - 定义 Gel 认证 schema

在 `dbschema/default.esdl` 文件中添加带有认证扩展的 Gel schema

```esdl
using extension auth;

module default {
  global current_user := (
    assert_single((
      select User { id, username, email }
      filter .identity = global ext::auth::ClientTokenIdentity
    ))
  );

  type User {
    required identity: ext::auth::Identity;
    required username: str;
    required email: str;
  }
}
```

#### 第二步 - 将 Gel schema 推送到数据库

生成 Gel 迁移文件：
```bash
gel migration create
```

将 Gel 迁移应用到数据库
```bash
gel migration apply
```

#### 第三步 - 设置 Drizzle 配置文件

**Drizzle 配置** - 是一个被 [Drizzle Kit](/docs/kit-overview) 使用的配置文件，包含关于数据库连接、迁移文件夹和 schema 文件的所有信息。

在项目根目录创建一个 `drizzle.config.ts` 文件，并添加以下内容：

```typescript copy filename="drizzle.config.ts"
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
  dialect: 'gel',
  // 为 drizzle-kit 启用 auth schema
  schemaFilter: ['ext::auth', 'public']
});
```

#### 第四步 - 将 Gel 类型拉取到 Drizzle schema

拉取你的数据库 schema：
<Npx>
drizzle-kit pull
</Npx>

以下是生成的 schema.ts 文件示例：

<Callout type="warning">
你不仅会获得来自 `ext::auth` 的 `Identity` 表，Drizzle 会拉取所有你可以使用的 `auth` 表。下面的示例仅展示其中一个。
</Callout>

```ts
import { gelTable, uniqueIndex, uuid, text, gelSchema, timestamptz, foreignKey } from "drizzle-orm/gel-core"
import { sql } from "drizzle-orm"

export const extauth = gelSchema('ext::auth');

export const identityInExtauth = extauth.table('Identity', {
	id: uuid().default(sql`uuid_generate_v4()`).primaryKey().notNull(),
	createdAt: timestamptz('created_at').default(sql`(clock_timestamp())`).notNull(),
	issuer: text().notNull(),
	modifiedAt: timestamptz('modified_at').notNull(),
	subject: text().notNull(),
}, (table) => [
	uniqueIndex('6bc2dd19-bce4-5810-bb1b-7007afe97a11;schemaconstr').using(
		'btree',
		table.id.asc().nullsLast().op('uuid_ops'),
	),
]);

export const user = gelTable('User', {
	id: uuid().default(sql`uuid_generate_v4()`).primaryKey().notNull(),
	email: text().notNull(),
	identityId: uuid('identity_id').notNull(),
	username: text().notNull(),
}, (table) => [
	uniqueIndex('d504514c-26a7-11f0-b836-81aa188c0abe;schemaconstr').using(
		'btree',
		table.id.asc().nullsLast().op('uuid_ops'),
	),
	foreignKey({
		columns: [table.identityId],
		foreignColumns: [identityInExtauth.id],
		name: 'User_fk_identity',
	}),
]);
```

🎉 现在你可以在查询中使用 `auth` 表了！

Source: https://drizzle.zhcndoc.com/docs/include-or-exclude-columns


import Section from "@mdx/Section.astro";
import IsSupportedChipGroup from "@mdx/IsSupportedChipGroup.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from '@mdx/CodeTabs.astro';
import CodeTab from '@mdx/CodeTab.astro';

<IsSupportedChipGroup chips={{PostgreSQL: true, MySQL: true, SQLite: true}}/>

<Prerequisites>
- 开始使用 [PostgreSQL](/docs/get-started-postgresql), [MySQL](/docs/get-started-mysql) 和 [SQLite](/docs/get-started-sqlite)
- [选择语句](/docs/select)
- [获取类型化表列](/docs/goodies#get-typed-table-columns)
- [连接](/docs/joins)
- [关系查询](/docs/rqb)
- [使用关系查询的部分选择](/docs/rqb#partial-fields-select)
</Prerequisites>

Drizzle 提供了灵活的 API 用于在查询中包含或排除列。要包含所有列，可以使用 `.select()` 方法，如下所示：

<CodeTabs items={["index.ts", "schema.ts"]}>
	<CodeTab>
    ```ts copy {5}
    import { posts } from './schema';

    const db = drizzle(...);

    await db.select().from(posts);
    ```

    ```ts
    // 结果类型
    type Result = {
      id: number;
      title: string;
      content: string;
      views: number;
    }[];
    ```
  </CodeTab>

  ```ts copy
  import { integer, pgTable, serial, text } from 'drizzle-orm/pg-core';

  export const posts = pgTable('posts', {
    id: serial('id').primaryKey(),
    title: text('title').notNull(),
    content: text('content').notNull(),
    views: integer('views').notNull().default(0),
  });
	```
</CodeTabs>

要包含特定列，可以使用 `.select()` 方法，如下所示：

<Section>
  ```ts copy {1}
  await db.select({ title: posts.title }).from(posts);
  ```

  ```ts
  // 结果类型
  type Result = {
    title: string;
  }[];
  ```
</Section>

要包含所有列并添加额外列，可以使用 `getTableColumns()` 工具函数，如下所示：

<Section>
  ```ts copy {5,6}
  import { getTableColumns, sql } from 'drizzle-orm';

  await db
    .select({
      ...getTableColumns(posts),
      titleLength: sql<number>`length(${posts.title})`,
    })
    .from(posts);
  ```

  ```ts
  // 结果类型
  type Result = {
    id: number;
    title: string;
    content: string;
    views: number;
    titleLength: number;
  }[];
  ```
</Section>

要排除列，可以使用 `getTableColumns()` 工具函数，如下所示：

<Section>
  ```ts copy {3,5}
  import { getTableColumns } from 'drizzle-orm';

  const { content, ...rest } = getTableColumns(posts); // 排除 "content" 列

  await db.select({ ...rest }).from(posts); // 选择所有其他列
  ```

  ```ts
  // 结果类型
  type Result = {
    id: number;
    title: string;
    views: number;
  }[];
  ```
</Section>

这就是如何在连接中包含或排除列：

<CodeTabs items={["index.ts", "schema.ts"]}>
  <CodeTab>
    ```ts copy {5,9,10,11}
    import { eq, getTableColumns } from 'drizzle-orm';
    import { comments, posts, users } from './db/schema';

    // 从 "comments" 中排除 "userId" 和 "postId" 列
    const { userId, postId, ...rest } = getTableColumns(comments);

    await db
      .select({
        postId: posts.id, // 包含 "posts" 中的 "id" 列
        comment: { ...rest }, // 包含所有其他列
        user: users, // 等同于 getTableColumns(users)
      })
      .from(posts)
      .leftJoin(comments, eq(posts.id, comments.postId))
      .leftJoin(users, eq(users.id, posts.userId));
    ```

    ```ts
    // 结果类型
    type Result = {
      postId: number;
      comment: {
        id: number;
        content: string;
        createdAt: Date;
      } | null;
      user: {
        id: number;
        name: string;
        email: string;
      } | null;
    }[];
    ```
  </CodeTab>

  ```ts copy
  import { integer, pgTable, serial, text, timestamp } from 'drizzle-orm/pg-core';

  export const users = pgTable('users', {
    id: serial('id').primaryKey(),
    name: text('name').notNull(),
    email: text('email').notNull(),
  });

  export const posts = pgTable('posts', {
    id: serial('id').primaryKey(),
    title: text('title').notNull(),
    content: text('content').notNull(),
    views: integer('views').notNull().default(0),
    userId: integer('user_id').notNull().references(() => users.id),
  });

  export const comments = pgTable('comments', {
    id: serial('id').primaryKey(),
    postId: integer('post_id').notNull().references(() => posts.id),
    userId: integer('user_id').notNull().references(() => users.id),
    content: text('content').notNull(),
    createdAt: timestamp('created_at').notNull().defaultNow(),
  });
  ```
</CodeTabs>

Drizzle 提供了有用的关系查询 API，使您可以轻松包含或排除查询中的列。这就是如何包含所有列：

<CodeTabs items={["index.ts", "schema.ts"]}>
  <CodeTab>
    ```ts copy {5,7,8,9,12,13,14,17,18,19,20,21,22}
    import * as schema from './schema';

    const db = drizzle(..., { schema });

    await db.query.posts.findMany();
    ```

    ```ts
    // 结果类型
    type Result = {
      id: number;
      title: string;
      content: string;
      views: number;
    }[]
    ```
  </CodeTab>

  ```ts copy
  import { integer, pgTable, serial, text } from 'drizzle-orm/pg-core';

  export const posts = pgTable('posts', {
    id: serial('id').primaryKey(),
    title: text('title').notNull(),
    content: text('content').notNull(),
    views: integer('views').notNull().default(0),
  });
	```
</CodeTabs>

这就是如何使用关系查询包含特定列：

<Section>
  ```ts copy {2,3,4}
  await db.query.posts.findMany({
    columns: {
      title: true,
    },
  });
  ```

  ```ts
  // 结果类型
  type Result = {
    title: string;
  }[]
  ```
</Section>

这就是如何使用关系查询包含所有列并添加额外列：

<Section>
  ```ts copy {4,5,6}
  import { sql } from 'drizzle-orm';

  await db.query.posts.findMany({
    extras: {
      titleLength: sql<number>`length(${posts.title})`.as('title_length'),
    },
  });
  ```

  ```ts
  // 结果类型
  type Result = {
    id: number;
    title: string;
    content: string;
    views: number;
    titleLength: number;
  }[];
  ```
</Section>

这就是如何使用关系查询排除列：

<Section>
  ```ts copy {2,3,4}
  await db.query.posts.findMany({
    columns: {
      content: false,
    },
  });
  ```

  ```ts
  // 结果类型
  type Result = {
    id: number;
    title: string;
    views: number;
  }[]
  ```
</Section>

这就是如何使用关系查询包含或排除与关系相关的列：

<CodeTabs items={["index.ts", "schema.ts"]}>
  <CodeTab>
  ```ts copy {7,12,13,16}
  import * as schema from './schema';

  const db = drizzle(..., { schema });

  await db.query.posts.findMany({
    columns: {
      id: true, // 包含 "id" 列
    },
    with: {
      comments: {
        columns: {
          userId: false, // 排除 "userId" 列
          postId: false, // 排除 "postId" 列
        },
      },
      user: true, // 包含 "users" 表中的所有列
    },
  });
  ```

  ```ts
  // 结果类型
  type Result = {
    id: number;
    user: {
      id: number;
      name: string;
      email: string;
    };
    comments: {
      id: number;
      content: string;
      createdAt: Date;
    }[];
  }[]
  ```
  </CodeTab>

  ```ts copy
  import { relations } from 'drizzle-orm';
  import { integer, pgTable, serial, text, timestamp } from 'drizzle-orm/pg-core';

  export const users = pgTable('users', {
    id: serial('id').primaryKey(),
    name: text('name').notNull(),
    email: text('email').notNull(),
  });

  export const posts = pgTable('posts', {
    id: serial('id').primaryKey(),
    title: text('title').notNull(),
    content: text('content').notNull(),
    views: integer('views').notNull().default(0),
    userId: integer('user_id').notNull().references(() => users.id),
  });

  export const comments = pgTable('comments', {
    id: serial('id').primaryKey(),
    postId: integer('post_id').notNull().references(() => posts.id),
    userId: integer('user_id').notNull().references(() => users.id),
    content: text('content').notNull(),
    createdAt: timestamp('created_at').notNull().defaultNow(),
  });

  export const usersRelations = relations(users, ({ many }) => ({
    posts: many(posts),
    comments: many(comments),
  }));

  export const postsRelations = relations(posts, ({ many, one }) => ({
    comments: many(comments),
    user: one(users, { fields: [posts.userId], references: [users.id] }),
  }));

  export const commentsRelations = relations(comments, ({ one }) => ({
    post: one(posts, { fields: [comments.postId], references: [posts.id] }),
    user: one(users, { fields: [comments.userId], references: [users.id] }),
  }));
  ```
</CodeTabs>

这就是如何创建自定义条件选择解决方案：

<CodeTabs items={["index.ts", "schema.ts"]}>
  <CodeTab>
    ```ts copy {7}
    import { posts } from './schema';

    const searchPosts = async (withTitle = false) => {
      await db
        .select({
          id: posts.id,
          ...(withTitle && { title: posts.title }),
        })
        .from(posts);
    };

    await searchPosts();
    await searchPosts(true);
    ```

    ```ts
    // 结果类型
    type Result = {
      id: number;
      title?: string | undefined;
    }[];
    ```
  </CodeTab>

  ```ts copy
  import { integer, pgTable, serial, text } from 'drizzle-orm/pg-core';

  export const posts = pgTable('posts', {
    id: serial('id').primaryKey(),
    title: text('title').notNull(),
    content: text('content').notNull(),
    views: integer('views').notNull().default(0),
  });
	```
</CodeTabs>


Source: https://drizzle.zhcndoc.com/docs/incrementing-a-value

import Section from "@mdx/Section.astro";
import IsSupportedChipGroup from "@mdx/IsSupportedChipGroup.astro";
import Prerequisites from "@mdx/Prerequisites.astro";

<IsSupportedChipGroup chips={{PostgreSQL: true, MySQL: true, SQLite: true}}/>

<Prerequisites>
- 开始使用 [PostgreSQL](/docs/get-started-postgresql)、[MySQL](/docs/get-started-mysql) 和 [SQLite](/docs/get-started-sqlite)
- [更新语句](/docs/update)
- [过滤器](/docs/operators) 和 [SQL 操作符](/docs/sql)
</Prerequisites>

要增加列的值，可以使用 `update().set()` 方法，如下所示：

<Section>
```ts copy {8}
import { eq, sql } from 'drizzle-orm';

const db = drizzle(...)
  
await db
  .update(table)
  .set({
    counter: sql`${table.counter} + 1`,
  })
  .where(eq(table.id, 1));
```

```sql
update "table" set "counter" = "counter" + 1 where "id" = 1;
```
</Section>

Drizzle 具有简单且灵活的 API，允许您轻松创建自定义解决方案。以下是如何创建自定义增量函数：

```ts copy {4,10,11}
import { AnyColumn } from 'drizzle-orm';

const increment = (column: AnyColumn, value = 1) => {
  return sql`${column} + ${value}`;
};

await db
  .update(table)
  .set({
    counter1: increment(table.counter1),
    counter2: increment(table.counter2, 10),
  })
  .where(eq(table.id, 1));
```


Source: https://drizzle.zhcndoc.com/docs/limit-offset-pagination


import CodeTabs from '@mdx/CodeTabs.astro';
import CodeTab from '@mdx/CodeTab.astro';
import Section from "@mdx/Section.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import IsSupportedChipGroup from "@mdx/IsSupportedChipGroup.astro";

<IsSupportedChipGroup chips={{PostgreSQL: true, MySQL: true, SQLite: true}}/>

<Prerequisites>
- 开始使用 [PostgreSQL](/docs/get-started-postgresql)，[MySQL](/docs/get-started-mysql) 和 [SQLite](/docs/get-started-sqlite)
- [选择语句](/docs/select) 中使用 [排序子句](/docs/select#order-by) 和 [限制与偏移子句](/docs/select#limit--offset)
- 使用 [关系查询](/docs/rqb) 的 [排序子句](/docs/rqb#order-by) 和 [限制与偏移子句](/docs/rqb#limit--offset)
- [动态查询构建](/docs/dynamic-query-building)
</Prerequisites>

本指南演示如何在 Drizzle 中实现 `limit/offset` 分页：

<CodeTabs items={["index.ts", "schema.ts"]}>
  <CodeTab>
    ```ts copy {9,10,11}
    import { asc } from 'drizzle-orm';
    import { users } from './schema';

    const db = drizzle(...);

    await db
      .select()
      .from(users)
      .orderBy(asc(users.id)) // 必须有排序
      .limit(4) // 返回的行数
      .offset(4); // 跳过的行数
    ```

    ```sql
    select * from users order by id asc limit 4 offset 4;
    ```

    ```ts
    // 返回第5-8行
    [
      {
        id: 5,
        firstName: 'Beth',
        lastName: 'Davis',
        createdAt: 2024-03-11T20:51:46.787Z
      },
      {
        id: 6,
        firstName: 'Charlie',
        lastName: 'Miller',
        createdAt: 2024-03-11T21:15:46.787Z
      },
      {
        id: 7,
        firstName: 'Clara',
        lastName: 'Wilson',
        createdAt: 2024-03-11T21:33:46.787Z
      },
      {
        id: 8,
        firstName: 'David',
        lastName: 'Moore',
        createdAt: 2024-03-11T21:45:46.787Z
      }
    ]
    ```
  </CodeTab>
  <CodeTab>
    ```ts copy
    import { pgTable, serial, text, timestamp } from 'drizzle-orm/pg-core';

    export const users = pgTable('users', {
      id: serial('id').primaryKey(),
      firstName: text('first_name').notNull(),
      lastName: text('last_name').notNull(),
      createdAt: timestamp('created_at').notNull().defaultNow(),
    });
    ```

    ```plaintext
    +----+------------+-----------+----------------------------+
    | id | first_name | last_name |         created_at         |
    +----+------------+-----------+----------------------------+
    |  1 | Alice      | Johnson   | 2024-03-08 12:23:55.251797 |
    +----+------------+-----------+----------------------------+
    |  2 | Alex       | Smith     | 2024-03-08 12:25:55.182    |
    +----+------------+-----------+----------------------------+
    |  3 | Aaron      | Williams  | 2024-03-08 12:28:55.182    |
    +----+------------+-----------+----------------------------+
    |  4 | Brian      | Brown     | 2024-03-08 12:34:55.182    |
    +----+------------+-----------+----------------------------+
    |  5 | Beth       | Davis     | 2024-03-08 12:40:55.182    |
    +----+------------+-----------+----------------------------+
    |  6 | Charlie    | Miller    | 2024-03-08 13:04:55.182    |
    +----+------------+-----------+----------------------------+
    |  7 | Clara      | Wilson    | 2024-03-08 13:22:55.182    |
    +----+------------+-----------+----------------------------+
    |  8 | David      | Moore     | 2024-03-08 13:34:55.182    |
    +----+------------+-----------+----------------------------+
    ```
  </CodeTab>
</CodeTabs>

限制是要返回的行数（`页面大小`），而偏移是要跳过的行数（`(页面号 - 1) * 页面大小`）。 
为了确保分页一致性，必须按唯一列排序。否则，结果可能会不一致。

如果需要按照非唯一列排序，也应在排序中附加一个唯一列。

以下是如何使用两个列实现 `limit/offset` 分页的示例：

<Section>
```ts copy {5}
const getUsers = async (page = 1, pageSize = 3) => {
  await db
    .select()
    .from(users)
    .orderBy(asc(users.firstName), asc(users.id)) // 按 first_name（非唯一）和 id（主键）排序
    .limit(pageSize) 
    .offset((page - 1) * pageSize);
}

await getUsers();
```
</Section>

Drizzle 具有实用的关系查询 API，可以轻松实现 `limit/offset` 分页：

<Section>
```ts copy {7,8,9}
import * as schema from './db/schema';

const db = drizzle({ schema });

const getUsers = async (page = 1, pageSize = 3) => {
  await db.query.users.findMany({
    orderBy: (users, { asc }) => asc(users.id),
    limit: pageSize,
    offset: (page - 1) * pageSize,
  });
};

await getUsers();
```
</Section>

Drizzle 提供简单且灵活的 API，让您可以轻松创建自定义解决方案。以下是如何使用 `.$dynamic()` 函数创建自定义分页功能：

<Section>
```ts copy {11,12,13,16}
import { SQL, asc } from 'drizzle-orm';
import { PgColumn, PgSelect } from 'drizzle-orm/pg-core';

function withPagination<T extends PgSelect>(
  qb: T,
  orderByColumn: PgColumn | SQL | SQL.Aliased,
  page = 1,
  pageSize = 3,
) {
  return qb
    .orderBy(orderByColumn)
    .limit(pageSize)
    .offset((page - 1) * pageSize);
}

const query = db.select().from(users); // 需要进行分页的查询

await withPagination(query.$dynamic(), asc(users.id));
```

</Section>

您可以通过使用 `延迟连接` 技术来提高 `limit/offset` 分页的性能。此方法在数据的一个子集上执行分页，而不是在整个表上。

您可以这样实现：

```ts copy {10}
const getUsers = async (page = 1, pageSize = 10) => {
   const sq = db
    .select({ id: users.id })
    .from(users)
    .orderBy(users.id)
    .limit(pageSize)
    .offset((page - 1) * pageSize)
    .as('subquery');

   await db.select().from(users).innerJoin(sq, eq(users.id, sq.id)).orderBy(users.id);
};
```

**`limit/offset` 分页的好处**：实现简单，页面容易访问，这意味着您可以在不保存先前页面状态的情况下导航到任何页面。

**`limit/offset` 分页的缺点**：随着偏移量的增加，查询性能下降，因为数据库必须扫描所有在偏移量之前的行以跳过它们，以及由于数据移动造成的不一致性，可能会导致同一行在不同页面上被返回或行被跳过。

它的工作原理如下：

<Section>
```ts copy
const getUsers = async (page = 1, pageSize = 3) => {
  await db
    .select()
    .from(users)
    .orderBy(asc(users.id))
    .limit(pageSize)
    .offset((page - 1) * pageSize);
};

// 用户正在浏览第一页
await getUsers();
```

```ts
// 第一页的结果
[
  {
    id: 1,
    firstName: 'Alice',
    lastName: 'Johnson',
    createdAt: 2024-03-10T17:17:06.148Z
  },
  {
    id: 2,
    firstName: 'Alex',
    lastName: 'Smith',
    createdAt: 2024-03-10T17:19:06.147Z
  },
  {
    id: 3,
    firstName: 'Aaron',
    lastName: 'Williams',
    createdAt: 2024-03-10T17:22:06.147Z
  }
]
```

```ts
// 当用户浏览第一页时，删除了 id 为 2 的行
await db.delete(users).where(eq(users.id, 2));

// 用户导航到第二页
await getUsers(2);
```

```ts
// 第二页，id 为 3 的行被跳过
[
  {
    id: 5,
    firstName: 'Beth',
    lastName: 'Davis',
    createdAt: 2024-03-10T17:34:06.147Z
  },
  {
    id: 6,
    firstName: 'Charlie',
    lastName: 'Miller',
    createdAt: 2024-03-10T17:58:06.147Z
  },
  {
    id: 7,
    firstName: 'Clara',
    lastName: 'Wilson',
    createdAt: 2024-03-10T18:16:06.147Z
  }
]
```
</Section>

因此，如果您的数据库在实时中频繁执行插入和删除操作，或者您需要对大型表进行高性能分页，您应该考虑使用 [基于游标](/docs/guides/cursor-based-pagination) 的分页。

要了解有关 `延迟连接` 技术的更多信息，您可以参考以下指南：[Planetscale 分页指南](https://planetscale.com/blog/mysql-pagination) 和 [Aaron Francis 的高效分页指南](https://aaronfrancis.com/2022/efficient-pagination-using-deferred-joins)。


Source: https://drizzle.zhcndoc.com/docs/mysql-local-setup


import Section from "@mdx/Section.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from '@mdx/CodeTabs.astro';
import CodeTab from '@mdx/CodeTab.astro';
import Steps from '@mdx/Steps.astro';

<Prerequisites>
- 安装最新的 [Docker Desktop](https://www.docker.com/products/docker-desktop/)。请根据您的操作系统按照说明进行安装。
</Prerequisites>

<Steps>

#### 拉取 MySQL 镜像

从 Docker Hub 拉取最新的 MySQL 镜像。在终端中运行 `docker pull mysql` 命令来拉取最新的 MySQL 版本：

```bash copy
docker pull mysql
```

或者，您可以按特定标签拉取所需的版本：

```bash copy
docker pull mysql:8.2
```

当 MySQL 镜像下载完成后，您可以在 Docker Desktop 的“Images”选项卡中查看，或通过运行 `docker images` 命令来查看：

<Section>
```bash copy
docker images
```

```plaintext
REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
mysql        latest    4e8a34aea708   2 months ago   609MB
```
</Section>

#### 启动 MySQL 实例

要启动一个新的 MySQL 容器，请运行以下命令：

```bash copy
docker run --name drizzle-mysql -e MYSQL_ROOT_PASSWORD=mypassword -d -p 3306:3306 mysql
```

1. `--name` 选项给容器分配名称 `drizzle-mysql`。
2. `-e MYSQL_ROOT_PASSWORD=` 选项设置 `MYSQL_ROOT_PASSWORD` 环境变量为指定的值。这是根用户的密码。
3. `-d` 标志使容器在分离模式下运行（在后台）。
4. `-p` 选项将容器的 `3306` 端口映射到主机的 `3306` 端口，使 MySQL 可以通过该端口从主机系统访问。
5. `mysql` 参数指定用于容器的镜像。您也可以指定其他版本，如 `mysql:8.2`。

您还可以指定其他参数，例如：

1. `-e MYSQL_DATABASE=` 在创建容器时创建一个新的数据库。默认值为 `mysql`。
2. `-e MYSQL_USER=` 和 `-e MYSQL_PASSWORD=` 在创建容器时创建一个具有密码的新用户。不过，您仍需为 `root` 用户指定 `MYSQL_ROOT_PASSWORD`。

要检查容器是否正在运行，请查看 Docker Desktop 的“Containers”选项卡或使用 `docker ps` 命令：

```plaintext
CONTAINER ID   IMAGE         COMMAND                  CREATED          STATUS          PORTS                               NAMES
19506a8dc12b   mysql         "docker-entrypoint.s…"   4 seconds ago    Up 3 seconds    33060/tcp, 0.0.0.0:3306->3306/tcp   drizzle-mysql
```

#### 配置数据库 URL

要连接到 MySQL 数据库，您需要提供数据库 URL。URL 格式为：

```plaintext
mysql://<user>:<password>@<host>:<port>/<database>
```

您应该用实际值替换占位符。例如，针对创建的容器，URL 将为：

```plaintext
mysql://root:mypassword@localhost:3306/mysql
```

现在您可以在应用程序中使用该 URL 连接到数据库。
</Steps>


Source: https://drizzle.zhcndoc.com/docs/point-datatype-psql


import Section from "@mdx/Section.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from '@mdx/CodeTabs.astro';
import CodeTab from '@mdx/CodeTab.astro';

<Prerequisites>
- 开始使用 [PostgreSQL](/docs/get-started-postgresql)
- [点数据类型](/docs/column-types/pg#point)
- [选择语句中的过滤](/docs/select#filtering)
- [sql 操作符](/docs/sql)
</Prerequisites>

PostgreSQL 具有一种特殊的数据类型用于存储几何数据，称为 `point`。它用于表示二维空间中的一个点。点数据类型以一对 `(x, y)` 坐标表示。
点数据类型期待先接收经度，然后是纬度。

<Section>
```ts copy {6}
import { sql } from 'drizzle-orm';

const db = drizzle(...);

await db.execute(
  sql`select point(-90.9, 18.7)`,
);
```

```json
[ 
  { 
    point: '(-90.9,18.7)' 
  }
]
```
</Section>

以下是如何在 Drizzle 中创建一个具有 `point` 数据类型的表：

```ts {6}
import { pgTable, point, serial, text } from 'drizzle-orm/pg-core';

export const stores = pgTable('stores', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  location: point('location', { mode: 'xy' }).notNull(),
});
```

以下是如何在 Drizzle 中插入点数据到表中：

```ts {4, 10, 16}
// mode: 'xy'
await db.insert(stores).values({
  name: 'Test',
  location: { x: -90.9, y: 18.7 },
});

// mode: 'tuple'
await db.insert(stores).values({
  name: 'Test',
  location: [-90.9, 18.7],
});

// sql 原生
await db.insert(stores).values({
  name: 'Test',
  location: sql`point(-90.9, 18.7)`,
});
```

要计算对象之间的距离，可以使用 `<->` 操作符。以下是如何在 Drizzle 中根据坐标查询最近位置：

<Section>
```ts {9, 14, 17}
import { getTableColumns, sql } from 'drizzle-orm';
import { stores } from './schema';

const point = {
  x: -73.935_242,
  y: 40.730_61,
};

const sqlDistance = sql`location <-> point(${point.x}, ${point.y})`;

await db
  .select({
    ...getTableColumns(stores),
    distance: sql`round((${sqlDistance})::numeric, 2)`,
  })
  .from(stores)
  .orderBy(sqlDistance)
  .limit(1);
```

```sql
select *, round((location <-> point(-73.935242, 40.73061))::numeric, 2)
from stores order by location <-> point(-73.935242, 40.73061)
limit 1;
```
</Section>

要过滤行以仅包括 `point` 类型的 `location` 在由两个对角点定义的指定矩形边界内的行，可以使用 `<@` 操作符。该操作符检查第一个对象是否被包含在第二个对象内或在其上：

<Section>
```ts {12}
const point = {
  x1: -88,
  x2: -73,
  y1: 40,
  y2: 43,
};

await db
  .select()
  .from(stores)
  .where(
    sql`${stores.location} <@ box(point(${point.x1}, ${point.y1}), point(${point.x2}, ${point.y2}))`
  );
```

```sql
select * from stores where location <@ box(point(-88, 40), point(-73, 43));
```
</Section>





Source: https://drizzle.zhcndoc.com/docs/postgis-geometry-point


import Section from "@mdx/Section.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from '@mdx/CodeTabs.astro';
import CodeTab from '@mdx/CodeTab.astro';

<Prerequisites>
- 了解如何使用 [PostgreSQL](/docs/get-started-postgresql)
- [Postgis 扩展](/docs/extensions/pg#postgis)
- [索引](/docs/indexes-constraints#indexes)
- [选择语句中的过滤](/docs/select#filtering)
- [SQL 操作符](/docs/sql)
</Prerequisites>

`PostGIS` 通过支持存储、索引和查询地理空间数据来扩展 PostgreSQL 关系数据库的能力。

目前，Drizzle 不会自动创建扩展，因此您需要手动创建。创建一个空的迁移文件并添加 SQL 查询：

<Section>
```bash
npx drizzle-kit generate --custom
```

```sql
CREATE EXTENSION postgis;
```
</Section>

以下是您在 Drizzle 中如何创建具有 `geometry` 数据类型和空间索引的表：

<CodeTabs items={["schema.ts", "migration.sql"]}>
  <CodeTab>
  ```ts copy {8, 11}
  import { geometry, index, pgTable, serial, text } from 'drizzle-orm/pg-core';

  export const stores = pgTable(
    'stores',
    {
      id: serial('id').primaryKey(),
      name: text('name').notNull(),
      location: geometry('location', { type: 'point', mode: 'xy', srid: 4326 }).notNull(),
    },
    (t) => [
      index('spatial_index').using('gist', t.location),
    ]
  );
  ```
  </CodeTab>
  ```sql
  CREATE TABLE IF NOT EXISTS "stores" (
	  "id" serial PRIMARY KEY NOT NULL,
	  "name" text NOT NULL,
	  "location" geometry(point) NOT NULL
  );
  --> statement-breakpoint
  CREATE INDEX IF NOT EXISTS "spatial_index" ON "stores" USING gist ("location");
  ```
</CodeTabs>
 
以下是您如何在 Drizzle 中插入 `geometry` 数据。PostGIS 中的 `ST_MakePoint()` 使用指定的坐标创建一个 `point` 类型的几何对象。
`ST_SetSRID()` 将几何图形上的 `SRID`（与特定坐标系统、容差和分辨率关联的唯一标识符）设置为特定的整数值：

```ts {4, 10, 16}
// mode: 'xy'
await db.insert(stores).values({
  name: 'Test',
  location: { x: -90.9, y: 18.7 },
});

// mode: 'tuple'
await db.insert(stores).values({
  name: 'Test',
  location: [-90.9, 18.7],
});

// sql raw
await db.insert(stores).values({
  name: 'Test',
  location: sql`ST_SetSRID(ST_MakePoint(-90.9, 18.7), 4326)`,
});
```

要计算对象之间的距离，您可以使用 `<->` 操作符和 `ST_Distance()` 函数，对于 `geometry types` 返回两个几何形状之间的最小平面距离。这是您如何在 Drizzle 中通过 PostGIS 查询最近的位置：

<Section>
```ts copy {9, 14, 17}
import { getTableColumns, sql } from 'drizzle-orm';
import { stores } from './schema';

const point = {
  x: -73.935_242,
  y: 40.730_61,
};

const sqlPoint = sql`ST_SetSRID(ST_MakePoint(${point.x}, ${point.y}), 4326)`;

await db
  .select({
    ...getTableColumns(stores),
    distance: sql`ST_Distance(${stores.location}, ${sqlPoint})`,
  })
  .from(stores)
  .orderBy(sql`${stores.location} <-> ${sqlPoint}`)
  .limit(1);
```

```sql
select *, ST_Distance(location, ST_SetSRID(ST_MakePoint(-73.935_242, 40.730_61), 4326))
from stores order by location <-> ST_SetSRID(ST_MakePoint(-73.935_242, 40.730_61), 4326)
limit 1;
```
</Section>

要过滤位于指定矩形区域内的商店，您可以使用 `ST_MakeEnvelope()` 和 `ST_Within()` 函数。`ST_MakeEnvelope()` 从 X 和 Y 的最小值和最大值创建一个矩形多边形。`ST_Within()` 如果几何图形 A 在几何图形 B 内部则返回 TRUE。

<Section>
```ts copy {13}
const point = {
  x1: -88,
  x2: -73,
  y1: 40,
  y2: 43,
};

await db
  .select()
  .from(stores)
  .where(
    sql`ST_Within(
      ${stores.location}, ST_MakeEnvelope(${point.x1}, ${point.y1}, ${point.x2}, ${point.y2}, 4326)
    )`,
  );
```

```sql
select * from stores where ST_Within(location, ST_MakeEnvelope(-88, 40, -73, 43, 4326));
```
</Section>


Source: https://drizzle.zhcndoc.com/docs/postgresql-full-text-search


import Section from "@mdx/Section.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from '@mdx/CodeTabs.astro';
import CodeTab from '@mdx/CodeTab.astro';

<Prerequisites>
- 开始使用 [PostgreSQL](/docs/get-started-postgresql)
- [选择语句](/docs/select)
- [索引](/docs/indexes-constraints#indexes)
- [SQL 操作符](/docs/sql)
- 需要使用 `drizzle-orm@0.31.0` 和 `drizzle-kit@0.22.0` 或更高版本。  
</Prerequisites>

本指南演示如何在 PostgreSQL 中使用 Drizzle ORM 实现全文搜索。全文搜索是一种用于在文档或一组文档中搜索文本的技术。文档是全文搜索系统中的搜索单位。PostgreSQL 提供了一组函数来处理全文搜索，例如 `to_tsvector` 和 `to_tsquery`：

`to_tsvector` 函数将文本文档解析为标记，将标记减少为词元，并返回一个 `tsvector`，该 `tsvector` 列出了词元及其在文档中的位置：

<Section>
```ts copy {6}
import { sql } from 'drizzle-orm';

const db = drizzle(...);

await db.execute(
  sql`select to_tsvector('english', 'Guide to PostgreSQL full-text search with Drizzle ORM')`,
);
```

```json
[
  {
    to_tsvector: "'drizzl':9 'full':5 'full-text':4
    'guid':1 'orm':10 'postgresql':3 'search':7 'text':6"
  }
]
```
</Section>

`to_tsquery` 函数将关键字转换为规范化的标记，并返回一个与 `tsvector` 中的词元匹配的 `tsquery`。`@@` 操作符用于直接匹配：

<Section>
```ts copy {2, 3}
await db.execute(
  sql`select to_tsvector('english', 'Guide to PostgreSQL full-text search with Drizzle ORM')
    @@ to_tsquery('english', 'Drizzle') as match`,
);
```

```json
[ { match: true } ]
```
</Section>

目前，Drizzle 不支持 `tsvector` 类型，因此您需要动态地转换 `text` 列中的数据。为了提高性能，您可以像这样在您的列上创建一个 `GIN` 索引：

<CodeTabs items={["schema.ts", "migration.sql", "db_data"]}>
  <CodeTab>
  ```ts copy {10, 11}
  import { index, pgTable, serial, text } from 'drizzle-orm/pg-core';

  export const posts = pgTable(
    'posts',
    {
      id: serial('id').primaryKey(),
      title: text('title').notNull(),
    },
    (table) => [
      index('title_search_index').using('gin', sql`to_tsvector('english', ${table.title})`),
    ]
  );
  ```
  </CodeTab>
  <CodeTab>
  ```sql
  CREATE TABLE IF NOT EXISTS "posts" (
          "id" serial PRIMARY KEY NOT NULL,
          "title" text NOT NULL
  );

  CREATE INDEX IF NOT EXISTS "title_search_index" ON "posts"
    USING gin (to_tsvector('english', "title"));
  ```
  </CodeTab>
  ```json
  [
    { id: 1, title: 'Planning Your First Trip to Europe' },
    { id: 2, title: "Cultural Insights: Exploring Asia's Heritage" },
    { id: 3, title: 'Top 5 Destinations for a Family Trip' },
    { id: 4, title: 'Essential Hiking Gear for Mountain Enthusiasts' },
    { id: 5, title: 'Trip Planning: Choosing Your Next Destination' },
    { id: 6, title: 'Discovering Hidden Culinary Gems in Italy' },
    { id: 7, title: 'The Ultimate Road Trip Guide for Explorers' },
  ];
  ```
</CodeTabs>

要在 PostgreSQL 中使用 Drizzle ORM 实现全文搜索，您可以使用 `to_tsvector` 和 `to_tsquery` 函数与 `sql` 操作符：

<Section>
```ts copy {9}
import { sql } from 'drizzle-orm';
import { posts } from './schema';

const title = 'trip';

await db
  .select()
  .from(posts)
  .where(sql`to_tsvector('english', ${posts.title}) @@ to_tsquery('english', ${title})`);
```

```json
[
  { id: 1, title: 'Planning Your First Trip to Europe' },
  { id: 3, title: 'Top 5 Destinations for a Family Trip' },
  { id: 5, title: 'Trip Planning: Choosing Your Next Destination' },
  { id: 7, title: 'The Ultimate Road Trip Guide for Explorers' }
]
```
</Section>

要通过任何关键字进行匹配，您可以使用 `|` 操作符：

<Section>
```ts copy {6}
const title = 'Europe | Asia';

await db
  .select()
  .from(posts)
  .where(sql`to_tsvector('english', ${posts.title}) @@ to_tsquery('english', ${title})`);
```

```json
[
  { id: 1, title: 'Planning Your First Trip to Europe' },
  { id: 2, title: "Cultural Insights: Exploring Asia's Heritage" }
]
```
</Section>

要匹配多个关键字，您可以使用 `plainto_tsquery` 函数：

<Section>
```ts copy {7}
// 'discover & Italy'
const title = 'discover Italy';

await db
  .select()
  .from(posts)
  .where(sql`to_tsvector('english', ${posts.title}) @@ plainto_tsquery('english', ${title})`);
```

```sql
select * from posts
  where to_tsvector('english', title) @@ plainto_tsquery('english', 'discover Italy');
```

```json
[ { id: 6, title: 'Discovering Hidden Culinary Gems in Italy' } ]
```
</Section>

要匹配短语，您可以使用 `phraseto_tsquery` 函数：

<Section>
```ts copy {8}
// 如果按 "trip family" 查询，它将不会返回任何结果
// 'family <-> trip'
const title = 'family trip';

await db
  .select()
  .from(posts)
  .where(sql`to_tsvector('english', ${posts.title}) @@ phraseto_tsquery('english', ${title})`);
```

```sql
select * from posts
  where to_tsvector('english', title) @@ phraseto_tsquery('english', 'family trip');
```

```json
[ { id: 3, title: 'Top 5 Destinations for a Family Trip' } ]
```
</Section>

您还可以使用 `websearch_to_tsquery` 函数，它是 `to_tsquery` 的简化版本，具有类似于网络搜索引擎使用的替代语法：

<Section>
```ts copy {7}
// 'family | first & trip & europe | asia'
const title = 'family or first trip Europe or Asia';

await db
  .select()
  .from(posts)
  .where(sql`to_tsvector('english', ${posts.title}) @@ websearch_to_tsquery('english', ${title})`);
```

```sql
select * from posts
  where to_tsvector('english', title)
  @@ websearch_to_tsquery('english', 'family or first trip Europe or Asia');
```

```json
[
  { id: 1, title: 'Planning Your First Trip to Europe' },
  { id: 2, title: "Cultural Insights: Exploring Asia's Heritage" },
  { id: 3, title: 'Top 5 Destinations for a Family Trip' }
]
```
</Section>

要在多个列上实现全文搜索，您可以对多个列创建索引，并使用 `to_tsvector` 函数连接这些列：

<CodeTabs items={["schema.ts", "migration.sql", "db_data"]}>
  <CodeTab>
  ```ts copy {12-17}
  import { sql } from 'drizzle-orm';
  import { index, pgTable, serial, text } from 'drizzle-orm/pg-core';

  export const posts = pgTable(
    'posts',
    {
      id: serial('id').primaryKey(),
      title: text('title').notNull(),
      description: text('description').notNull(),
    },
    (table) => [
      index('search_index').using(
        'gin',
        sql`(
            setweight(to_tsvector('english', ${table.title}), 'A') ||
            setweight(to_tsvector('english', ${table.description}), 'B')
        )`,
      ),
    ],
  );
  ```
  </CodeTab>
  <CodeTab>
  ```sql
  CREATE TABLE IF NOT EXISTS "posts" (
        "id" serial PRIMARY KEY NOT NULL,
        "title" text NOT NULL,
        "description" text NOT NULL
  );

  CREATE INDEX IF NOT EXISTS "search_index" ON "posts"
    USING gin ((setweight(to_tsvector('english', "title"), 'A') ||
    setweight(to_tsvector('english', "description"), 'B')));
  ```
  </CodeTab>
  ```json
  [
    {
      id: 1,
      title: 'Planning Your First Trip to Europe',
      description:
        'Get essential tips on budgeting, sightseeing, and cultural etiquette for your inaugural European adventure.',
    },
    {
      id: 2,
      title: "Cultural Insights: Exploring Asia's Heritage",
      description:
        'Dive deep into the rich history and traditions of Asia through immersive experiences and local interactions.',
    },
    {
      id: 3,
      title: 'Top 5 Destinations for a Family Trip',
      description:
        'Discover family-friendly destinations that offer fun, education, and relaxation for all ages.',
    },
    {
      id: 4,
      title: 'Essential Hiking Gear for Mountain Enthusiasts',
      description:
        'Equip yourself with the latest and most reliable gear for your next mountain hiking expedition.',
    },
    {
      id: 5,
      title: 'Trip Planning: Choosing Your Next Destination',
      description:
        'Learn how to select destinations that align with your travel goals, whether for leisure, adventure, or cultural exploration.',
    },
    {
      id: 6,
      title: 'Discovering Hidden Culinary Gems in Italy',
      description:
        "Unearth Italy's lesser-known eateries and food markets that offer authentic and traditional flavors.",
    },
    {
      id: 7,
      title: 'The Ultimate Road Trip Guide for Explorers',
      description:
        'Plan your next great road trip with tips on route planning, packing, and discovering off-the-beaten-path attractions.',
    },
  ];
  ```
</CodeTabs>

`setweight` 函数用于为 tsvector 的条目标记一个给定的权重，其中权重是字母 A、B、C 或 D 之一。这通常用于标记来自文档不同部分的条目，例如标题与正文。

这就是您如何在多个列上执行查询：

<Section>
```ts copy {5-7}
const title = 'plan';

await db.select().from(posts)
  .where(sql`(
      setweight(to_tsvector('english', ${posts.title}), 'A') ||
      setweight(to_tsvector('english', ${posts.description}), 'B'))
      @@ to_tsquery('english', ${title}
    )`
  );
```

```json
[
  {
    id: 1,
    title: 'Planning Your First Trip to Europe',
    description: 'Get essential tips on budgeting, sightseeing, and cultural etiquette for your inaugural European adventure.'
  },
  {
    id: 5,
    title: 'Trip Planning: Choosing Your Next Destination',
    description: 'Learn how to select destinations that align with your travel goals, whether for leisure, adventure, or cultural exploration.'
  },
  {
    id: 7,
    title: 'The Ultimate Road Trip Guide for Explorers',
    description: 'Plan your next great road trip with tips on route planning, packing, and discovering off-the-beaten-path attractions.'
  }
]
```
</Section>

要对搜索结果进行排名，您可以使用 `ts_rank` 或 `ts_rank_cd` 函数和 `orderBy` 方法：

<Section>
```ts copy {6,7,12,13,18-20}
import { desc, getTableColumns, sql } from 'drizzle-orm';

const search = 'culture | Europe | Italy | adventure';

const matchQuery = sql`(
  setweight(to_tsvector('english', ${posts.title}), 'A') ||
  setweight(to_tsvector('english', ${posts.description}), 'B')), to_tsquery('english', ${search})`;

await db
  .select({
    ...getTableColumns(posts),
    rank: sql`ts_rank(${matchQuery})`,
    rankCd: sql`ts_rank_cd(${matchQuery})`,
  })
  .from(posts)
  .where(
    sql`(
      setweight(to_tsvector('english', ${posts.title}), 'A') ||
      setweight(to_tsvector('english', ${posts.description}), 'B')
      ) @@ to_tsquery('english', ${search})`,
  )
  .orderBy((t) => desc(t.rank));
```

```json
[
  {
    id: 1,
    title: 'Planning Your First Trip to Europe',
    description: 'Get essential tips on budgeting, sightseeing, and cultural etiquette for your inaugural European adventure.',
    rank: 0.2735672,
    rankCd: 1.8
  },
  {
    id: 6,
    title: 'Discovering Hidden Culinary Gems in Italy',
    description: "Unearth Italy's lesser-known eateries and food markets that offer authentic and traditional flavors.",
    rank: 0.16717994,
    rankCd: 1.4
  },
  {
    id: 2,
    title: "Cultural Insights: Exploring Asia's Heritage",
    description: 'Dive deep into the rich history and traditions of Asia through immersive experiences and local interactions.',
    rank: 0.15198177,
    rankCd: 1
  },
  {
    id: 5,
    title: 'Trip Planning: Choosing Your Next Destination',
    description: 'Learn how to select destinations that align with your travel goals, whether for leisure, adventure, or cultural exploration.',
    rank: 0.12158542,
    rankCd: 0.8
  }
]
```
</Section>

`ts_rank` 函数侧重于查询术语在整个文档中的频率。而 `ts_rank_cd` 函数则侧重于查询术语在文档中的接近程度。


Source: https://drizzle.zhcndoc.com/docs/postgresql-local-setup


import Section from "@mdx/Section.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from '@mdx/CodeTabs.astro';
import CodeTab from '@mdx/CodeTab.astro';
import Steps from '@mdx/Steps.astro';

<Prerequisites>
- 安装最新的 [Docker Desktop](https://www.docker.com/products/docker-desktop/)。请按照您操作系统的说明进行操作。
</Prerequisites>

<Steps>

#### 拉取 PostgreSQL 镜像

从 Docker Hub 拉取最新的 PostgreSQL 镜像。在终端中运行 `docker pull postgres` 来拉取最新的 Postgres 版本：

```bash copy
docker pull postgres
```

此外，您还可以使用特定标签拉取所需版本：

```bash copy
docker pull postgres:15
```

当 PostgreSQL 镜像下载完成后，您可以在 Docker Desktop 的 `Images` 标签中查看它，或通过运行 `docker images` 进行检查：

<Section>
```bash copy
docker images
```

```plaintext
REPOSITORY   TAG       IMAGE ID       CREATED         SIZE
postgres     latest    75282fa229a1   6 weeks ago     453MB
```
</Section>

#### 启动 PostgreSQL 实例

要启动一个新的 PostgreSQL 容器，请运行以下命令：

```bash copy
docker run --name drizzle-postgres -e POSTGRES_PASSWORD=mypassword -d -p 5432:5432 postgres
```

1. `--name` 选项为容器指定名称 `drizzle-postgres`。
2. `-e POSTGRES_PASSWORD=` 选项设置 `POSTGRES_PASSWORD` 环境变量为指定值。
3. `-d` 标志使容器在分离模式下（在后台）运行。
4. `-p` 选项将容器中的端口 `5432` 映射到主机上的端口 `5432`，允许通过该端口从主机系统访问 PostgreSQL。
5. `postgres` 参数指定用于容器的镜像。您也可以指定其他版本，例如 `postgres:15`。

您还可以指定其他参数，例如：

1. `-e POSTGRES_USER=` 选项设置 `POSTGRES_USER` 环境变量为指定值。当为空时，Postgres 使用默认用户。通常情况下，它是 `postgres`，您可以在 Docker Desktop 中查看容器日志，或通过运行 `docker logs <container_name>` 进行检查。
2. `-e POSTGRES_DB=` 选项设置 `POSTGRES_DB` 环境变量为指定值。当为空时，默认为 `POSTGRES_USER` 的值。

要检查容器是否正在运行，请查看 Docker Desktop 的 `Containers` 标签或使用 `docker ps` 命令：

```plaintext
CONTAINER ID   IMAGE      COMMAND                  CREATED         STATUS         PORTS                    NAMES
df957c58a6a3   postgres   "docker-entrypoint.s…"   4 seconds ago   Up 3 seconds   0.0.0.0:5432->5432/tcp   drizzle-postgres
```

#### 配置数据库 URL

要连接到 PostgreSQL 数据库，您需要提供数据库 URL。URL 的格式为：

```plaintext
postgres://<user>:<password>@<host>:<port>/<database>
```

您应该用实际的值替换占位符。例如，对于创建的容器，URL 为：

```plaintext
postgres://postgres:mypassword@localhost:5432/postgres
```

现在，您可以在应用程序中使用该 URL 连接到数据库。
</Steps>


Source: https://drizzle.zhcndoc.com/docs/seeding-using-with-option


import IsSupportedChipGroup from "@mdx/IsSupportedChipGroup.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from '@mdx/CodeTabs.astro';
import CodeTab from '@mdx/CodeTab.astro';
import Callout from '@mdx/Callout.astro';
import Section from "@mdx/Section.astro";

<IsSupportedChipGroup chips={{PostgreSQL: true, MySQL: true, SQLite: true}}/>

<Prerequisites>
- 了解如何开始使用 [PostgreSQL](/docs/get-started-postgresql)、[MySQL](/docs/get-started-mysql) 或 [SQLite](/docs/get-started-sqlite)
- 熟悉 [一对多关系](/docs/relations#one-to-many)
- 熟悉 [Drizzle Seed](/docs/seed-overview)
</Prerequisites>

<Callout title='警告'>
使用 `with` 意味着表之间存在一对多关系。

因此，如果一个 `one` 用户拥有 `many` 帖子，则可以如下使用 `with`：
```ts
users: {
    count: 2,
    with: {
        posts: 3,
    },
},
```
</Callout>

## 示例 1
<CodeTabs items={["index.ts", "schema.ts"]}>
<CodeTab>
```ts
import { users, posts } from './schema.ts';

async function main() {
    const db = drizzle(...);
    await seed(db, { users, posts }).refine(() => ({
        users: {
            count: 2,
            with: {
                posts: 3,
            },
        },
    }));
}
main();

```
</CodeTab>

<CodeTab>
```ts
import { serial, pgTable, integer, text } from "drizzle-orm/pg-core";

export const users = pgTable('users', {
	id: serial('id').primaryKey(),
	name: text('name'),
});

export const posts = pgTable('posts', {
	id: serial('id').primaryKey(),
	content: text('content'),
	authorId: integer('author_id').notNull(),
});
```
</CodeTab>
</CodeTabs>

运行上述填充脚本会导致错误。

```
Error: "posts" 表没有引用 "users" 表，或者
你没有在 seed 函数的 schema 中包含一对多关系。
你不能在 users.with 对象中指定 "posts" 作为参数。
```

你有几种方式解决此错误：
- 你可以在 `posts` 表的 `authorId` 列中添加对 `users` 表的引用
<CodeTabs items={["index.ts", "schema.ts"]}>
<CodeTab>
<Section>
```ts
import { users, posts } from './schema.ts';

async function main() {
    const db = drizzle(...);
    await seed(db, { users, posts }).refine(() => ({
        users: {
            count: 2,
            with: {
                posts: 3,
            },
        },
    }));
}
main();

// 运行上述填充脚本将填充数据库如下值
```

```mdx
`users`

| id |   name   |   
| -- | -------- |
|  1 | 'Melanny' | 
|  2 | 'Elvera' |

`posts`

| id |        content        | author_id |   
| -- | --------------------- | --------- |
|  1 | 'tf02gUXb0LZIdEg6SL'  |     2     |
|  2 | 'j15YdT7Sma'          |     2     |
|  3 | 'LwwvWtLLAZzIpk'      |     1     |
|  4 | 'mgyUnBKSrQw'         |     1     |
|  5 | 'CjAJByKIqilHcPjkvEw' |     2     |
|  6 | 'S5g0NzXs'            |     1     |
```
</Section>
</CodeTab>
<CodeTab>
```ts copy{11}
import { serial, pgTable, integer, text } from "drizzle-orm/pg-core";

export const users = pgTable('users', {
	id: serial('id').primaryKey(),
	name: text('name'),
});

export const posts = pgTable('posts', {
	id: serial('id').primaryKey(),
	content: text('content'),
	authorId: integer('author_id').notNull().references(() => users.id),
});
```
</CodeTab>
</CodeTabs>

- 你也可以在 schema 中添加一对多关系，并在 seed 函数的 schema 中包含该关系
<CodeTabs items={["index.ts", "schema.ts"]}>
<CodeTab>
<Section>
```ts copy{1,5}
import { users, posts, postsRelations } from './schema.ts';

async function main() {
    const db = drizzle(...);
    await seed(db, { users, posts, postsRelations }).refine(() => ({
        users: {
            count: 2,
            with: {
                posts: 3,
            },
        },
    }));
}
main();

// 运行上述填充脚本将填充数据库如下值
```

```mdx
`users`

| id |   name   |   
| -- | -------- |
|  1 | 'Melanny' | 
|  2 | 'Elvera' |

`posts`

| id |        content        | author_id |   
| -- | --------------------- | --------- |
|  1 | 'tf02gUXb0LZIdEg6SL'  |     2     |
|  2 | 'j15YdT7Sma'          |     2     |
|  3 | 'LwwvWtLLAZzIpk'      |     1     |
|  4 | 'mgyUnBKSrQw'         |     1     |
|  5 | 'CjAJByKIqilHcPjkvEw' |     2     |
|  6 | 'S5g0NzXs'            |     1     |
```
</Section>
</CodeTab>

<CodeTab>
```ts copy{2,15-20}
import { serial, pgTable, integer, text } from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";

export const users = pgTable('users', {
	id: serial('id').primaryKey(),
	name: text('name'),
});

export const posts = pgTable('posts', {
	id: serial('id').primaryKey(),
	content: text('content'),
	authorId: integer('author_id').notNull(),
});

export const postsRelations = relations(posts, ({ one }) => ({
	author: one(users, {
		fields: [posts.authorId],
		references: [users.id],
	}),
}));
```
</CodeTab>
</CodeTabs>


## 示例 2
<CodeTabs items={["index.ts", "schema.ts"]}>
<CodeTab>
```ts
import { users, posts } from './schema.ts';

async function main() {
    const db = drizzle(...);
    await seed(db, { users, posts }).refine(() => ({
        posts: {
            count: 2,
            with: {
                users: 3,
            },
        },
    }));
}
main();

```
</CodeTab>

<CodeTab>
```ts
import { serial, pgTable, integer, text } from "drizzle-orm/pg-core";

export const users = pgTable('users', {
	id: serial('id').primaryKey(),
	name: text('name'),
});

export const posts = pgTable('posts', {
	id: serial('id').primaryKey(),
	content: text('content'),
	authorId: integer('author_id').notNull().references(() => users.id),
});
```
</CodeTab>
</CodeTabs>

运行上述填充脚本会导致错误。

```
Error: "posts" 表没有引用 "users" 表，或者
你没有在 seed 函数的 schema 中包含一对多关系。
你不能在 users.with 对象中指定 "posts" 作为参数。
```

<Callout title='为什么？'>
你的 schema 中 `posts` 表引用了 `users` 表， 
```ts copy{7}
.
.
.
export const posts = pgTable('posts', {
	id: serial('id').primaryKey(),
	content: text('content'),
	authorId: integer('author_id').notNull().references(() => users.id),
});
```
换句话说，你有一个一对多关系，其中一个用户可以拥有多篇帖子。

但是，在填充脚本中，你试图为一篇帖子生成三个（多个）用户。
```ts
posts: {
    count: 2,
    with: {
        users: 3,
    },
},
```
</Callout>

解决此错误，你可以将填充脚本修改为如下：
<Section>
```ts copy{6-9}
import { users, posts, postsRelations } from './schema.ts';

async function main() {
    const db = drizzle(...);
    await seed(db, { users, posts, postsRelations }).refine(() => ({
        users: {
            count: 2,
            with: {
                posts: 3,
            },
        },
    }));
}
main();

// 运行上述填充脚本将填充数据库如下值
```

```mdx
`users`

| id |   name   |   
| -- | -------- |
|  1 | 'Melanny' | 
|  2 | 'Elvera' |

`posts`

| id |        content        | author_id |   
| -- | --------------------- | --------- |
|  1 | 'tf02gUXb0LZIdEg6SL'  |     2     |
|  2 | 'j15YdT7Sma'          |     2     |
|  3 | 'LwwvWtLLAZzIpk'      |     1     |
|  4 | 'mgyUnBKSrQw'         |     1     |
|  5 | 'CjAJByKIqilHcPjkvEw' |     2     |
|  6 | 'S5g0NzXs'            |     1     |
```
</Section>

## 示例 3

<CodeTabs items={["index.ts", "schema.ts"]}>
<CodeTab>
```ts copy{6-9}
import { users } from './schema.ts';

async function main() {
    const db = drizzle(...);
    await seed(db, { users }).refine(() => ({
        users: {
            count: 2,
            with: {
                users: 3,
            },
        },
    }));
}
main();

```
</CodeTab>

<CodeTab>
```ts
import { serial, pgTable, integer, text } from "drizzle-orm/pg-core";
import type { AnyPgColumn } from "drizzle-orm/pg-core";

export const users = pgTable('users', {
	id: serial('id').primaryKey(),
	name: text('name'),
    reportsTo: integer('reports_to').references((): AnyPgColumn => users.id),
});
```
</CodeTab>
</CodeTabs>

运行上述填充脚本会导致错误。

```
Error: "users" 表存在自引用。
你不能在 users.with 对象中指定 "users" 作为参数。
```

<Callout title='为什么？'>
你的 schema 中 `users` 表引用了自己，
```ts copy{7}
.
.
.
export const users = pgTable('users', {
	id: serial('id').primaryKey(),
	name: text('name'),
    reportsTo: integer('reports_to').references((): AnyPgColumn => users.id),
});
```
换句话说，你有一个一对一关系，一个用户只能对应一个用户。

但是，在填充脚本中，你试图为一个用户生成三个（多个）用户，这是不可能的。
```ts
users: {
    count: 2,
    with: {
        users: 3,
    },
},
```
</Callout>

Source: https://drizzle.zhcndoc.com/docs/seeding-with-partially-exposed-tables


import IsSupportedChipGroup from "@mdx/IsSupportedChipGroup.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from '@mdx/CodeTabs.astro';
import CodeTab from '@mdx/CodeTab.astro';
import Callout from '@mdx/Callout.astro';

<IsSupportedChipGroup chips={{PostgreSQL: true, MySQL: true, SQLite: true}}/>

<Prerequisites>
- 了解如何使用 [PostgreSQL](/docs/get-started-postgresql), [MySQL](/docs/get-started-mysql) 或 [SQLite](/docs/get-started-sqlite)
- 熟悉 [Drizzle Seed](/docs/seed-overview)
</Prerequisites>

## 示例 1
假设您尝试使用以下所示的填充脚本和模式来填充数据库。
<CodeTabs items={["index.ts", "schema.ts"]}>
<CodeTab>
```ts
import { bloodPressure } from './schema.ts';

async function main() {
  const db = drizzle(...);
  await seed(db, { bloodPressure });
}
main();

```
</CodeTab>

<CodeTab>
```ts copy {10}
import { serial, pgTable, integer, doublePrecision } from "drizzle-orm/pg-core";

export const users = pgTable("users", {
    id: serial("id").primaryKey(),
});

export const bloodPressure = pgTable("bloodPressure", {
	bloodPressureId: serial().primaryKey(),
	pressure: doublePrecision(),
	userId: integer().references(() => users.id).notNull(),
})
```
</CodeTab>
</CodeTabs>
如果 `bloodPressure` 表在 `userId` 列上有非空约束，那么运行填充脚本将导致错误。

```
错误: 列 'userId' 具有非空约束，
并且您没有为 'bloodPressure' 表中的 'userId' 列指定外键表。
```

<Callout title='这意味着什么？'>
这意味着我们不能在 `userId` 列中填充 Null 值，因为该列有非空约束。
此外，您没有将 `users` 表暴露给 `seed` 函数的模式，因此我们无法生成 `users.id` 来填充 `userId` 列。
</Callout>

此时，您有几种选择来解决错误：
- 您可以删除 `userId` 列上的非空约束；
- 您可以将 `users` 表暴露给 `seed` 函数的模式
```ts 
await seed(db, { bloodPressure, users });
```
- 您可以 [改进](/docs/guides/seeding-with-partially-exposed-tables#refining-the-userid-column-generator) `userId` 列生成器；

## 示例 2

<CodeTabs items={["index.ts", "schema.ts"]}>
<CodeTab>
```ts
import { bloodPressure } from './schema.ts';

async function main() {
  const db = drizzle(...);
  await seed(db, { bloodPressure });
}
main();

```
</CodeTab>

<CodeTab>
```ts copy {10}
import { serial, pgTable, integer, doublePrecision } from "drizzle-orm/pg-core";

export const users = pgTable("users", {
    id: serial("id").primaryKey(),
});

export const bloodPressure = pgTable("bloodPressure", {
	bloodPressureId: serial().primaryKey(),
	pressure: doublePrecision(),
	userId: integer().references(() => users.id),
})
```
</CodeTab>
</CodeTabs>

通过运行上述填充脚本，您将看到一个警告
```
在 'bloodPressure' 表中的 'userId' 列将填充 Null 值
因为您既没有为 'userId' 列指定外键表
也没有为 'userId' 列提供函数的细化。
```
<Callout title='这意味着什么？'>
这意味着您既没有将 `users` 表提供给 `seed` 函数的模式，也没有改进 `userId` 列生成器。 
因此，`userId` 列将填充 Null 值。
</Callout>
然后您将有两个选择：
- 如果您可以接受用 Null 值填充 `userId` 列，可以忽略该警告；

- 否则，您可以 [改进](/docs/guides/seeding-with-partially-exposed-tables#refining-the-userid-column-generator) `userId` 列生成器。 

## 改进 `userId` 列生成器
这样做需要 `users` 表中已经有类似于 1 和 2 的 ID。
<CodeTabs items={["index.ts"]}>
<CodeTab>
```ts copy {8}
import { bloodPressure } from './schema.ts';

async function main() {
  const db = drizzle(...);
  await seed(db, { bloodPressure }).refine((funcs) => ({
    bloodPressure: {
      columns: {
        userId: funcs.valuesFromArray({ values: [1, 2] })
      }
    }
  }));
}
main();

```
</CodeTab>
</CodeTabs>

Source: https://drizzle.zhcndoc.com/docs/select-parent-rows-with-at-least-one-related-child-row


import Prerequisites from "@mdx/Prerequisites.astro";
import IsSupportedChipGroup from "@mdx/IsSupportedChipGroup.astro";
import CodeTabs from '@mdx/CodeTabs.astro';
import CodeTab from '@mdx/CodeTab.astro';
import Section from "@mdx/Section.astro";

<IsSupportedChipGroup chips={{PostgreSQL: true, MySQL: true, SQLite: true}}/>

<Prerequisites>
- 开始使用 [PostgreSQL](/docs/get-started-postgresql), [MySQL](/docs/get-started-mysql) 和 [SQLite](/docs/get-started-sqlite)
- [选择语句](/docs/select) 和 [从子查询选择](/docs/select#select-from-subquery)
- [内部连接](/docs/joins#inner-join)
- [过滤运算符](/docs/operators) 和 [exists函数](/docs/operators#exists)
</Prerequisites>

本指南演示如何选择父行，条件是至少有一个相关的子行。下面是模式定义和相应的数据库数据示例：

```ts copy
import { integer, pgTable, serial, text } from 'drizzle-orm/pg-core';

export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  email: text('email').notNull(),
});

export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  title: text('title').notNull(),
  content: text('content').notNull(),
  userId: integer('user_id').notNull().references(() => users.id),
});
```

<CodeTabs items={["users.db", "posts.db"]}>
  <CodeTab>
    ```plaintext
    +----+------------+----------------------+
    | id |    name    |        email         |
    +----+------------+----------------------+
    |  1 | John Doe   | john_doe@email.com   |
    +----+------------+----------------------+
    |  2 | Tom Brown  | tom_brown@email.com  |
    +----+------------+----------------------+
    |  3 | Nick Smith | nick_smith@email.com |
    +----+------------+----------------------+
    ```
  </CodeTab>

  <CodeTab>
    ```plaintext
    +----+--------+-----------------------------+---------+
    | id | title  |          content            | user_id |
    +----+--------+-----------------------------+---------+
    |  1 | Post 1 | This is the text of post 1  |       1 |
    +----+--------+-----------------------------+---------+
    |  2 | Post 2 | This is the text of post 2  |       1 |
    +----+--------+-----------------------------+---------+
    |  3 | Post 3 | This is the text of post 3  |       3 |
    +----+--------+-----------------------------+---------+
    ```
  </CodeTab>
</CodeTabs>

要选择至少有一个相关子行的父行并检索子数据，可以使用 `.innerJoin()` 方法：

<Section>
  ```ts copy {12}
  import { eq } from 'drizzle-orm';
  import { users, posts } from './schema';

  const db = drizzle(...);

  await db
    .select({
      user: users,
      post: posts,
    })
    .from(users)
    .innerJoin(posts, eq(users.id, posts.userId));
    .orderBy(users.id);
  ```

  ```sql
  select users.*, posts.* from users
    inner join posts on users.id = posts.user_id
    order by users.id;
  ```

  ```ts
  // 结果数据，ID为2的用户没有，因为他没有帖子
  [
    {
      user: { id: 1, name: 'John Doe', email: 'john_doe@email.com' },
      post: {
        id: 1,
        title: 'Post 1',
        content: 'This is the text of post 1',
        userId: 1
      }
    },
    {
      user: { id: 1, name: 'John Doe', email: 'john_doe@email.com' },
      post: {
        id: 2,
        title: 'Post 2',
        content: 'This is the text of post 2',
        userId: 1
      }
    },
    {
      user: { id: 3, name: 'Nick Smith', email: 'nick_smith@email.com' },
      post: {
        id: 3,
        title: 'Post 3',
        content: 'This is the text of post 3',
        userId: 3
      }
    }
  ]
  ```
</Section>

要仅选择至少有一个相关子行的父行，可以使用带有 `exists()` 函数的子查询，如下所示：

<Section>
```ts copy {8}
import { eq, exists, sql } from 'drizzle-orm';

const sq = db
  .select({ id: sql`1` })
  .from(posts)
  .where(eq(posts.userId, users.id));

await db.select().from(users).where(exists(sq));
```

```sql
select * from users where exists (select 1 from posts where posts.user_id = users.id);
```

```ts
// 结果数据，ID为2的用户没有，因为他没有帖子
[
  { id: 1, name: 'John Doe', email: 'john_doe@email.com' },
  { id: 3, name: 'Nick Smith', email: 'nick_smith@email.com' }
]
```
</Section>


Source: https://drizzle.zhcndoc.com/docs/timestamp-default-value


import Section from "@mdx/Section.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from '@mdx/CodeTabs.astro';
import CodeTab from '@mdx/CodeTab.astro';

<Prerequisites>
- 开始使用 [PostgreSQL](/docs/get-started-postgresql)、[MySQL](/docs/get-started-mysql) 和 [SQLite](/docs/get-started-sqlite)
- 了解 [PostgreSQL](/docs/column-types/pg)、[MySQL](/docs/column-types/mysql) 和 [SQLite](/docs/column-types/sqlite) 的列数据类型
- [sql 操作符](/docs/sql)
</Prerequisites>

### PostgreSQL

要在 PostgreSQL 中将当前时间戳设置为默认值，可以使用 `defaultNow()` 方法或带有 `now()` 函数的 `sql` 操作符，该函数返回当前日期和时间（带有时区）：

<Section>
```ts copy {6,9}
import { sql } from 'drizzle-orm';
import { timestamp, pgTable, serial } from 'drizzle-orm/pg-core';

export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  timestamp1: timestamp('timestamp1').notNull().defaultNow(),
  timestamp2: timestamp('timestamp2', { mode: 'string' })
    .notNull()
    .default(sql`now()`),
});
```

```sql
CREATE TABLE IF NOT EXISTS "users" (
	"id" serial PRIMARY KEY NOT NULL,
	"timestamp1" timestamp DEFAULT now() NOT NULL,
	"timestamp2" timestamp DEFAULT now() NOT NULL
);
```
</Section>

`mode` 选项定义了应用程序中如何处理值。使用 `string` 模式的值在应用程序中被视为 `string`，但在数据库中存储为时间戳。

<Section>
```plaintext
// 存储在数据库中的数据
+----+----------------------------+----------------------------+
| id |         timestamp1         |         timestamp2         |
+----+----------------------------+----------------------------+
| 1  | 2024-04-11 14:14:28.038697 | 2024-04-11 14:14:28.038697 |
+----+----------------------------+----------------------------+
```

```ts
// 应用程序返回的数据
[
  {
    id: 1,
    timestamp1: 2024-04-11T14:14:28.038Z, // 日期对象
    timestamp2: '2024-04-11 14:14:28.038697' // 字符串
  }
]
```
</Section>

要在 PostgreSQL 中将 Unix 时间戳设置为默认值，可以使用 `sql` 操作符和 `extract(epoch from now())` 函数，该函数返回自 `1970-01-01 00:00:00 UTC` 以来的秒数：

<Section>
```ts copy {8}
import { sql } from 'drizzle-orm';
import { integer, pgTable, serial } from 'drizzle-orm/pg-core'

export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  timestamp: integer('timestamp')
    .notNull()
    .default(sql`extract(epoch from now())`),
});
```

```sql
CREATE TABLE IF NOT EXISTS "users" (
	"id" serial PRIMARY KEY NOT NULL,
	"timestamp" integer DEFAULT extract(epoch from now()) NOT NULL
);
```

```plaintext
// 存储在数据库中的数据
+----+------------+
| id | timestamp  |
+----+------------+
|  1 | 1712846784 |
+----+------------+
```

```ts
// 应用程序返回的数据
[ 
  { 
    id: 1, 
    timestamp: 1712846784 // 数字
  } 
]
```
</Section>


### MySQL

要在 MySQL 中将当前时间戳设置为默认值，可以使用 `defaultNow()` 方法或带有 `now()` 函数的 `sql` 操作符，该函数返回当前日期和时间 `(YYYY-MM-DD HH-MM-SS)`：

<Section>
```ts copy {6,9,12}
import { sql } from 'drizzle-orm';
import { mysqlTable, serial, timestamp } from 'drizzle-orm/mysql-core';

export const users = mysqlTable('users', {
  id: serial('id').primaryKey(),
  timestamp1: timestamp('timestamp1').notNull().defaultNow(),
  timestamp2: timestamp('timestamp2', { mode: 'string' })
    .notNull()
    .default(sql`now()`),
  timestamp3: timestamp('timestamp3', { fsp: 3 }) // 小数秒部分
    .notNull()
    .default(sql`now(3)`),
});
```

```sql
CREATE TABLE `users` (
	`id` serial AUTO_INCREMENT NOT NULL,
	`timestamp1` timestamp NOT NULL DEFAULT now(),
	`timestamp2` timestamp NOT NULL DEFAULT now(),
	`timestamp3` timestamp(3) NOT NULL DEFAULT now(3),
	CONSTRAINT `users_id` PRIMARY KEY(`id`)
);
```
</Section>

`fsp` 选项定义在时间戳中包含的小数秒数。默认值为 `0`。  
`mode` 选项定义了应用程序中如何处理值。使用 `string` 模式的值在应用程序中被视为 `string`，但在数据库中存储为时间戳。

<Section>
```plaintext
// 存储在数据库中的数据
+----+---------------------+---------------------+-------------------------+
| id | timestamp1          | timestamp2          | timestamp3              |
+----+---------------------+---------------------+-------------------------+
|  1 | 2024-04-11 15:24:53 | 2024-04-11 15:24:53 | 2024-04-11 15:24:53.236 |
+----+---------------------+---------------------+-------------------------+
```

```ts
// 应用程序返回的数据
[
  {
    id: 1,
    timestamp1: 2024-04-11T15:24:53.000Z, // 日期对象
    timestamp2: '2024-04-11 15:24:53', // 字符串
    timestamp3: 2024-04-11T15:24:53.236Z // 日期对象
  }
]
```
</Section>

要在 MySQL 中将 Unix 时间戳设置为默认值，可以使用 `sql` 操作符和 `unix_timestamp()` 函数，该函数返回自 `1970-01-01 00:00:00 UTC` 以来的秒数：

<Section>
```ts copy {8}
import { sql } from 'drizzle-orm';
import { mysqlTable, serial, int } from 'drizzle-orm/mysql-core';

export const users = mysqlTable('users', {
  id: serial('id').primaryKey(),
  timestamp: int('timestamp')
    .notNull()
    .default(sql`(unix_timestamp())`),
});
```

```sql
CREATE TABLE `users` (
	`id` serial AUTO_INCREMENT NOT NULL,
	`timestamp` int NOT NULL DEFAULT (unix_timestamp()),
	CONSTRAINT `users_id` PRIMARY KEY(`id`)
);
```

```plaintext
// 存储在数据库中的数据
+----+------------+
| id | timestamp  |
+----+------------+
|  1 | 1712847986 |
+----+------------+
```

```ts
// 应用程序返回的数据
[ 
  { 
    id: 1, 
    timestamp: 1712847986 // 数字
  } 
]
```
</Section>

### SQLite

要在 SQLite 中将当前时间戳设置为默认值，可以使用带有 `current_timestamp` 常量的 `sql` 操作符，该常量返回当前 UTC 日期和时间的文本表示 `(YYYY-MM-DD HH:MM:SS)`：

<Section>
```ts copy {8}
import { sql } from 'drizzle-orm';
import { integer, sqliteTable, text } from 'drizzle-orm/sqlite-core';

export const users = sqliteTable('users', {
  id: integer('id').primaryKey(),
  timestamp: text('timestamp')
    .notNull()
    .default(sql`(current_timestamp)`),
});
```

```sql
CREATE TABLE `users` (
	`id` integer PRIMARY KEY NOT NULL,
	`timestamp` text DEFAULT (current_timestamp) NOT NULL
);
```

```plaintext
// 存储在数据库中的数据
+----+---------------------+
| id | timestamp           |
+----+---------------------+
|  1 | 2024-04-11 15:40:43 |
+----+---------------------+
```

```ts
// 应用程序返回的数据
[
  {
    id: 1,
    timestamp: '2024-04-11 15:40:43' // 字符串
  }
]
```
</Section>

要在 SQLite 中将 Unix 时间戳设置为默认值，可以使用 `sql` 操作符和 `unixepoch()` 函数，该函数返回自 `1970-01-01 00:00:00 UTC` 以来的秒数：

<Section>
```ts copy {8,11,14}
import { sql } from 'drizzle-orm';
import { integer, sqliteTable } from 'drizzle-orm/sqlite-core';

export const users = sqliteTable('users', {
  id: integer('id').primaryKey(),
  timestamp1: integer('timestamp1', { mode: 'timestamp' })
    .notNull()
    .default(sql`(unixepoch())`),
  timestamp2: integer('timestamp2', { mode: 'timestamp_ms' })
    .notNull()
    .default(sql`(unixepoch() * 1000)`),
  timestamp3: integer('timestamp3', { mode: 'number' })
    .notNull()
    .default(sql`(unixepoch())`),
});
```

```sql
CREATE TABLE `users` (
	`id` integer PRIMARY KEY NOT NULL,
	`timestamp1` integer DEFAULT (unixepoch()) NOT NULL,
	`timestamp2` integer DEFAULT (unixepoch() * 1000) NOT NULL,
	`timestamp3` integer DEFAULT (unixepoch()) NOT NULL
);
```
</Section>

`mode` 选项定义了应用程序中如何处理值。在应用程序中，使用 `timestamp` 和 `timestamp_ms` 模式的值被视为 `Date` 对象，但在数据库中存储为整数。  
它们之间的区别在于，`timestamp` 处理秒，而 `timestamp_ms` 处理毫秒。

<Section>
```plaintext
// 存储在数据库中的数据
+------------+------------+---------------+------------+
| id         | timestamp1 | timestamp2    | timestamp3 |
+------------+------------+---------------+------------+
| 1          | 1712835640 | 1712835640000 | 1712835640 |
+------------+------------+---------------+------------+
```

```ts
// 应用程序返回的数据
[
  {
    id: 1,
    timestamp1: 2024-04-11T11:40:40.000Z, // 日期对象
    timestamp2: 2024-04-11T11:40:40.000Z, // 日期对象
    timestamp3: 1712835640 // 数字
  }
]
```
</Section>


Source: https://drizzle.zhcndoc.com/docs/toggling-a-boolean-field

import Section from "@mdx/Section.astro";
import IsSupportedChipGroup from "@mdx/IsSupportedChipGroup.astro";
import Prerequisites from "@mdx/Prerequisites.astro";

<IsSupportedChipGroup chips={{PostgreSQL: true, MySQL: true, SQLite: true}}/>

<Prerequisites>
- 开始使用 [PostgreSQL](/docs/get-started-postgresql), [MySQL](/docs/get-started-mysql) 和 [SQLite](/docs/get-started-sqlite)
- [更新语句](/docs/update)
- [过滤器](/docs/operators) 和 [非操作符](/docs/operators#not)
- [MySQL](/docs/column-types/mysql#boolean) 和 [SQLite](/docs/column-types/sqlite#boolean) 中的布尔数据类型
</Prerequisites>

要切换列值，可以使用 `update().set()` 方法，如下所示：

<Section>
```tsx copy {8}
import { eq, not } from 'drizzle-orm';

const db = drizzle(...);

await db
  .update(table)
  .set({
    isActive: not(table.isActive),
  })
  .where(eq(table.id, 1));
```

```sql
update "table" set "is_active" = not "is_active" where "id" = 1;
```
</Section>

请注意，MySQL 和 SQLite 中没有布尔类型。
MySQL 使用 tinyint(1)。
SQLite 使用整数 0（false）和 1（true）。 


Source: https://drizzle.zhcndoc.com/docs/unique-case-insensitive-email


import Section from "@mdx/Section.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from '@mdx/CodeTabs.astro';
import CodeTab from '@mdx/CodeTab.astro';
import Callout from '@mdx/Callout.astro';

<Prerequisites>
- 开始使用 [PostgreSQL](/docs/get-started-postgresql)、[MySQL](/docs/get-started-mysql) 和 [SQLite](/docs/get-started-sqlite)
- [索引](/docs/indexes-constraints#indexes)
- [插入语句](/docs/insert) 和 [查询方法](/docs/select)
- [SQL 操作符](/docs/sql)
- 你应该有 `drizzle-orm@0.31.0` 和 `drizzle-kit@0.22.0` 或更高版本。
</Prerequisites>

### PostgreSQL

要在 PostgreSQL 中使用 Drizzle 实现唯一且不区分大小写的 `email` 处理，你可以在小写的 `email` 列上创建一个唯一索引。这样可以确保 `email` 在不考虑大小写的情况下是唯一的。

Drizzle 提供了简单灵活的 API，让你可以轻松使用 SQL 类似的语法创建这样的索引：
<CodeTabs items={["schema.ts", "migration.sql"]}>
  <CodeTab>
  ```ts copy {12,13}
  import { SQL, sql } from 'drizzle-orm';
  import { AnyPgColumn, pgTable, serial, text, uniqueIndex } from 'drizzle-orm/pg-core';

  export const users = pgTable(
    'users',
    {
      id: serial('id').primaryKey(),
      name: text('name').notNull(),
      email: text('email').notNull(),
    },
    (table) => [
         // uniqueIndex('emailUniqueIndex').on(sql`lower(${table.email})`),
      uniqueIndex('emailUniqueIndex').on(lower(table.email)),
    ],
  );

  // 自定义小写函数
  export function lower(email: AnyPgColumn): SQL {
    return sql`lower(${email})`;
  }
  ```
  </CodeTab>
  ```sql
  CREATE TABLE IF NOT EXISTS "users" (
	"id" serial PRIMARY KEY NOT NULL,
	"name" text NOT NULL,
	"email" text NOT NULL
  );
  --> statement-breakpoint
  CREATE UNIQUE INDEX IF NOT EXISTS "emailUniqueIndex" ON "users" USING btree (lower("email"));
  ```
</CodeTabs>

这就是你如何使用 `lower` 函数按 `email` 选择用户：

<Section>
```ts copy {10}
import { eq } from 'drizzle-orm';
import { lower, users } from './schema';

const db = drizzle(...);

const findUserByEmail = async (email: string) => {
  return await db
    .select()
    .from(users)
    .where(eq(lower(users.email), email.toLowerCase()));
};
```

```sql
select * from "users" where lower(email) = 'john@email.com';
```
</Section>

### MySQL

在 MySQL 中，字符串比较的默认排序规则是大小写不敏感的，这意味着在进行像搜索或比较字符串的 SQL 查询时，字符的大小写不会影响结果。然而，由于排序规则设置可能会有所不同并且可能配置为大小写敏感，因此我们将明确确保 `email` 在不考虑大小写的情况下是唯一的，方法是对小写的 `email` 列创建唯一路径。

Drizzle 提供了简单灵活的 API，让你可以轻松使用 SQL 类似的语法创建这样的索引：
<CodeTabs items={["schema.ts", "migration.sql"]}>
  <CodeTab>
  ```ts copy {12,13}
  import { SQL, sql } from 'drizzle-orm';
  import { AnyMySqlColumn, mysqlTable, serial, uniqueIndex, varchar } from 'drizzle-orm/mysql-core';

  export const users = mysqlTable(
    'users',
    {
      id: serial('id').primaryKey(),
      name: varchar('name', { length: 255 }).notNull(),
      email: varchar('email', { length: 255 }).notNull(),
    },
    (table) => [
         // uniqueIndex('emailUniqueIndex').on(sql`(lower(${table.email}))`),
      uniqueIndex('emailUniqueIndex').on(lower(table.email)),
    ]
  );

  // 自定义小写函数
  export function lower(email: AnyMySqlColumn): SQL {
    return sql`(lower(${email}))`;
  }
  ```
  </CodeTab>
  ```sql
  CREATE TABLE `users` (
	  `id` serial AUTO_INCREMENT NOT NULL,
	  `name` varchar(255) NOT NULL,
	  `email` varchar(255) NOT NULL,
	  CONSTRAINT `users_id` PRIMARY KEY(`id`),
	  CONSTRAINT `emailUniqueIndex` UNIQUE((lower(`email`)))
  );
  ```
</CodeTabs>

<Callout type="warning">
函数索引在 MySQL 8.0.13 版本开始得到支持。对于正确的语法，表达式应被括号括起来，例如，`(lower(column))`。
</Callout>

这就是你如何使用 `lower` 函数按 `email` 选择用户：

<Section>
```ts copy {10}
import { eq } from 'drizzle-orm';
import { lower, users } from './schema';

const db = drizzle(...);

const findUserByEmail = async (email: string) => {
  return await db
    .select()
    .from(users)
    .where(eq(lower(users.email), email.toLowerCase()));
};
```

```sql
select * from `users` where lower(email) = 'john@email.com';
```
</Section>

### SQLite

要在 SQLite 中使用 Drizzle 实现唯一且不区分大小写的 `email` 处理，你可以在小写的 `email` 列上创建一个唯一索引。这样可以确保 `email` 在不考虑大小写的情况下是唯一的。

Drizzle 提供了简单灵活的 API，让你可以轻松创建这样的索引，使用 SQL 类似的语法：

<CodeTabs items={["schema.ts", "migration.sql"]}>
  <CodeTab>
  ```ts copy {12,13}
  import { SQL, sql } from 'drizzle-orm';
  import { AnySQLiteColumn, integer, sqliteTable, text, uniqueIndex } from 'drizzle-orm/sqlite-core';

  export const users = sqliteTable(
    'users',
    {
      id: integer('id').primaryKey(),
      name: text('name').notNull(),
      email: text('email').notNull(),
    },
    (table) => [
      // uniqueIndex('emailUniqueIndex').on(sql`lower(${table.email})`),
      uniqueIndex('emailUniqueIndex').on(lower(table.email)),
    ]
  );

  // 自定义小写函数
  export function lower(email: AnySQLiteColumn): SQL {
    return sql`lower(${email})`;
  }
  ```
  </CodeTab>
  ```sql
  CREATE TABLE `users` (
	  `id` integer PRIMARY KEY NOT NULL,
	  `name` text NOT NULL,
	  `email` text NOT NULL
  );
  --> statement-breakpoint
  CREATE UNIQUE INDEX `emailUniqueIndex` ON `users` (lower(`email`));
  ```
</CodeTabs>

这就是你如何使用 `lower` 函数按 `email` 选择用户：

<Section>
```ts copy {10}
import { eq } from 'drizzle-orm';
import { lower, users } from './schema';

const db = drizzle(...);

const findUserByEmail = async (email: string) => {
  return await db
    .select()
    .from(users)
    .where(eq(lower(users.email), email.toLowerCase()));
};
```

```sql
select * from "users" where lower(email) = 'john@email.com';
```
</Section>


Source: https://drizzle.zhcndoc.com/docs/update-many-with-different-value


import Section from "@mdx/Section.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import IsSupportedChipGroup from "@mdx/IsSupportedChipGroup.astro";

<IsSupportedChipGroup chips={{PostgreSQL: true, MySQL: true, SQLite: true}}/>

<Prerequisites>
- 开始使用 [PostgreSQL](/docs/get-started-postgresql), [MySQL](/docs/get-started-mysql) 和 [SQLite](/docs/get-started-sqlite)
- [更新语句](/docs/update)
- [过滤器](/docs/operators) 和 [sql 操作符](/docs/sql)
</Prerequisites>

要在一个请求中实现对多个行进行不同值的更新，可以使用 `sql` 操作符结合 `case` 语句和 `.update().set()` 方法，如下所示：

<Section>
```ts {26, 29, 32, 36, 38, 40}
import { SQL, inArray, sql } from 'drizzle-orm';
import { users } from './schema';

const db = drizzle(...);

const inputs = [
  {
    id: 1,
    city: 'New York',
  },
  {
    id: 2,
    city: 'Los Angeles',
  },
  {
    id: 3,
    city: 'Chicago',
  },
];

// 确保 inputs 数组不为空
if (inputs.length === 0) {
  return;
}

const sqlChunks: SQL[] = [];
const ids: number[] = [];

sqlChunks.push(sql`(case`);

for (const input of inputs) {
  sqlChunks.push(sql`when ${users.id} = ${input.id} then ${input.city}`);
  ids.push(input.id);
}

sqlChunks.push(sql`end)`);

const finalSql: SQL = sql.join(sqlChunks, sql.raw(' '));

await db.update(users).set({ city: finalSql }).where(inArray(users.id, ids));
```

```sql
update users set "city" = 
  (case when id = 1 then 'New York' when id = 2 then 'Los Angeles' when id = 3 then 'Chicago' end)
where id in (1, 2, 3)
```
</Section>


Source: https://drizzle.zhcndoc.com/docs/upsert


import Section from "@mdx/Section.astro";
import IsSupportedChipGroup from "@mdx/IsSupportedChipGroup.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from '@mdx/CodeTabs.astro';
import CodeTab from '@mdx/CodeTab.astro';

<IsSupportedChipGroup chips={{PostgreSQL: true, MySQL: true, SQLite: true}}/>

<Prerequisites>
- 开始使用 [PostgreSQL](/docs/get-started-postgresql), [MySQL](/docs/get-started-mysql) 和 [SQLite](/docs/get-started-sqlite)
- [插入语句](/docs/insert), [onConflictDoUpdate 方法](/docs/insert#on-conflict-do-update) 和 [onDuplicateKeyUpdate 方法](/docs/insert#on-duplicate-key-update)
- [复合主键](/docs/indexes-constraints#composite-primary-key)
- [sql 操作符](/docs/sql)
</Prerequisites>

### PostgreSQL 和 SQLite

要在 PostgreSQL 和 SQLite 中实现上插入查询（跳到 [MySQL](/docs/guides/upsert#mysql)），可以使用 `.onConflictDoUpdate()` 方法：

<Section>
```ts copy {8,9,10,11}
import { users } from './schema';

const db = drizzle(...);

await db
  .insert(users)
  .values({ id: 1, name: 'John' })
  .onConflictDoUpdate({
    target: users.id,
    set: { name: 'Super John' },
  });
```

```sql
insert into users ("id", "name") values (1, 'John')
  on conflict ("id") do update set name = 'Super John';
```
</Section>

要在 PostgreSQL 和 SQLite 中一次查询上插入多行，您可以使用 `sql 操作符` 和 `excluded` 关键词。`excluded` 是一个特殊引用，指的是因冲突而未插入的提议行。

您可以这样做：

<CodeTabs items={["index.ts", "schema.ts"]}>
  <CodeTab>
    ```ts copy {21,24}
    import { sql } from 'drizzle-orm';
    import { users } from './schema';

    const values = [
      {
        id: 1,
        lastLogin: new Date(),
      },
      {
        id: 2,
        lastLogin: new Date(Date.now() + 1000 * 60 * 60),
      },
      {
        id: 3,
        lastLogin: new Date(Date.now() + 1000 * 60 * 120),
      },
    ];

    await db
      .insert(users)
      .values(values)
      .onConflictDoUpdate({
        target: users.id,
        set: { lastLogin: sql.raw(`excluded.${users.lastLogin.name}`) },
      });
    ```

    ```sql
    insert into users ("id", "last_login") 
      values 
        (1, '2024-03-15T22:29:06.679Z'),
        (2, '2024-03-15T23:29:06.679Z'),
        (3, '2024-03-16T00:29:06.679Z')
      on conflict ("id") do update set last_login = excluded.last_login;
    ```
  </CodeTab>
  ```ts copy
  import { pgTable, serial, timestamp } from 'drizzle-orm/pg-core';

  export const users = pgTable('users', {
    id: serial('id').primaryKey(),
    lastLogin: timestamp('last_login', { mode: 'date' }).notNull(),
  });
  ```
</CodeTabs>

Drizzle 提供了简单而灵活的 API，可以让您轻松创建自定义解决方案。这是如何针对 PostgreSQL 和 SQLite 中由于冲突而更新特定列的自定义函数：

<CodeTabs items={["index.ts", "schema.ts"]}>
  <CodeTab>
    ```ts copy {43,46}
    import { SQL, getTableColumns, sql } from 'drizzle-orm';
    import { PgTable } from 'drizzle-orm/pg-core';
    import { SQLiteTable } from 'drizzle-orm/sqlite-core';
    import { users } from './schema';

    const buildConflictUpdateColumns = <
      T extends PgTable | SQLiteTable,
      Q extends keyof T['_']['columns']
    >(
      table: T,
      columns: Q[],
    ) => {
      const cls = getTableColumns(table);

      return columns.reduce((acc, column) => {
        const colName = cls[column].name;
        acc[column] = sql.raw(`excluded.${colName}`);

        return acc;
      }, {} as Record<Q, SQL>);
    };

    const values = [
      {
        id: 1,
        lastLogin: new Date(),
        active: true,
      },
      {
        id: 2,
        lastLogin: new Date(Date.now() + 1000 * 60 * 60),
        active: true,
      },
      {
        id: 3,
        lastLogin: new Date(Date.now() + 1000 * 60 * 120),
        active: true,
      },
    ];

    await db
      .insert(users)
      .values(values)
      .onConflictDoUpdate({
        target: users.id,
        set: buildConflictUpdateColumns(users, ['lastLogin', 'active']),
      });
    ```

    ```sql
    insert into users ("id", "last_login", "active")
    values
      (1, '2024-03-16T15:44:41.141Z', true),
      (2, '2024-03-16T16:44:41.141Z', true),
      (3, '2024-03-16T17:44:41.141Z', true)
    on conflict ("id") do update set last_login = excluded.last_login, active = excluded.active;
    ```
  </CodeTab>
  ```ts copy
  import { boolean, pgTable, serial, timestamp } from 'drizzle-orm/pg-core';

  export const users = pgTable('users', {
    id: serial('id').primaryKey(),
    lastLogin: timestamp('last_login', { mode: 'date' }).notNull(),
    active: boolean('active').notNull().default(false),
  });
  ```
</CodeTabs>

这是如何在 PostgreSQL 和 SQLite 中使用多个目标实现上插入查询：

<Section>
```ts copy {8}
import { sql } from 'drizzle-orm';
import { inventory } from './schema';

await db
  .insert(inventory)
  .values({ warehouseId: 1, productId: 1, quantity: 100 })
  .onConflictDoUpdate({
    target: [inventory.warehouseId, inventory.productId], // 复合主键
    set: { quantity: sql`${inventory.quantity} + 100` }, // 将现有数量增加 100
  });
```

```sql
insert into inventory ("warehouse_id", "product_id", "quantity") values (1, 1, 100)
  on conflict ("warehouse_id","product_id") do update set quantity = quantity + 100;
```
</Section>

如果您想在 `update` 语句中实现带有 `where` 条件的上插入查询，可以使用 `setWhere` 属性在 `onConflictDoUpdate` 方法中：

<CodeTabs items={["index.ts", "schema.ts"]}>
  <CodeTab>
  ```ts copy {25,26,27,28}
  import { or, sql } from 'drizzle-orm';
  import { products } from './schema';

  const data = {
    id: 1,
    title: 'Phone',
    price: '999.99',
    stock: 10,
    lastUpdated: new Date(),
  };

  const excludedPrice = sql.raw(`excluded.${products.price.name}`);
  const excludedStock = sql.raw(`excluded.${products.stock.name}`);

  await db
    .insert(products)
    .values(data)
    .onConflictDoUpdate({
      target: products.id,
      set: {
        price: excludedPrice,
        stock: excludedStock,
        lastUpdated: sql.raw(`excluded.${products.lastUpdated.name}`)
      },
      setWhere: or(
        sql`${products.stock} != ${excludedStock}`,
        sql`${products.price} != ${excludedPrice}`
      ),
    });
  ```

  ```sql
  insert into products ("id", "title", "stock", "price", "last_updated")
    values (1, 'Phone', 10, '999.99', '2024-04-29T21:56:55.563Z')
    on conflict ("id") do update
    set stock = excluded.stock, price = excluded.price, last_updated = excluded.last_updated
    where (stock != excluded.stock or price != excluded.price);
  ```
  </CodeTab>

  ```ts copy
  import { integer, numeric, pgTable, serial, text, timestamp } from 'drizzle-orm/pg-core';

  export const products = pgTable('products', {
    id: serial('id').primaryKey(),
    title: text('title').notNull(),
    stock: integer('stock').notNull(),
    price: numeric('price', { precision: 10, scale: 2 }).notNull(),
    lastUpdated: timestamp('last_updated').notNull().defaultNow(),
  });
  ```
</CodeTabs>


如果您想更新所有列，除了特定的一列，您可以像这样保留先前的值：

<Section>
```ts copy {16}
import { sql } from 'drizzle-orm';
import { users } from './schema';

const data = {
  id: 1,
  name: 'John',
  email: 'john@email.com',
  age: 29,
};

await db
  .insert(users)
  .values(data)
  .onConflictDoUpdate({
    target: users.id,
    set: { ...data, email: sql`${users.email}` }, // 保持 email 不变
});
```

```sql
insert into users ("id", "name", "email", "age") values (1, 'John', 'john@email.com', 29)
  on conflict ("id") do update set id = 1, name = 'John', email = email, age = 29;
```
</Section>

### MySQL

要在 MySQL 中实现上插入查询，可以使用 `.onDuplicateKeyUpdate()` 方法。MySQL 会根据主键和唯一索引自动确定冲突目标，如果有任何唯一索引冲突，将会更新该行。

您可以这样做：

<Section>
```ts copy {4}
await db
  .insert(users)
  .values({ id: 1, name: 'John' })
  .onDuplicateKeyUpdate({ set: { name: 'Super John' } });
```

```sql
insert into users (`id`, `first_name`) values (1, 'John')
  on duplicate key update first_name = 'Super John';
```
</Section>

要在 MySQL 中一次查询上插入多行，您可以使用 `sql 操作符` 和 `values()` 函数。`values()` 函数指的是如果没有发生重复键冲突，则将插入的列的值。  

<CodeTabs items={["index.ts", "schema.ts"]}>
  <CodeTab>
    ```ts copy {21,24}
    import { sql } from 'drizzle-orm';
    import { users } from './schema';

    const values = [
      {
        id: 1,
        lastLogin: new Date(),
      },
      {
        id: 2,
        lastLogin: new Date(Date.now() + 1000 * 60 * 60),
      },
      {
        id: 3,
        lastLogin: new Date(Date.now() + 1000 * 60 * 120),
      },
    ];

    await db
      .insert(users)
      .values(values)
      .onDuplicateKeyUpdate({
        set: {
          lastLogin: sql`values(${users.lastLogin})`,
        },
      });
    ```

    ```sql
    insert into users (`id`, `last_login`)
      values
        (1, '2024-03-15 23:08:27.025'),
        (2, '2024-03-15 00:08:27.025'),
        (3, '2024-03-15 01:08:27.025')
      on duplicate key update last_login = values(last_login);
    ```
  </CodeTab>
  ```ts copy
  import { mysqlTable, serial, timestamp } from 'drizzle-orm/mysql-core';

  export const users = mysqlTable('users', {
    id: serial('id').primaryKey(),
    lastLogin: timestamp('last_login', { mode: 'date' }).notNull(),
  });
  ```
</CodeTabs>

Drizzle 提供了简单而灵活的 API，可以让您轻松创建自定义解决方案。这是如何针对 MySQL 中由于冲突而更新特定列的自定义函数：

<CodeTabs items={["index.ts", "schema.ts"]}>
  <CodeTab>
    ```ts copy {36,38}
    import { SQL, getTableColumns, sql } from 'drizzle-orm';
    import { MySqlTable } from 'drizzle-orm/mysql-core';
    import { users } from './schema';

    const buildConflictUpdateColumns = <T extends MySqlTable, Q extends keyof T['_']['columns']>(
      table: T,
      columns: Q[],
    ) => {
      const cls = getTableColumns(table);
      return columns.reduce((acc, column) => {
        acc[column] = sql`values(${cls[column]})`;
        return acc;
      }, {} as Record<Q, SQL>);
    };

    const values = [
      {
        id: 1,
        lastLogin: new Date(),
        active: true,
      },
      {
        id: 2,
        lastLogin: new Date(Date.now() + 1000 * 60 * 60),
        active: true,
      },
      {
        id: 3,
        lastLogin: new Date(Date.now() + 1000 * 60 * 120),
        active: true,
      },
    ];

    await db
      .insert(users)
      .values(values)
      .onDuplicateKeyUpdate({
        set: buildConflictUpdateColumns(users, ['lastLogin', 'active']),
      });
    ```

    ```sql
    insert into users (`id`, `last_login`, `active`)
      values
        (1, '2024-03-16 15:23:28.013', true),
        (2, '2024-03-16 16:23:28.013', true),
        (3, '2024-03-16 17:23:28.013', true)
      on duplicate key update last_login = values(last_login), active = values(active);
    ```
  </CodeTab>
  ```ts copy
  import { boolean, mysqlTable, serial, timestamp } from 'drizzle-orm/mysql-core';

  export const users = mysqlTable('users', {
    id: serial('id').primaryKey(),
    lastLogin: timestamp('last_login', { mode: 'date' }).notNull(),
    active: boolean('active').notNull().default(false),
  });
  ```
</CodeTabs>

如果您想更新所有列，除了特定的一列，您可以像这样保留先前的值：

<Section>
```ts copy {15}
import { sql } from 'drizzle-orm';
import { users } from './schema';

const data = {
  id: 1,
  name: 'John',
  email: 'john@email.com',
  age: 29,
};

await db
  .insert(users)
  .values(data)
  .onDuplicateKeyUpdate({
    set: { ...data, email: sql`${users.email}` }, // 保持 email 不变
});
```

```sql
insert into users (`id`, `name`, `email`, `age`) values (1, 'John', 'john@email.com', 29)
  on duplicate key update id = 1, name = 'John', email = email, age = 29;
```
</Section>


Source: https://drizzle.zhcndoc.com/docs/vector-similarity-search


import Section from "@mdx/Section.astro";
import IsSupportedChipGroup from "@mdx/IsSupportedChipGroup.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import CodeTabs from '@mdx/CodeTabs.astro';
import CodeTab from '@mdx/CodeTab.astro';
import Npm from "@mdx/Npm.astro";

<Prerequisites>
- 从 [PostgreSQL](/docs/get-started-postgresql) 开始入门。
- [选择语句](/docs/select)
- [索引](/docs/indexes-constraints#indexes)
- [sql 操作符](/docs/sql)
- [pgvector 扩展](/docs/extensions/pg#pg_vector)
- [Drizzle kit](/docs/kit-overview)
- 您应该安装 `openai` [包](https://www.npmjs.com/package/openai) 来生成嵌入。 
<Npm>
  openai
</Npm>
- 您应该安装 `drizzle-orm@0.31.0` 和 `drizzle-kit@0.22.0` 或更高版本。  
</Prerequisites>

要在 PostgreSQL 中使用 Drizzle ORM 实现向量相似性搜索，您可以使用 `pgvector` 扩展。这个扩展提供了一系列函数来处理向量并进行相似性搜索。

目前，Drizzle 并不会自动创建扩展，因此您需要手动创建。创建一个空的迁移文件并添加 SQL 查询：

<Section>
```bash
npx drizzle-kit generate --custom
```

```sql
CREATE EXTENSION vector;
```
</Section>

为了进行相似性搜索，您需要创建一个包含向量列的表，并在该列上创建一个 `HNSW` 或 `IVFFlat` 索引以提高性能：

<CodeTabs items={["schema.ts", "migration.sql"]}>
  <CodeTab>
  ```ts copy {10, 13}
  import { index, pgTable, serial, text, vector } from 'drizzle-orm/pg-core';

  export const guides = pgTable(
    'guides',
    {
      id: serial('id').primaryKey(),
      title: text('title').notNull(),
      description: text('description').notNull(),
      url: text('url').notNull(),
      embedding: vector('embedding', { dimensions: 1536 }),
    },
    (table) => [
      index('embeddingIndex').using('hnsw', table.embedding.op('vector_cosine_ops')),
    ]
  );
  ```
  </CodeTab>
  ```sql
  CREATE TABLE IF NOT EXISTS "guides" (
    "id" serial PRIMARY KEY NOT NULL,
    "title" text NOT NULL,
    "description" text NOT NULL,
    "url" text NOT NULL,
    "embedding" vector(1536)
  );
  --> statement-breakpoint
  CREATE INDEX IF NOT EXISTS "embeddingIndex" ON "guides" USING hnsw (embedding vector_cosine_ops);
  ```
</CodeTabs>

`embedding` 列用于存储指南描述的向量嵌入。向量嵌入是一种对某些数据的表示。它将不同类型的数据转换为语言模型可以处理的通用格式（向量）。这使我们能够执行数学运算，例如测量两个向量之间的距离，以确定两个数据项是多么相似或不同。

在此示例中，我们将使用 `OpenAI` 模型生成描述的 [嵌入](https://platform.openai.com/docs/guides/embeddings)：
```ts copy
import OpenAI from 'openai';

const openai = new OpenAI({
  apiKey: process.env['OPENAI_API_KEY'],
});

export const generateEmbedding = async (value: string): Promise<number[]> => {
  const input = value.replaceAll('\n', ' ');

  const { data } = await openai.embeddings.create({
    model: 'text-embedding-ada-002',
    input,
  });

  return data[0].embedding;
};
```

要通过嵌入搜索相似的指南，您可以使用 `gt` 和 `sql` 操作符与 `cosineDistance` 函数来计算 `embedding` 列与生成的嵌入之间的相似性：

<Section>
```ts copy {10,15,16}
import { cosineDistance, desc, gt, sql } from 'drizzle-orm';
import { generateEmbedding } from './embedding';
import { guides } from './schema';

const db = drizzle(...);

const findSimilarGuides = async (description: string) => {
  const embedding = await generateEmbedding(description);

  const similarity = sql<number>`1 - (${cosineDistance(guides.embedding, embedding)})`;

  const similarGuides = await db
    .select({ name: guides.title, url: guides.url, similarity })
    .from(guides)
    .where(gt(similarity, 0.5))
    .orderBy((t) => desc(t.similarity))
    .limit(4);

  return similarGuides;
};
```

```ts
const description = '使用 Drizzle ORM 的各种平台指南';

const similarGuides = await findSimilarGuides(description);
```

```json
[
  {
    name: 'Drizzle with Turso',
    url: '/docs/tutorials/drizzle-with-turso',
    similarity: 0.8642314333984994
  },
  {
    name: 'Drizzle with Supabase Database',
    url: '/docs/tutorials/drizzle-with-supabase',
    similarity: 0.8593631126014918
  },
  {
    name: 'Drizzle with Neon Postgres',
    url: '/docs/tutorials/drizzle-with-neon',
    similarity: 0.8541051184461372
  },
  {
    name: 'Drizzle with Vercel Edge Functions',
    url: '/docs/tutorials/drizzle-with-vercel-edge-functions',
    similarity: 0.8481551084241092
  }
]
```
</Section>


Source: https://drizzle.zhcndoc.com/docs/indexes-constraints

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Callout from '@mdx/Callout.astro';
import Section from '@mdx/Section.astro';

# 索引与约束

## 约束

SQL 约束是对表列施加的规则。它们用于防止无效数据被输入到数据库中。

这确保了数据库中数据的准确性和可靠性。

### 默认值

`DEFAULT` 子句指定在执行 `INSERT` 时，如果用户未提供值，则使用的列的默认值。
如果列定义中没有附加显式的 `DEFAULT` 子句，
则该列的默认值为 `NULL`。

显式的 `DEFAULT` 子句可以指定默认值为 `NULL`、
字符串常量、BLOB 常量、带符号数字或任何用括号括起来的常量表达式。

<Tabs items={['PostgreSQL', 'MySQL', 'SQLite', 'SingleStore']}>
  <Tab>
    <Section>
    ```typescript
    import { sql } from "drizzle-orm";
    import { integer, uuid, pgTable } from "drizzle-orm/pg-core";

    const table = pgTable('table', {
      integer1: integer('integer1').default(42),
      integer2: integer('integer2').default(sql`'42'::integer`),
      uuid1: uuid('uuid1').defaultRandom(),
      uuid2: uuid('uuid2').default(sql`gen_random_uuid()`),
    });
    ```

    ```sql
    CREATE TABLE IF NOT EXISTS "table" (
      "integer1" integer DEFAULT 42,
      "integer2" integer DEFAULT '42'::integer,
      "uuid1" uuid DEFAULT gen_random_uuid(),
      "uuid2" uuid DEFAULT gen_random_uuid()
    );
    ```
    </Section>

  </Tab> 
  <Tab>
    <Section>
    ```typescript
    import { sql } from "drizzle-orm";
    import { int, time, mysqlTable } from "drizzle-orm/mysql-core";
    
    const table = mysqlTable("table", {
      int: int("int").default(42),
      time: time("time").default(sql`cast("14:06:10" AS TIME)`),
    });
    ```
    ```sql
    CREATE TABLE `table` (
      `int` int DEFAULT 42,
      `time` time DEFAULT cast("14:06:10" AS TIME)
    );
    ```
    </Section>
  </Tab>
  <Tab>
    <Section>
    ```typescript
    import { sql } from "drizzle-orm";
    import { integer, sqliteTable } from "drizzle-orm/sqlite-core";

    const table = sqliteTable('table', {
      int1: integer('int1').default(42),
      int2: integer('int2').default(sql`(abs(42))`)
    });

    ```
    ```sql
    CREATE TABLE `table` (
      `int1` integer DEFAULT 42
      `int2` integer DEFAULT (abs(42))
    );
    ```
    </Section>

  </Tab>
  <Tab>
    <Section>
    ```typescript
    import { sql } from "drizzle-orm";
    import { int, time, singlestoreTable } from "drizzle-orm/singlestore-core";
    
    const table = singlestoreTable("table", {
      int: int("int").default(42),
      time: time("time").default(sql`cast("14:06:10" AS TIME)`),
    });
    ```
    ```sql
    CREATE TABLE `table` (
      `int` int DEFAULT 42,
      `time` time DEFAULT cast("14:06:10" AS TIME)
    );
    ```
    </Section>
  </Tab>
</Tabs>

### 非空

默认情况下，列可以包含 **NULL** 值。`NOT NULL` 约束强制列 **不** 接受 **NULL** 值。

这强制字段始终包含一个值，这意味着您不能插入新记录，
或在不向该字段添加值的情况下更新记录。

<Tabs items={['PostgreSQL', 'MySQL', 'SQLite', 'SingleStore']}>
  <Tab>
    <Section>
      ```typescript copy
      import { integer, pgTable } from "drizzle-orm/pg-core";

      const table = pgTable('table', {
        integer: integer('integer').notNull(),
      });
      ```

      ```sql
      CREATE TABLE IF NOT EXISTS "table" (
        "integer" integer NOT NULL
      );
      ```
    </Section>

  </Tab> 
  <Tab>
    <Section>
      ```typescript
      import { int, mysqlTable } from "drizzle-orm/mysql-core";

      const table = mysqlTable('table', {
        int: int('int').notNull(),
      });
      ```

      ```sql
      CREATE TABLE `table` (
        `int` int NOT NULL
      );
      ```
    </Section>

  </Tab>
  <Tab>
   <Section>
      ```typescript copy
      const table = sqliteTable('table', { 
        numInt: integer('numInt').notNull() 
      });
      ```

      ```sql
      CREATE TABLE table (
        `numInt` integer NOT NULL
      );
      ```
    </Section>

  </Tab>
    <Tab>
    <Section>
      ```typescript
      import { int, singlestoreTable } from "drizzle-orm/singlestore-core";

      const table = singlestoreTable('table', {
        int: int('int').notNull(),
      });
      ```

      ```sql
      CREATE TABLE `table` (
        `int` int NOT NULL
      );
      ```
    </Section>

  </Tab>
</Tabs>

### 唯一

`UNIQUE` 约束确保列中的所有值都是不同的。

`UNIQUE` 和 `PRIMARY KEY` 约束都为列或列集提供了唯一性的保证。

`PRIMARY KEY` 约束自动具有 `UNIQUE` 约束。

<Callout type="info" emoji="ℹ️">
  每个表可以有多个 `UNIQUE` 约束，但每个表只能有一个 `PRIMARY KEY` 约束。
</Callout>

<Tabs items={['PostgreSQL', 'MySQL', 'SQLite', 'SingleStore']}>
  <Tab>
    <Section>
      ```typescript copy
      import { integer, text, unique, pgTable } from "drizzle-orm/pg-core";

      export const user = pgTable('user', {
        id: integer('id').unique(),
      });

      export const table = pgTable('table', {
        id: integer('id').unique('custom_name'),
      });

      export const composite = pgTable('composite_example', {
        id: integer('id'),
        name: text('name'),
      }, (t) => [
        unique().on(t.id, t.name),
        unique('custom_name').on(t.id, t.name)
      ]);

      // In Postgres 15.0+ NULLS NOT DISTINCT is available
      // This example demonstrates both available usages
      export const userNulls = pgTable('user_nulls_example', {
        id: integer('id').unique("custom_name", { nulls: 'not distinct' }),
      }, (t) => [
        unique().on(t.id).nullsNotDistinct()
      ]);
      ```

      ```sql
      CREATE TABLE IF NOT EXISTS "composite_example" (
	      "id" integer,
        "name" text,
        CONSTRAINT "composite_example_id_name_unique" UNIQUE("id","name"),
        CONSTRAINT "custom_name" UNIQUE("id","name")
      );

      CREATE TABLE IF NOT EXISTS "table" (
      	"id" integer,
      	CONSTRAINT "custom_name" UNIQUE("id")
      );

      CREATE TABLE IF NOT EXISTS "user" (
      	"id" integer,
      	CONSTRAINT "user_id_unique" UNIQUE("id")
      );

      CREATE TABLE IF NOT EXISTS "user_nulls_example" (
        "id" integer,
        CONSTRAINT "custom_name" UNIQUE NULLS NOT DISTINCT("id"),
        CONSTRAINT "user_nulls_example_id_unique" UNIQUE NULLS NOT DISTINCT("id")
      );
      ```
    </Section>

  </Tab> 
  <Tab>
    <Section>
      ```typescript
      import { int, varchar, unique, mysqlTable } from "drizzle-orm/mysql-core";

      export const user = mysqlTable('user', {
        id: int('id').unique(),
      });

      export const table = mysqlTable('table', {
        id: int('id').unique('custom_name'),
      });

      export const composite = mysqlTable('composite_example', {
        id: int('id'),
        name: varchar('name', { length: 256 }),
      }, (t) => [
        unique().on(t.id, t.name),
        unique('custom_name').on(t.id, t.name)
      ]);
      ```

      ```sql
      CREATE TABLE `user` (
      	`id` int,
      	CONSTRAINT `user_id_unique` UNIQUE(`id`)
      );

      CREATE TABLE `table` (
      	`id` int,
      	CONSTRAINT `custom_name` UNIQUE(`id`)
      );

      CREATE TABLE `composite_example` (
        `id` int,
        `name` varchar(256),
        CONSTRAINT `composite_example_id_name_unique` UNIQUE(`id`,`name`),
        CONSTRAINT `custom_name` UNIQUE(`id`,`name`)
      );
      ```
    </Section>

  </Tab>
  <Tab>
   <Section>
      ```typescript copy
      import { int, text, unique, sqliteTable } from "drizzle-orm/sqlite-core";

      export const user = sqliteTable('user', {
        id: int('id').unique(),
      });

      export const table = sqliteTable('table', {
        id: int('id').unique('custom_name'),
      });

      export const composite = sqliteTable('composite_example', {
        id: int('id'),
        name: text('name'),
      }, (t) => [
        unique().on(t.id, t.name),
        unique('custom_name').on(t.id, t.name)
      ]);
      ```

      ```sql
      CREATE TABLE `user` (
	      `id` integer
      );

      CREATE TABLE `table` (
      	`id` integer
      );

      CREATE TABLE `composite_example` (
      	`id` integer,
      	`name` text
      );

      CREATE UNIQUE INDEX `composite_example_id_name_unique` ON `composite_example` (`id`,`name`);
      CREATE UNIQUE INDEX `custom_name` ON `composite_example` (`id`,`name`);
      CREATE UNIQUE INDEX `custom_name` ON `table` (`id`);
      CREATE UNIQUE INDEX `user_id_unique` ON `user` (`id`);
      ```
    </Section>

  </Tab>
    <Tab>
    <Section>
      ```typescript
      import { int, varchar, unique, singlestoreTable } from "drizzle-orm/singlestore-core";

      export const user = singlestoreTable('user', {
        id: int('id').unique(),
      });

      export const table = singlestoreTable('table', {
        id: int('id').unique('custom_name'),
      });

      export const composite = singlestoreTable('composite_example', {
        id: int('id'),
        name: varchar('name', { length: 256 }),
      }, (t) => [
        unique().on(t.id, t.name),
        unique('custom_name').on(t.id, t.name)
      ]);
      ```

      ```sql
      CREATE TABLE `user` (
      	`id` int,
      	CONSTRAINT `user_id_unique` UNIQUE(`id`)
      );

      CREATE TABLE `table` (
      	`id` int,
      	CONSTRAINT `custom_name` UNIQUE(`id`)
      );

      CREATE TABLE `composite_example` (
        `id` int,
        `name` varchar(256),
        CONSTRAINT `composite_example_id_name_unique` UNIQUE(`id`,`name`),
        CONSTRAINT `custom_name` UNIQUE(`id`,`name`)
      );
      ```
    </Section>

  </Tab>
</Tabs>

### 检查

`CHECK` 约束用于限制可以放置在列中的值范围。

如果您在列上定义 `CHECK` 约束，它将仅允许该列的某些值。

如果您在表上定义 `CHECK` 约束，它可以根据行中其他列的值限制某些列的值。

<Tabs items={['PostgreSQL', 'MySQL', 'SQLite', 'SingleStore']}>
  <Tab>
    <Section>
      ```typescript copy
      import { sql } from "drizzle-orm";
      import { check, integer, pgTable, text, uuid } from "drizzle-orm/pg-core";

      export const users = pgTable(
        "users",
        {
          id: uuid().defaultRandom().primaryKey(),
          username: text().notNull(),
          age: integer(),
        },
        (table) => [
          check("age_check1", sql`${table.age} > 21`),
        ]
      );
      ```
      ```sql
      CREATE TABLE IF NOT EXISTS "users" (
	      "id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	      "username" text NOT NULL,
	      "age" integer,
	      CONSTRAINT "age_check1" CHECK ("users"."age" > 21)
      );
      ```
    </Section>

  </Tab> 
  <Tab>
    <Section>
      ```typescript copy
      import { sql } from "drizzle-orm";
      import { check, int, mysqlTable, text } from "drizzle-orm/mysql-core";

      export const users = mysqlTable(
        "users",
        {
          id: int().primaryKey(),
          username: text().notNull(),
          age: int(),
        },
        (table) => [
          check("age_check1", sql`${table.age} > 21`)
        ]
      );
      ```
      ```sql
      CREATE TABLE `users` (
	      `id` int NOT NULL,
	      `username` text NOT NULL,
	      `age` int,
	      CONSTRAINT `users_id` PRIMARY KEY(`id`),
	      CONSTRAINT `age_check1` CHECK(`users`.`age` > 21)
      );
      ```
    </Section>
  </Tab>
  <Tab>
   <Section>
      ```typescript copy
      import { sql } from "drizzle-orm";
      import { check, int, sqliteTable, text } from "drizzle-orm/sqlite-core";

      export const users = sqliteTable(
        "users",
        {
          id: int().primaryKey(),
          username: text().notNull(),
          age: int(),
        },
        (table) => [
          check("age_check1", sql`${table.age} > 21`)
        ]
      );
      ```
      ```sql
      CREATE TABLE `users` (
	      `id` integer PRIMARY KEY NOT NULL,
	      `username` text NOT NULL,
	      `age` integer,
	      CONSTRAINT "age_check1" CHECK("users"."age" > 21)
      );
      ```
    </Section>

  </Tab>
  <Tab>
    Currently not supported in SingleStore
  </Tab>
</Tabs>

### 主键

`PRIMARY KEY` 约束唯一标识表中的每条记录。
主键必须包含 `UNIQUE` 值，并且不能包含 `NULL` 值。

一个表只能有 **一个** 主键；在该表中，这个主键可以由单个或多个列（字段）组成。

<Tabs items={['PostgreSQL', 'MySQL', 'SQLite', 'SingleStore']}>
  <Tab>
    <Section>
      ```typescript copy
      import { serial, text, pgTable } from "drizzle-orm/pg-core";

      const user = pgTable('user', {
        id: serial('id').primaryKey(),
      });

      const table = pgTable('table', {
        id: text('cuid').primaryKey(),
      });
      ```

      ```sql
      CREATE TABLE IF NOT EXISTS "user" (
        "id" serial PRIMARY KEY
      );

      CREATE TABLE IF NOT EXISTS "table" (
        "cuid" text PRIMARY KEY
      );
      ```
    </Section>

  </Tab> 
  <Tab>
    <Section>
      ```typescript
      import { int, text, mysqlTable } from "drizzle-orm/mysql-core";

      export const user = mysqlTable("user", {
        id: int("id").autoincrement().primaryKey(),
      })

      export const table = mysqlTable("table", {
        cuid: text("cuid").primaryKey(),
      })
      ```

      ```sql
      CREATE TABLE `user` (
        `id` int AUTO_INCREMENT PRIMARY KEY NOT NULL
      );

      CREATE TABLE `table` (
        `cuid` text PRIMARY KEY NOT NULL
      );
      ```
    </Section>

  </Tab>
  <Tab>
   <Section>
      ```typescript copy
      import { integer, sqliteTable } from "drizzle-orm/sqlite-core";

      export const user = sqliteTable("user", {
        id: integer("id").primaryKey(),
      })

      export const pet = sqliteTable("pet", {
        id: integer("id").primaryKey(),
      })
      ```

      ```sql
      CREATE TABLE `user` (
        `id` integer PRIMARY KEY AUTOINCREMENT NOT NULL
      );

      CREATE TABLE `pet` (
        `id` integer PRIMARY KEY AUTOINCREMENT
      )
      ```
    </Section>

  </Tab>
  <Tab>
    <Section>
      ```typescript
      import { int, text, singlestoreTable } from "drizzle-orm/singlestore-core";

      export const user = singlestoreTable("user", {
        id: int("id").autoincrement().primaryKey(),
      })

      export const table = singlestoreTable("table", {
        cuid: text("cuid").primaryKey(),
      })
      ```

      ```sql
      CREATE TABLE `user` (
        `id` int AUTO_INCREMENT PRIMARY KEY NOT NULL
      );

      CREATE TABLE `table` (
        `cuid` text PRIMARY KEY NOT NULL
      );
      ```
    </Section>

  </Tab>
</Tabs>

### 复合主键

就像 `PRIMARY KEY`，复合主键通过多个字段唯一标识表中的每条记录。

Drizzle ORM 提供了一个独立的 `primaryKey` 操作符来实现这一点：
<Tabs items={['PostgreSQL', 'MySQL', 'SQLite', 'SingleStore']}>
  <Tab>
    <Section>
      ```typescript copy {18, 19}
      import { serial, text, integer, primaryKey, pgTable } from "drizzle-orm/pg-core";

      export const user = pgTable("user", {
        id: serial("id").primaryKey(),
        name: text("name"),
      });

      export const book = pgTable("book", {
        id: serial("id").primaryKey(),
        name: text("name"),
      });

      export const booksToAuthors = pgTable("books_to_authors", {
        authorId: integer("author_id"),
        bookId: integer("book_id"),
      }, (table) => [
        primaryKey({ columns: [table.bookId, table.authorId] }),
        // Or PK with custom name
        primaryKey({ name: 'custom_name', columns: [table.bookId, table.authorId] }),
      ]);
      ```

      ```sql {6, 9}
      ...

      CREATE TABLE IF NOT EXISTS "books_to_authors" (
        "author_id" integer,
        "book_id" integer,
        PRIMARY KEY("book_id","author_id")
      );

      ALTER TABLE "books_to_authors" ADD CONSTRAINT "custom_name" PRIMARY KEY("book_id","author_id");
      ```
    </Section>

  </Tab> 
  <Tab>
    <Section>
      ```typescript {18, 19}
      import { int, text, primaryKey, mysqlTable } from "drizzle-orm/mysql-core";

      export const user = mysqlTable("user", {
        id: int("id").autoincrement().primaryKey(),
        name: text("name"),
      });

      export const book = mysqlTable("book", {
        id: int("id").autoincrement().primaryKey(),
        name: text("name"),
      });

      export const booksToAuthors = mysqlTable("books_to_authors", {
        authorId: int("author_id"),
        bookId: int("book_id"),
      }, (table) => [
        primaryKey({ columns: [table.bookId, table.authorId] }),
        // Or PK with custom name
        primaryKey({ name: 'custom_name', columns: [table.bookId, table.authorId] })
      ]);
      ```

      ```sql {6}
      ...

      CREATE TABLE `books_to_authors` (
        `author_id` int,
        `book_id` int,
        PRIMARY KEY(`book_id`,`author_id`)
      );
      ```
    </Section>

  </Tab>
  <Tab>
   <Section>
      ```typescript copy {18, 19}
      import { integer, text, primaryKey, sqliteTable} from "drizzle-orm/sqlite-core";

      export const user = sqliteTable("user", {
        id: integer("id").primaryKey({ autoIncrement: true }),
        name: text("name"),
      });

      export const book = sqliteTable("book", {
        id: integer("id").primaryKey({ autoIncrement: true }),
        name: text("name"),
      });

      export const bookToAuthor = sqliteTable("book_to_author", {
        authorId: integer("author_id"),
        bookId: integer("book_id"),
      }, (table) => [
        primaryKey({ columns: [table.bookId, table.authorId] }),
        // Or PK with custom name
        primaryKey({ name: 'custom_name', columns: [table.bookId, table.authorId] })
      ]);
      ```
      ```sql {6}
      ...

      CREATE TABLE `book_to_author` (
        `author_id` integer,
        `book_id` integer,
        PRIMARY KEY(`book_id`, `author_id`)
      );
      ```
    </Section>

  </Tab>
  <Tab>
    <Section>
      ```typescript {18, 19}
      import { int, text, primaryKey, mysqlTable } from "drizzle-orm/singlestore-core";

      export const user = singlestoreTable("user", {
        id: int("id").autoincrement().primaryKey(),
        name: text("name"),
      });

      export const book = singlestoreTable("book", {
        id: int("id").autoincrement().primaryKey(),
        name: text("name"),
      });

      export const booksToAuthors = singlestoreTable("books_to_authors", {
        authorId: int("author_id"),
        bookId: int("book_id"),
      }, (table) => [
        primaryKey({ columns: [table.bookId, table.authorId] }),
        // Or PK with custom name
        primaryKey({ name: 'custom_name', columns: [table.bookId, table.authorId] }),
      ]);
      ```

      ```sql {6}
      ...

      CREATE TABLE `books_to_authors` (
        `author_id` int,
        `book_id` int,
        PRIMARY KEY(`book_id`,`author_id`)
      );
      ```
    </Section>

  </Tab>
</Tabs>

### 外键

`FOREIGN KEY` 约束用于防止破坏表之间链接的操作。
`FOREIGN KEY` 是一个字段（或字段集合），在一个表中引用另一个表的 `PRIMARY KEY`。
包含外键的表称为子表，包含主键的表称为引用表或父表。

Drizzle ORM 提供了几种声明外键的方法。
您可以在列声明语句中声明它们：

<Tabs items={['PostgreSQL', 'MySQL', 'SQLite', 'SingleStore']}>
  <Tab>
    ```typescript copy {11}
    import { serial, text, integer, pgTable } from "drizzle-orm/pg-core";

    export const user = pgTable("user", {
      id: serial("id"),
      name: text("name"),
    });

    export const book = pgTable("book", {
      id: serial("id"),
      name: text("name"),
      authorId: integer("author_id").references(() => user.id)
    });
    ```

  </Tab>
  <Tab>
    ```typescript {11}
    import { int, text, mysqlTable } from "drizzle-orm/mysql-core";

    export const user = mysqlTable("user", {
      id: int("id").primaryKey().autoincrement(),
      name: text("name"),
    });

    export const book = mysqlTable("book", {
      id: int("id").primaryKey().autoincrement(),
      name: text("name"),
      authorId: int("author_id").references(() => user.id)
    });
    ```

  </Tab>
  <Tab>
    ```typescript {11}
    import { integer, text, sqliteTable } from "drizzle-orm/sqlite-core";

    export const user = sqliteTable("user", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      name: text("name"),
    });

    export const book = sqliteTable("book", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      name: text("name"),
      authorId: integer("author_id").references(() => user.id)
    });
    ```

  </Tab>
  <Tab>
    当前在 SingleStore 中不支持
  </Tab>
</Tabs>

如果您想进行自引用，由于 TypeScript 的限制，您必须显式设置引用回调的返回类型或使用独立的 `foreignKey` 操作符。

<Tabs items={['PostgreSQL', 'MySQL', 'SQLite', 'SingleStore']}>
  <Tab>
    ```typescript copy {6,16-19}
    import { serial, text, integer, foreignKey, pgTable, AnyPgColumn } from "drizzle-orm/pg-core";

    export const user = pgTable("user", {
      id: serial("id"),
      name: text("name"),
      parentId: integer("parent_id").references((): AnyPgColumn => user.id)
    });

    // or
    export const user = pgTable("user", {
      id: serial("id"),
      name: text("name"),
      parentId: integer("parent_id"),
    }, (table) => [
      foreignKey({
        columns: [table.parentId],
        foreignColumns: [table.id],
        name: "custom_fk"
      })
    ]);
    ```

  </Tab>
  <Tab>
    ```typescript {6,16-19}
    import { int, text, foreignKey, AnyMySqlColumn, mysqlTable } from "drizzle-orm/mysql-core";

    export const user = mysqlTable("user", {
      id: int("id").primaryKey().autoincrement(),
      name: text("name"),
      parentId: int("parent_id").references((): AnyMySqlColumn => user.id),
    });

    // or
    export const user = mysqlTable("user", {
      id: int("id").primaryKey().autoincrement(),
      name: text("name"),
      parentId: int("parent_id")
    }, (table) => [
      foreignKey({
        columns: [table.parentId],
        foreignColumns: [table.id],
        name: "custom_fk"
      })
    ]);
    ```

  </Tab>
  <Tab>
    ```typescript {6,16-19}
    import { integer, text, foreignKey, sqliteTable, AnySQLiteColumn } from "drizzle-orm/sqlite-core";

    export const user = sqliteTable("user", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      name: text("name"),
      parentId: integer("parent_id").references((): AnySQLiteColumn => user.id)
    });

    //or
    export const user = sqliteTable("user", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      name: text("name"),
      parentId: integer("parent_id"),
    }, (table) => [
      foreignKey({
        columns: [table.parentId],
        foreignColumns: [table.id],
        name: "custom_fk"
      })
    ]);
    ```

  </Tab>
  <Tab>
    当前在 SingleStore 中不支持
  </Tab>
</Tabs>
要声明多列外键，可以使用专用的 `foreignKey` 操作符：
<Tabs items={['PostgreSQL', 'MySQL', 'SQLite', 'SingleStore']}>
  <Tab>
    ```typescript copy {4-5,14-15,18-21}
    import { serial, text, foreignKey, pgTable, AnyPgColumn } from "drizzle-orm/pg-core";

    export const user = pgTable("user", {
      firstName: text("firstName"),
      lastName: text("lastName"),
    }, (table) => [
      primaryKey({ columns: [table.firstName, table.lastName]})
    ]);

    export const profile = pgTable("profile", {
      id: serial("id").primaryKey(),
      userFirstName: text("user_first_name"),
      userLastName: text("user_last_name"),
    }, (table) => [
      foreignKey({
        columns: [table.userFirstName, table.userLastName],
        foreignColumns: [user.firstName, user.lastName],
        name: "custom_fk"
      })
    ])
    ```

  </Tab>
  <Tab>
    ```typescript copy {4-5,14-15,18-21}
    import { int, text, primaryKey, foreignKey, mysqlTable, AnyMySqlColumn } from "drizzle-orm/mysql-core";

    export const user = mysqlTable("user", {
      firstName: text("firstName"),
      lastName: text("lastName"),
    }, (table) => [
      primaryKey({ columns: [table.firstName, table.lastName]})
    ]);

    export const profile = mysqlTable("profile", {
      id: int("id").autoincrement().primaryKey(),
      userFirstName: text("user_first_name"),
      userLastName: text("user_last_name"),
    }, (table) => [
      foreignKey({
        columns: [table.userFirstName, table.userLastName],
        foreignColumns: [user.firstName, user.lastName],
        name: "custom_name"
      })
    ]);
    ```

  </Tab>
  <Tab>
    ```typescript {4-5,14-15,18-21}
    import { integer, text, primaryKey, foreignKey, sqliteTable, AnySQLiteColumn } from "drizzle-orm/sqlite-core";

    export const user = sqliteTable("user", {
      firstName: text("firstName"),
      lastName: text("lastName"),
    }, (table) => [
      primaryKey({ columns: [table.firstName, table.lastName]})
    ]);

    export const profile = sqliteTable("profile", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      userFirstName: text("user_first_name"),
      userLastName: text("user_last_name"),
    }, (table) => [
      foreignKey({
        columns: [table.userFirstName, table.userLastName],
        foreignColumns: [user.firstName, user.lastName],
        name: "custom_name"
      })
    ]);
    ```

  </Tab>
  <Tab>
    当前在 SingleStore 中不支持
  </Tab>
</Tabs>

## 索引

Drizzle ORM 提供了 `index` 和 `unique index` 声明的 API：

<Tabs items={['PostgreSQL', 'MySQL', 'SQLite', 'SingleStore']}>
  <Tab>
    <Section>
    ```typescript copy {9-10}
    import { serial, text, index, uniqueIndex, pgTable } from "drizzle-orm/pg-core";

    export const user = pgTable("user", {
      id: serial("id").primaryKey(),
      name: text("name"),
      email: text("email"),
    }, (table) => [
      index("name_idx").on(table.name),
      uniqueIndex("email_idx").on(table.email)
    ]);
    ```
    ```sql {5-6}
    CREATE TABLE "user" (
      ...
    );

    CREATE INDEX "name_idx" ON "user" ("name");
    CREATE UNIQUE INDEX "email_idx" ON "user" ("email");
    ```
    </Section>
    <Callout type="warning" emoji="⚠️">
      对于 `drizzle-kit@0.22.0` 和 `drizzle-orm@0.31.0` 之前的版本，`drizzle-kit` 仅支持索引 `name` 和 `on()` 参数。

      在 `drizzle-kit@0.22.0` 和 `drizzle-orm@0.31.0` 之后的版本中，`drizzle-kit` 支持所有字段！
    </Callout>


    从 0.31.0 开始，Drizzle ORM 的新索引 API 提供了用于索引创建的所有参数的集合：

```ts
// First example, with `.on()`
index('name')
  .on(table.column1.asc(), table.column2.nullsFirst(), ...) or .onOnly(table.column1.desc().nullsLast(), table.column2, ...)
  .concurrently()
  .where(sql``)
  .with({ fillfactor: '70' })

// Second Example, with `.using()`
index('name')
  .using('btree', table.column1.asc(), sql`lower(${table.column2})`, table.column1.op('text_ops'))
  .where(sql``) // sql expression
  .with({ fillfactor: '70' })
```

  </Tab>
  <Tab>
    <Section>
    ```typescript copy {9-10}
    import { int, text, index, uniqueIndex, mysqlTable } from "drizzle-orm/mysql-core";

    export const user = mysqlTable("user", {
      id: int("id").primaryKey().autoincrement(),
      name: text("name"),
      email: text("email"),
    }, (table) => [
      index("name_idx").on(table.name),
      uniqueIndex("email_idx").on(table.email),
    ]);
    ```
    ```sql {5-6}
    CREATE TABLE `user` (
      ...
    );

    CREATE INDEX `name_idx` ON `user` (`name`);
    CREATE UNIQUE INDEX `email_idx` ON `user` (`email`);
    ```
    </Section>
    <Callout type="warning" emoji="⚠️">
      截至目前，`drizzle-kit` 仅支持索引 `name` 和 `on()` 参数。
    </Callout>

     Drizzle ORM 提供了用于索引创建的所有参数集合：

    ```typescript
    // Index declaration reference
    index("name")
      .on(table.name)
      .algorythm("default") // "default" | "copy" | "inplace"
      .using("btree") // "btree" | "hash"
      .lock("default") // "none" | "default" | "exclusive" | "shared"
    ```
  </Tab>
  <Tab>
    <Section>
    ```typescript {9-10}
    import { integer, text, index, uniqueIndex, sqliteTable } from "drizzle-orm/sqlite-core";

    export const user = sqliteTable("user", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      name: text("name"),
      email: text("email"),
    }, (table) => [
      index("name_idx").on(table.name),
      uniqueIndex("email_idx").on(table.email),
    ]);
    ```
    ```sql {5-6}
    CREATE TABLE `user` (
      ...
    );

    CREATE INDEX `name_idx` ON `user` (`name`);
    CREATE UNIQUE INDEX `email_idx` ON `user` (`email`);
    ```
    </Section>

     Drizzle ORM 提供了用于索引创建的所有参数集合：
     
    ```typescript
    // Index declaration reference
    index("name")
      .on(table.name)
      .where(sql`...`)
    ```
  </Tab>
  <Tab>
    <Section>
    ```typescript copy {9-10}
    import { int, text, index, uniqueIndex, singlestoreTable } from "drizzle-orm/singlestore-core";

    export const user = singlestoreTable("user", {
      id: int("id").primaryKey().autoincrement(),
      name: text("name"),
      email: text("email"),
    }, (table) => [
      index("name_idx").on(table.name),
      uniqueIndex("email_idx").on(table.email),
    ]);
    ```
    ```sql {5-6}
    CREATE TABLE `user` (
      ...
    );

    CREATE INDEX `name_idx` ON `user` (`name`);
    CREATE UNIQUE INDEX `email_idx` ON `user` (`email`);
    ```
    </Section>
  </Tab>
</Tabs>

Source: https://drizzle.zhcndoc.com/docs/insert

import IsSupportedChipGroup from '@mdx/IsSupportedChipGroup.astro';
import Section from '@mdx/Section.astro';
import Callout from '@mdx/Callout.astro';
import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';

# SQL 插入
Drizzle ORM 为您提供最接近 SQL 的方式将行插入数据库表中。

## 插入一行
使用 Drizzle 插入数据非常简单且类似 SQL。您可以自己看看：

<Section>
```typescript copy 
await db.insert(users).values({ name: 'Andrew' });
```
```sql
insert into "users" ("name") values ("Andrew");
```
</Section>

如果您需要某个特定表的插入类型，可以使用 `typeof usersTable.$inferInsert` 语法。
```typescript copy 
type NewUser = typeof users.$inferInsert;

const insertUser = async (user: NewUser) => {
  return db.insert(users).values(user);
}

const newUser: NewUser = { name: "Alef" };
await insertUser(newUser);
```

## 返回插入结果
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'SQLite': true, 'MySQL': false, 'SingleStore': false}} />
您可以在 PostgreSQL 和 SQLite 中插入一行并获得返回值，如下所示：
```typescript copy
await db.insert(users).values({ name: "Dan" }).returning();

// 部分返回
await db.insert(users).values({ name: "Partial Dan" }).returning({ insertedId: users.id });
```

## 插入 $returningId
<IsSupportedChipGroup chips={{ 'PostgreSQL': false, 'SQLite': false, 'MySQL': true, 'SingleStore': true }} />

MySQL 本身并不原生支持在使用 `INSERT` 后使用 `RETURNING`。对于 `自增`（或 `序列`）类型的 `主键`，只有一种方法可以做到，您可以访问 `insertId` 和 `affectedRows` 字段。我们为您准备了一种自动处理此类情况的方法，使用 Drizzle 自动接收所有插入的 ID 作为独立对象。

```ts
import { boolean, int, text, mysqlTable } from 'drizzle-orm/mysql-core';

const usersTable = mysqlTable('users', {
  id: int('id').primaryKey(),
  name: text('name').notNull(),
  verified: boolean('verified').notNull().default(false),
});


const result = await db.insert(usersTable).values([{ name: 'John' }, { name: 'John1' }]).$returningId();
//    ^? { id: number }[]
```

使用 Drizzle，您还可以指定一个使用 `$default` 函数的 `主键`，该函数将在运行时生成自定义主键。我们也将在 `$returningId()` 调用中返回这些生成的键。

```ts
import { varchar, text, mysqlTable } from 'drizzle-orm/mysql-core';
import { createId } from '@paralleldrive/cuid2';

const usersTableDefFn = mysqlTable('users_default_fn', {
  customId: varchar('id', { length: 256 }).primaryKey().$defaultFn(createId),
  name: text('name').notNull(),
});


const result = await db.insert(usersTableDefFn).values([{ name: 'John' }, { name: 'John1' }]).$returningId();
//  ^? { customId: string }[]
```

> 如果没有主键 -> 这种查询的类型将是 `{}[]`

## 插入多行
```typescript copy
await db.insert(users).values([{ name: 'Andrew' }, { name: 'Dan' }]);
```

## 插入或更新及冲突处理
Drizzle ORM 提供了简单的接口来处理插入或更新和冲突。

### 冲突时不执行任何操作
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'SQLite': true, 'MySQL': false, 'SingleStore': false }} />

`onConflictDoNothing` 会在发生冲突时取消插入：

```typescript copy
await db.insert(users)
  .values({ id: 1, name: 'John' })
  .onConflictDoNothing();

// 显式指定冲突目标
await db.insert(users)
  .values({ id: 1, name: 'John' })
  .onConflictDoNothing({ target: users.id });
```

### 冲突时进行更新

<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'SQLite': true, 'MySQL': false }} />

`onConflictDoUpdate` 会在发生冲突时更新该行：
```typescript
await db.insert(users)
  .values({ id: 1, name: 'Dan' })
  .onConflictDoUpdate({ target: users.id, set: { name: 'John' } });
```

#### `where` 子句

`冲突时更新` 可以在两个不同位置使用 `where` 子句 -
作为冲突目标的一部分（即用于部分索引）或作为 `更新` 子句的一部分：

```sql
insert into employees (employee_id, name)
values (123, 'John Doe')
on conflict (employee_id) where name <> 'John Doe'
do update set name = excluded.name

insert into employees (employee_id, name)
values (123, 'John Doe')
on conflict (employee_id) do update set name = excluded.name
where name <> 'John Doe';
```

要在 Drizzle 中指定这些条件，您可以使用 `setWhere` 和 `targetWhere` 子句：

```typescript
await db.insert(employees)
  .values({ employeeId: 123, name: 'John Doe' })
  .onConflictDoUpdate({
    target: employees.employeeId,
    targetWhere: sql`name <> 'John Doe'`,
    set: { name: sql`excluded.name` }
  });

await db.insert(employees)
  .values({ employeeId: 123, name: 'John Doe' })
  .onConflictDoUpdate({
    target: employees.employeeId,
    set: { name: 'John Doe' },
    setWhere: sql`name <> 'John Doe'`
  });
```

<hr />

使用复合索引或复合主键进行插入或更新及冲突处理：

```typescript
await db.insert(users)
  .values({ firstName: 'John', lastName: 'Doe' })
  .onConflictDoUpdate({
    target: [users.firstName, users.lastName],
    set: { firstName: 'John1' }
  });
```

### 主键重复时更新
<IsSupportedChipGroup chips={{ 'PostgreSQL': false, 'SQLite': false, 'MySQL': true, 'SingleStore': true }} />

MySQL 支持 [`ON DUPLICATE KEY UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html) 代替 `ON CONFLICT` 子句。MySQL 会根据主键和唯一索引自动确定冲突目标，如果 *任何* 唯一索引冲突，将更新该行。

Drizzle 通过 `onDuplicateKeyUpdate` 方法支持这一点：

```typescript
// 注意，MySQL 自动根据主键和唯一索引确定目标
await db.insert(users)
  .values({ id: 1, name: 'John' })
  .onDuplicateKeyUpdate({ set: { name: 'John' } });
```

虽然 MySQL 不直接支持在冲突时什么都不做，您可以通过将任意列的值设置为自身来执行无操作，从而达到相同的效果：

```typescript
import { sql } from 'drizzle-orm';

await db.insert(users)
  .values({ id: 1, name: 'John' })
  .onDuplicateKeyUpdate({ set: { id: sql`id` } });
```

## `with insert` 子句

<Callout>
  查看如何使用 WITH 语句与 [select](/docs/select#with-clause)、[update](/docs/update#with-update-clause)、[delete](/docs/delete#with-delete-clause)
</Callout>

使用 `with` 子句可以帮助您通过将复杂查询拆分为称为公共表表达式 (CTEs) 的较小子查询来简化复杂查询：
<Section>
```typescript copy
const userCount = db.$with('user_count').as(
	db.select({ value: sql`count(*)`.as('value') }).from(users)
);

const result = await db.with(userCount)
	.insert(users)
	.values([
		{ username: 'user1', admin: sql`((select * from ${userCount}) = 0)` }
	])
	.returning({
		admin: users.admin
	});
```
```sql
with "user_count" as (select count(*) as "value" from "users") 
insert into "users" ("username", "admin") 
values ($1, ((select * from "user_count") = 0)) 
returning "admin"
```
</Section>


## Insert into ... select

As the SQLite documentation mentions:

<Callout>
The second form of the INSERT statement contains a SELECT statement instead of a VALUES clause. 
A new entry is inserted into the table for each row of data returned by executing the SELECT statement. 
If a column-list is specified, the number of columns in the result of the SELECT must be the same as 
the number of items in the column-list. Otherwise, if no column-list is specified, the number of 
columns in the result of the SELECT must be the same as the number of columns in the table. 
Any SELECT statement, including compound SELECTs and SELECT statements with ORDER BY and/or LIMIT clauses, 
may be used in an INSERT statement of this form.
</Callout>
<Callout type='warning'>
To avoid a parsing ambiguity, the SELECT statement should always contain a WHERE clause, even if that clause is simply "WHERE true", if the upsert-clause is present. Without the WHERE clause, the parser does not know if the token "ON" is part of a join constraint on the SELECT, or the beginning of the upsert-clause.
</Callout>

As the PostgreSQL documentation mentions:
<Callout>
A query (SELECT statement) that supplies the rows to be inserted
</Callout>

And as the MySQL documentation mentions:

<Callout>
With INSERT ... SELECT, you can quickly insert many rows into a table from the result of a SELECT statement, which can select from one or many tables
</Callout>

Drizzle supports the current syntax for all dialects, and all of them share the same syntax. Let's review some common scenarios and API usage. 
There are several ways to use select inside insert statements, allowing you to choose your preferred approach:

- You can pass a query builder inside the select function.
- You can use a query builder inside a callback.
- You can pass an SQL template tag with any custom select query you want to use


<Tabs items={["Query Builder", "Callback", "SQL template tag"]}>
<Tab>
<Section>
```ts
const insertedEmployees = await db
  .insert(employees)
  .select(
    db.select({ name: users.name }).from(users).where(eq(users.role, 'employee'))
  )
  .returning({
    id: employees.id,
    name: employees.name
  });
```
```ts
const qb = new QueryBuilder();
await db.insert(employees).select(
    qb.select({ name: users.name }).from(users).where(eq(users.role, 'employee'))
);
```
</Section>
</Tab>
<Tab>
<Section>
```ts
await db.insert(employees).select(
    () => db.select({ name: users.name }).from(users).where(eq(users.role, 'employee'))
);
```
```ts
await db.insert(employees).select(
    (qb) => qb.select({ name: users.name }).from(users).where(eq(users.role, 'employee'))
);
```
</Section>
</Tab>
<Tab>
<Section>
```ts
await db.insert(employees).select(
    sql`select "users"."name" as "name" from "users" where "users"."role" = 'employee'`
);
```
```ts
await db.insert(employees).select(
    () => sql`select "users"."name" as "name" from "users" where "users"."role" = 'employee'`
);
```
</Section>
</Tab>
</Tabs>

Source: https://drizzle.zhcndoc.com/docs/joins

import CodeTabs from '@mdx/CodeTabs.astro';
import CodeTab from '@mdx/CodeTab.astro';
import Section from '@mdx/Section.astro';

# 联接 [SQL]
SQL中的联接子句用于基于两个或多个表之间的相关列组合它们。
Drizzle ORM 的联接语法在 SQL 语法和类型安全之间达成了平衡。

## 联接类型
Drizzle ORM 提供了 `INNER JOIN [LATERAL]`、`FULL JOIN`、`LEFT JOIN [LATERAL]`、`RIGHT JOIN`、`CROSS JOIN [LATERAL]` 的 API。
让我们快速看一下基于下面表模式的示例：
```typescript copy
export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
});

export const pets = pgTable('pets', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  ownerId: integer('owner_id').notNull().references(() => users.id),
})
```

### 左联接
<Section>
```typescript copy
const result = await db.select().from(users).leftJoin(pets, eq(users.id, pets.ownerId))
```
```sql
select ... from "users" left join "pets" on "users"."id" = "pets"."owner_id"
```
```typescript
// result type
const result: {
    user: {
        id: number;
        name: string;
    };
    pets: {
        id: number;
        name: string;
        ownerId: number;
    } | null;
}[];
```
</Section>

### 左联接 Lateral
<Section>
```typescript copy
const subquery = db.select().from(pets).where(gte(users.age, 16)).as('userPets')
const result = await db.select().from(users).leftJoinLateral(subquery, sql`true`)
```
```sql
select ... from "users" left join lateral (select ... from "pets" where "users"."age" >= 16) "userPets" on true
```
```typescript
// result type
const result: {
    user: {
        id: number;
        name: string;
    };
    userPets: {
        id: number;
        name: string;
        ownerId: number;
    } | null;
}[];
```
</Section>

### 右联接
<Section>
```typescript copy
const result = await db.select().from(users).rightJoin(pets, eq(users.id, pets.ownerId))
```
```sql
select ... from "users" right join "pets" on "users"."id" = "pets"."owner_id"
```
```typescript
// result type
const result: {
    user: {
        id: number;
        name: string;
    } | null;
    pets: {
        id: number;
        name: string;
        ownerId: number;
    };
}[];
```
</Section>

### 内联接
<Section>
```typescript copy
const result = await db.select().from(users).innerJoin(pets, eq(users.id, pets.ownerId))
```
```sql
select ... from "users" inner join "pets" on "users"."id" = "pets"."owner_id"
```
```typescript
// result type
const result: {
    user: {
        id: number;
        name: string;
    };
    pets: {
        id: number;
        name: string;
        ownerId: number;
    };
}[];
```
</Section>

### 内联接 Lateral
<Section>
```typescript copy
const subquery = db.select().from(pets).where(gte(users.age, 16)).as('userPets')
const result = await db.select().from(users).innerJoinLateral(subquery, sql`true`)
```
```sql
select ... from "users" inner join lateral (select ... from "pets" where "users"."age" >= 16) "userPets" on true
```
```typescript
// result type
const result: {
    user: {
        id: number;
        name: string;
    };
    userPets: {
        id: number;
        name: string;
        ownerId: number;
    };
}[];
```
</Section>

### 全联接
<Section>
```typescript copy
const result = await db.select().from(users).fullJoin(pets, eq(users.id, pets.ownerId))
```
```sql
select ... from "users" full join "pets" on "users"."id" = "pets"."owner_id"
```
```typescript
// result type
const result: {
    user: {
        id: number;
        name: string;
    } | null;
    pets: {
        id: number;
        name: string;
        ownerId: number;
    } | null;
}[];
```
</Section>

### 交叉联接
<Section>
```typescript copy
const result = await db.select().from(users).crossJoin(pets)
```
```sql
select ... from "users" cross join "pets"
```
```typescript
// result type
const result: {
    user: {
        id: number;
        name: string;
    };
    pets: {
        id: number;
        name: string;
        ownerId: number;
    };
}[];
```
</Section>

### 交叉联接 Lateral
<Section>
```typescript copy
const subquery = db.select().from(pets).where(gte(users.age, 16)).as('userPets')
const result = await db.select().from(users).crossJoinLateral(subquery)
```
```sql
select ... from "users" cross join lateral (select ... from "pets" where "users"."age" >= 16) "userPets"
```
```typescript
// result type
const result: {
    user: {
        id: number;
        name: string;
    };
    userPets: {
        id: number;
        name: string;
        ownerId: number;
    };
}[];
```
</Section>

## 部分选择
如果您需要选择特定字段的子集或希望有一个平坦的响应类型，Drizzle ORM
支持带有部分选择的联接，并会根据 `.select({ ... })` 结构自动推断返回类型。
<Section>
```typescript copy
await db.select({
  userId: users.id,
  petId: pets.id,
}).from(user).leftJoin(pets, eq(users.id, pets.ownerId))
```
```sql
select "users"."id", "pets"."id" from "users" left join "pets" on "users"."id" = "pets"."owner_id"
```
```typescript
// result type
const result: {
  userId: number;
  petId: number | null;
}[];
```
</Section>
您可能已经注意到 `petId` 现在可以为 null，这是因为我们是左联接，并且可能有没有宠物的用户。

在使用 `sql` 操作符进行部分选择字段和聚合时，记得要使用 `sql<type | null>` 以便正确推断结果类型，这取决于你自己！
<Section>
```typescript copy
const result = await db.select({
  userId: users.id,
  petId: pets.id,
  petName1: sql`upper(${pets.name})`,
  petName2: sql<string | null>`upper(${pets.name})`,
  //˄我们应该在类型中明确告诉' 字符串 | null'，因为我们左联接了该字段
}).from(user).leftJoin(pets, eq(users.id, pets.ownerId))
```
```sql
select "users"."id", "pets"."id", upper("pets"."name")... from "users" left join "pets" on "users"."id" = "pets"."owner_id"
```
```typescript
// result type
const result: {
  userId: number;
  petId: number | null;
  petName1: unknown;
  petName2: string | null;
}[];
```
</Section>
为了避免在联接带有大量列的表时出现多个可为 null 的字段，我们可以利用我们的 **嵌套选择对象语法**，
我们的智能类型推断将使整个对象变为可为 null，而不是使所有表字段可为 null！
<Section>
```typescript copy
await db.select({
  userId: users.id,
  userName: users.name,
  pet: {
    id: pets.id,
    name: pets.name,
    upperName: sql<string>`upper(${pets.name})`
  }
}).from(user).fullJoin(pets, eq(users.id, pets.ownerId))
```
```sql
select ... from "users" full join "pets" on "users"."id" = "pets"."owner_id"
```
```typescript
// result type
const result: {
    userId: number | null;
    userName: string | null;
    pet: {
        id: number;
        name: string;
        upperName: string;
    } | null;
}[];
```
</Section>

## 别名与自连接
Drizzle ORM 支持表别名，当您需要进行自连接时非常方便。

假设您需要获取用户及其父母：
<CodeTabs items={["index.ts", "schema.ts"]}>
<CodeTab>
```typescript copy
import { user } from "./schema";

const parent = alias(user, "parent");
const result = db
  .select()
  .from(user)
  .leftJoin(parent, eq(parent.id, user.parentId));
```
```sql
select ... from "user" left join "user" "parent" on "parent"."id" = "user"."parent_id"
```
```typescript
// result type
const result: {
    user: {
        id: number;
        name: string;
        parentId: number;
    };
    parent: {
        id: number;
        name: string;
        parentId: number;
    } | null;
}[];
```
</CodeTab>

```typescript
export const user = pgTable("user", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  name: text("name").notNull(),
  parentId: integer("parent_id").notNull().references((): AnyPgColumn => user.id)
});
```

</CodeTabs>

## 聚合结果
Drizzle ORM 从驱动程序提供名称映射的结果，而不改变结构。

您可以自由地按您想要的方式处理结果，这是一个映射多对一关系数据的示例：
```typescript
type User = typeof users.$inferSelect;
type Pet = typeof pets.$inferSelect;

const rows = db.select({
    user: users,
    pet: pets,
  }).from(users).leftJoin(pets, eq(users.id, pets.ownerId)).all();

const result = rows.reduce<Record<number, { user: User; pets: Pet[] }>>(
  (acc, row) => {
    const user = row.user;
    const pet = row.pet;

    if (!acc[user.id]) {
      acc[user.id] = { user, pets: [] };
    }

    if (pet) {
      acc[user.id].pets.push(pet);
    }

    return acc;
  },
  {}
);

// result type
const result: Record<number, {
    user: User;
    pets: Pet[];
}>;
```

## 多对一示例
```typescript
import { sqliteTable, text, integer } from 'drizzle-orm/sqlite-core';
import { drizzle } from 'drizzle-orm/better-sqlite3';

const cities = sqliteTable('cities', {
  id: integer('id').primaryKey(),
  name: text('name'),
});

const users = sqliteTable('users', {
  id: integer('id').primaryKey(),
  name: text('name'),
  cityId: integer('city_id').references(() => cities.id)
});

const db = drizzle();

const result = db.select().from(cities).leftJoin(users, eq(cities.id, users.cityId)).all();
```
## 多对多示例
```typescript
const users = sqliteTable('users', {
  id: integer('id').primaryKey(),
  name: text('name'),
});

const chatGroups = sqliteTable('chat_groups', {
  id: integer('id').primaryKey(),
  name: text('name'),
});

const usersToChatGroups = sqliteTable('usersToChatGroups', {
  userId: integer('user_id').notNull().references(() => users.id),
  groupId: integer('group_id').notNull().references(() => chatGroups.id),
});


// 查询 ID 为 1 的用户组及所有参与者（用户）
db.select()
  .from(usersToChatGroups)
  .leftJoin(users, eq(usersToChatGroups.userId, users.id))
  .leftJoin(chatGroups, eq(usersToChatGroups.groupId, chatGroups.id))
  .where(eq(chatGroups.id, 1))
  .all();

Source: https://drizzle.zhcndoc.com/docs/kit-custom-migrations

import CodeTab from '@mdx/CodeTab.astro';
import CodeTabs from '@mdx/CodeTabs.astro';
import Section from '@mdx/Section.astro';
import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Callout from '@mdx/Callout.astro';
import Npm from '@mdx/Npm.astro';
import Npx from '@mdx/Npx.astro';
import Steps from '@mdx/Steps.astro';
import Prerequisites from "@mdx/Prerequisites.astro"

# 使用 Drizzle Kit 的迁移
<Prerequisites>
- 开始使用 Drizzle 和 `drizzle-kit` - [阅读这里](/docs/get-started)
- Drizzle schema 基础知识 - [阅读这里](/docs/sql-schema-declaration)
- 数据库连接基础 - [阅读这里](/docs/connect-overview)
- Drizzle 迁移基础 - [阅读这里](/docs/migrations)
- Drizzle Kit [概述](/docs/kit-overview) 和 [配置文件](/docs/drizzle-config-file)
- `drizzle-kit generate` 命令 - [阅读这里](/docs/drizzle-kit-generate)
- `drizzle-kit migrate` 命令 - [阅读这里](/docs/drizzle-kit-migrate)
</Prerequisites>

Drizzle 允许你生成空的迁移文件，以编写自定义的 SQL 迁移，
用于目前不支持的 DDL 修改或数据预填充，你可以使用 [`drizzle-kit migrate`](/docs/drizzle-kit-migrate) 命令来运行这些迁移。

```shell
drizzle-kit generate --custom --name=seed-users
```
<Section>
```plaintext {5}
📦 <项目根目录>
 ├ 📂 drizzle
 │ ├ 📂 _meta
 │ ├ 📜 0000_init.sql 
 │ └ 📜 0001_seed-users.sql 
 ├ 📂 src
 └ …
```
```sql
-- ./drizzle/0001_seed-users.sql

INSERT INTO "users" ("name") VALUES('Dan');
INSERT INTO "users" ("name") VALUES('Andrew');
INSERT INTO "users" ("name") VALUES('Dandrew');
```
</Section>

### 运行 JavaScript 和 TypeScript 迁移
我们将在即将发布的版本中添加运行自定义 JavaScript 和 TypeScript 迁移/填充脚本的能力，你可以关注 [GitHub 讨论](https://github.com/drizzle-team/drizzle-orm/discussions/2832)。

Source: https://drizzle.zhcndoc.com/docs/kit-migrations-for-teams

# Drizzle 团队的迁移

此部分将在我们发布下一个版本的迁移文件夹结构后更新。
您可以阅读扩展的 [github 讨论](https://github.com/drizzle-team/drizzle-orm/discussions/2832) 并订阅更新！


Source: https://drizzle.zhcndoc.com/docs/kit-overview

import CodeTab from '@mdx/CodeTab.astro';
import CodeTabs from '@mdx/CodeTabs.astro';
import Section from '@mdx/Section.astro';
import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Callout from '@mdx/Callout.astro';
import Npm from '@mdx/Npm.astro';
import Npx from '@mdx/Npx.astro';
import Steps from '@mdx/Steps.astro';
import Prerequisites from "@mdx/Prerequisites.astro"

# 使用 Drizzle Kit 进行迁移
<Prerequisites>
- 开始使用 Drizzle 和 `drizzle-kit` - [点击这里阅读](/docs/get-started)
- Drizzle 架构基础 - [点击这里阅读](/docs/sql-schema-declaration)
- 数据库连接基础 - [点击这里阅读](/docs/connect-overview)
- Drizzle 迁移基础 - [点击这里阅读](/docs/migrations)
</Prerequisites>


**Drizzle Kit** 是一个用于管理 SQL 数据库迁移的 CLI 工具。
<Npm>
  drizzle-kit
</Npm>
<Callout type="warning">
确保首先阅读 Drizzle 的 [入门指南](/docs/get-started) 和 [迁移基础](/docs/migrations)，并选择最适合您业务需求的 SQL 迁移流程。
</Callout>

根据您的架构，Drizzle Kit 让您生成和运行 SQL 迁移文件，
直接将架构推送到数据库，从数据库中提取架构，启动 Drizzle Studio，并具有一些实用命令。
<Npx>
drizzle-kit generate
drizzle-kit migrate
drizzle-kit push
drizzle-kit pull
drizzle-kit check
drizzle-kit up
drizzle-kit studio
</Npx>


|                                                      |                                                                                                                                                                    |
| :--------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [`drizzle-kit generate`](/docs/drizzle-kit-generate) | 让您根据 Drizzle 架构生成 SQL 迁移文件，无论是声明时还是后续更改时，[点击这里查看](/docs/drizzle-kit-generate)。       |
| [`drizzle-kit migrate`](/docs/drizzle-kit-migrate)   | 让您将生成的 SQL 迁移文件应用到您的数据库，[点击这里查看](/docs/drizzle-kit-migrate)。                                                              |
| [`drizzle-kit pull`](/docs/drizzle-kit-pull)         | 让您提取（内省）数据库架构，将其转换为 Drizzle 架构并保存在您的代码库中，[点击这里查看](/docs/drizzle-kit-pull)。                           |
| [`drizzle-kit push`](/docs/drizzle-kit-push)         | 让您在声明或后续架构更改时将 Drizzle 架构推送到数据库，[点击这里查看](/docs/drizzle-kit-push)。                          |
| [`drizzle-kit studio`](/docs/drizzle-kit-studio)     | 将连接到您的数据库并为 Drizzle Studio 启动代理服务器，您可以使用它方便地浏览数据库，[点击这里查看](/docs/drizzle-kit-studio)。 |
| [`drizzle-kit check`](/docs/drizzle-kit-check)       | 将遍历所有生成的迁移并检查生成的迁移是否存在竞态条件（冲突），[点击这里查看](/docs/drizzle-kit-check)。               |
| [`drizzle-kit up`](/docs/drizzle-kit-up)             | 用于升级之前生成的迁移快照，[点击这里查看](/docs/drizzle-kit-up)                                                                     |
<br/>

Drizzle Kit 通过 [drizzle.config.ts](/docs/drizzle-config-file) 配置文件或 CLI 参数进行配置。<br/>
至少需要提供 SQL `dialect` 和 `schema` 路径，以便 Drizzle Kit 知道如何生成迁移。
```
📦 <项目根目录>
 ├ 📂 drizzle
 ├ 📂 src
 ├ 📜 .env
 ├ 📜 drizzle.config.ts  <--- Drizzle 配置文件
 ├ 📜 package.json
 └ 📜 tsconfig.json
```

<CodeTabs items={["简单配置", "扩展配置"]}>
```ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql",
  schema: "./src/schema.ts",
});
```
```ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  out: "./drizzle",
  dialect: "postgresql",
  schema: "./src/schema.ts",

  driver: "pglite",
  dbCredentials: {
    url: "./database/",
  },

  extensionsFilters: ["postgis"],
  schemaFilter: "public",
  tablesFilter: "*",

  introspect: {
    casing: "camel",
  },

  migrations: {
    prefix: "timestamp",
    table: "__drizzle_migrations__",
    schema: "public",
  },

  breakpoints: true,
  strict: true,
  verbose: true,
});
```
</CodeTabs>

您可以通过 CLI 参数提供 Drizzle Kit 配置路径，这在您有多个数据库阶段或多个数据库，或同一项目中有不同数据库时非常有用：

<Npx>
  drizzle-kit push --config=drizzle-dev.drizzle.config
  drizzle-kit push --config=drizzle-prod.drizzle.config
</Npx>
```plaintext {5-6}
📦 <项目根目录>
 ├ 📂 drizzle
 ├ 📂 src
 ├ 📜 .env
 ├ 📜 drizzle-dev.config.ts
 ├ 📜 drizzle-prod.config.ts
 ├ 📜 package.json
 └ 📜 tsconfig.json
```


Source: https://drizzle.zhcndoc.com/docs/kit-seed-data

import CodeTab from '@mdx/CodeTab.astro';
import CodeTabs from '@mdx/CodeTabs.astro';
import Section from '@mdx/Section.astro';
import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Callout from '@mdx/Callout.astro';
import Npm from '@mdx/Npm.astro';
import Npx from '@mdx/Npx.astro';
import Steps from '@mdx/Steps.astro';
import Prerequisites from "@mdx/Prerequisites.astro"

# Drizzle Kit 数据预置

此部分将在我们发布 `drizzle-seed` 包后立即更新。

Source: https://drizzle.zhcndoc.com/docs/kit-web-mobile

import CodeTab from '@mdx/CodeTab.astro';
import CodeTabs from '@mdx/CodeTabs.astro';
import Section from '@mdx/Section.astro';
import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Callout from '@mdx/Callout.astro';
import Npm from '@mdx/Npm.astro';
import Npx from '@mdx/Npx.astro';
import Steps from '@mdx/Steps.astro';
import Prerequisites from "@mdx/Prerequisites.astro"

# Drizzle 在网页和移动环境中的迁移

本节内容将在下一个版本中更新。

有关 **Expo SQLite**、**OP SQLite** 和 **React Native** 的迁移，请参考我们的[快速开始](/docs/get-started/expo-new)指南。

Source: https://drizzle.zhcndoc.com/docs/migrations

export const a = 10;

import Callout from '@mdx/Callout.astro';
import Steps from '@mdx/Steps.astro';
import CodeTab from '@mdx/CodeTab.astro';
import CodeTabs from '@mdx/CodeTabs.astro';
import Section from '@mdx/Section.astro';
import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Npm from '@mdx/Npm.astro';
import Tag from '@mdx/Tag.astro'


# Drizzle 迁移基础知识

SQL 数据库要求你提前指定你将要存储的实体的 **严格模式**， 
如果（当）你需要改变这些实体的形状 - 你需要通过 **模式迁移** 来实现。

有多种生产级管理数据库迁移的方式。 
Drizzle 旨在完美适应所有这些方式，无论你是选择 **数据库优先** 还是 **代码库优先**。

**数据库优先** 是指你的数据库模式是事实来源。你要么直接在数据库上管理数据库模式， 
要么通过数据库迁移工具，然后将数据库模式拉入代码库的应用实体中。

**代码库优先** 是指代码库中的数据库模式是事实来源，且受版本控制。你在 JavaScript/TypeScript 中声明和管理数据库模式，
然后使用 Drizzle 将该模式应用于数据库，直接或通过外部迁移工具。

#### Drizzle 如何提供帮助？
我们构建了 [**drizzle-kit**](/docs/kit-overview) - 用于管理迁移的 CLI 应用程序。 
```shell
drizzle-kit migrate
drizzle-kit generate
drizzle-kit push
drizzle-kit pull
```
它旨在根据你当前的业务需求，让你选择如何处理迁移。

它适用于数据库优先和代码库优先两种方法，允许你 **推送你的模式** 或 **生成 SQL 迁移** 文件，或 **从数据库拉取模式**。
无论你是单独工作还是在团队中，它都非常完美。
<br/>

<hr/>
<rem/>

**现在让我们为你的项目选择最佳选项：**
<rem/>

<Tag style="font-size: 12px">**选项 1**</Tag>
> 我自己管理数据库模式，使用外部迁移工具或直接在数据库上运行 SQL 迁移。
> 从 Drizzle 中，我只需要从我的数据库中获取当前模式状态并将其保存为 TypeScript 模式文件。

<Callout collapsed="Expand details">
这是一种 **数据库优先** 的方法。你将数据库模式作为 **事实来源**， 
Drizzle 允许你使用 [`drizzle-kit pull`](/docs/drizzle-kit-pull) 命令将数据库模式拉取到 TypeScript 中。

<Section>
```
                                  ┌────────────────────────┐      ┌─────────────────────────┐ 
                                  │                        │ <---  CREATE TABLE "users" (
┌──────────────────────────┐      │                        │        "id" SERIAL PRIMARY KEY,
│ ~ drizzle-kit pull       │      │                        │        "name" TEXT,
└─┬────────────────────────┘      │        DATABASE        │        "email" TEXT UNIQUE
  │                               │                        │       );
  └ Pull datatabase schema -----> │                        │
  ┌ Generate Drizzle       <----- │                        │
  │ schema TypeScript file        └────────────────────────┘
  │
  v
```
```typescript
import * as p from "drizzle-orm/pg-core";

export const users = p.pgTable("users", {
  id: p.serial().primaryKey(),
  name: p.text(),
  email: p.text().unique(),
});
```
</Section>
</Callout>

<rem/>
<rem/>
<rem/>

<Tag style="font-size: 12px">**选项 2**</Tag>
> 我希望在我的 TypeScript 代码库中拥有数据库模式，
> 我不想处理 SQL 迁移文件。
> 我希望 Drizzle 将我的模式“推送”到数据库。

<Callout collapsed="Expand details">
这是一种 **代码库优先** 的方法。你将 TypeScript Drizzle 模式作为 **事实来源**， 
Drizzle 允许你使用 [`drizzle-kit push`](/docs/drizzle-kit-push) 命令将模式更改推送到数据库。

这是快速原型设计的最佳方法，
我们看到几十个团队和独立开发者成功地将其作为生产应用程序的主要迁移流程。

<Section>
```typescript {6} filename="src/schema.ts"
import * as p from "drizzle-orm/pg-core";

export const users = p.pgTable("users", {
  id: p.serial().primaryKey(),
  name: p.text(),
  email: p.text().unique(), // <--- 添加的列
};
```
```
为 `users` 表添加列                                                                          
┌──────────────────────────┐                  
│ + email: text().unique() │                  
└─┬────────────────────────┘                  
  │                                           
  v                                           
┌──────────────────────────┐                  
│ ~ drizzle-kit push       │                  
└─┬────────────────────────┘                  
  │                                           ┌──────────────────────────┐
  └ Pull current datatabase schema ---------> │                          │
                                              │                          │
  ┌ Generate alternations based on diff <---- │         DATABASE         │
  │                                           │                          │
  └ Apply migrations to the database -------> │                          │
                                       │      └──────────────────────────┘
                                       │
  ┌────────────────────────────────────┴──────────────┐
   ALTER TABLE `users` ADD COLUMN `email` TEXT UNIQUE; 
```
</Section>
</Callout>

<rem/>
<rem/>
<rem/>

<Tag style="font-size: 12px">**选项 3**</Tag>
> 我希望在我的 TypeScript 代码库中拥有数据库模式，
> 我希望 Drizzle 为我生成 SQL 迁移文件并将其应用到我的数据库。

<Callout collapsed="Expand details">
这是一种 **代码库优先** 的方法。你将 TypeScript Drizzle 模式作为事实来源， 
Drizzle 允许你基于模式更改生成 SQL 迁移文件，使用 [`drizzle-kit generate`](/docs/drizzle-kit-generate），
然后使用 [`drizzle-kit migrate`](/docs/drizzle-kit-migrate) 命令将其应用到数据库。 
<Section>
```typescript filename="src/schema.ts"
import * as p from "drizzle-orm/pg-core";

export const users = p.pgTable("users", {
  id: p.serial().primaryKey(),
  name: p.text(),
  email: p.text().unique(),
});
```
```                                  
┌────────────────────────┐                  
│ $ drizzle-kit generate │                  
└─┬──────────────────────┘                  
  │                                           
  └ 1. 读取先前的迁移文件夹
    2. 找到当前和先前模式之间的差异
    3. 如有必要，提示开发者进行重命名
  ┌ 4. 生成 SQL 迁移并持久保存到文件
  │    ┌─┴───────────────────────────────────────┐  
  │      📂 drizzle       
  │      └ 📂 20242409125510_premium_mister_fear
  │        ├ 📜 snapshot.json
  │        └ 📜 migration.sql
  v
```
```sql
-- drizzle/20242409125510_premium_mister_fear/migration.sql

CREATE TABLE "users" (
 "id" SERIAL PRIMARY KEY,
 "name" TEXT,
 "email" TEXT UNIQUE
);
```
```
┌───────────────────────┐                  
│ $ drizzle-kit migrate │                  
└─┬─────────────────────┘                  
  │                                                         ┌──────────────────────────┐                                         
  └ 1. 读取迁移.sql 文件                                                        │                          │
    2. 从数据库中获取迁移历史 -------------> │                          │
  ┌ 3. 选择以前未应用的迁移 <-------------- │         DATABASE         │
  └ 4. 将新迁移应用于数据库 -------------> │                          │
                                                            │                          │
                                                            └──────────────────────────┘
[✓] 完成！                                                 
```
</Section>
</Callout>

<rem/>
<rem/>
<rem/>

<Tag style="font-size: 12px">**选项 4**</Tag>
> 我希望在我的 TypeScript 代码库中拥有数据库模式，
> 我希望 Drizzle 为我生成 SQL 迁移文件，并希望 Drizzle 在运行时应用它们。

<Callout collapsed="Expand details">
这是一种 **代码库优先** 的方法。你将 TypeScript Drizzle 模式作为事实来源， 
Drizzle 允许你根据模式更改生成 SQL 迁移文件，使用 [`drizzle-kit generate`](/docs/drizzle-kit-generate），
然后你可以在应用程序运行时将其应用到数据库。

这种方法广泛用于 **单体** 应用程序，
在零停机部署期间应用数据库迁移，并在发生故障时回滚 DDL 更改。
这也应用于 **无服务器** 部署，在部署过程中以 **自定义资源** 运行迁移。

<Section>
```typescript filename="src/schema.ts"
import * as p from "drizzle-orm/pg-core";

export const users = p.pgTable("users", {
  id: p.serial().primaryKey(),
  name: p.text(),
  email: p.text().unique(),
});
```
```                                  
┌────────────────────────┐                  
│ $ drizzle-kit generate │                  
└─┬──────────────────────┘                  
  │                                           
  └ 1. 读取先前的迁移文件夹
    2. 找到当前和先前模式之间的差异
    3. 如有必要，提示开发者进行重命名
  ┌ 4. 生成 SQL 迁移并持久保存到文件
  │    ┌─┴───────────────────────────────────────┐  
  │      📂 drizzle       
  │      └ 📂 20242409125510_premium_mister_fear
  │        ├ 📜 snapshot.json
  │        └ 📜 migration.sql
  v
```
```sql
-- drizzle/20242409125510_premium_mister_fear/migration.sql

CREATE TABLE "users" (
 "id" SERIAL PRIMARY KEY,
 "name" TEXT,
 "email" TEXT UNIQUE
);
```
```ts
// index.ts
import { drizzle } from "drizzle-orm/node-postgres"
import { migrate } from 'drizzle-orm/node-postgres/migrator';

const db = drizzle(process.env.DATABASE_URL);

await migrate(db);
```
```
┌───────────────────────┐                  
│ npx tsx src/index.ts  │                  
└─┬─────────────────────┘                  
  │                                                      
  ├ 1. 初始化数据库连接                             ┌──────────────────────────┐                                         
  └ 2. 读取迁移.sql 文件                                                        │                          │
    3. 从数据库中获取迁移历史 -------------> │                          │
  ┌ 4. 选择以前未应用的迁移 <-------------- │         DATABASE         │
  └ 5. 将新迁移应用于数据库 -------------> │                          │
                                                            │                          │
                                                            └──────────────────────────┘
[✓] 完成！                                                 
```
</Section>
</Callout>

<rem/>
<rem/>
<rem/>

<Tag style="font-size: 12px">**选项 5**</Tag>
> 我希望在我的 TypeScript 代码库中拥有数据库模式，
> 我希望 Drizzle 为我生成 SQL 迁移文件，
> 但我会自己将其应用到我的数据库或使用外部迁移工具。

<Callout collapsed="Expand details">
这是一种 **代码库优先** 的方法。你将 TypeScript Drizzle 模式作为事实来源， 
Drizzle 允许你基于模式更改生成 SQL 迁移文件，使用 [`drizzle-kit generate`](/docs/drizzle-kit-generate)，
然后你可以直接或通过外部迁移工具将其应用于数据库。

<Section>
```typescript filename="src/schema.ts"
import * as p from "drizzle-orm/pg-core";

export const users = p.pgTable("users", {
  id: p.serial().primaryKey(),
  name: p.text(),
  email: p.text().unique(),
});
```
```                                  
┌────────────────────────┐                  
│ $ drizzle-kit generate │                  
└─┬──────────────────────┘                  
  │                                           
  └ 1. 读取先前的迁移文件夹
    2. 找到当前和先前模式之间的差异
    3. 如有必要，提示开发者进行重命名
  ┌ 4. 生成 SQL 迁移并持久保存到文件
  │    ┌─┴───────────────────────────────────────┐  
  │      📂 drizzle       
  │      └ 📂 20242409125510_premium_mister_fear
  │        ├ 📜 snapshot.json
  │        └ 📜 migration.sql
  v
```
```sql
-- drizzle/20242409125510_premium_mister_fear/migration.sql

CREATE TABLE "users" (
 "id" SERIAL PRIMARY KEY,
 "name" TEXT,
 "email" TEXT UNIQUE
);
```
```
┌───────────────────────────────────┐                  
│ (._.) 现在你运行你的迁移 │           
└─┬─────────────────────────────────┘  
  │
  直接到数据库
  │                                         ┌────────────────────┐
  ├────────────────────────────────────┬───>│                    │  
  │                                    │    │      Database      │           
 or via external tools                 │    │                    │   
  │                                    │    └────────────────────┘
  │  ┌────────────────────┐            │      
  └──│ Bytebase           ├────────────┘         
     ├────────────────────┤  
     │ Liquibase          │
     ├────────────────────┤ 
     │ Atlas              │
     ├────────────────────┤ 
     │ etc…               │
     └────────────────────┘

[✓] 完成！                                                 
```
</Section>
</Callout>

<rem/>
<rem/>
<rem/>

<Tag style="font-size: 12px">**Option 6**</Tag>
> 我想在我的 TypeScript 代码库中拥有数据库架构，
> 我希望 Drizzle 将我的 Drizzle 架构的 SQL 表示输出到控制台，
> 然后我将通过 [Atlas](https://atlasgo.io/guides/orms/drizzle)应用这些架构到我的数据库中。

<Callout collapsed="Expand details">
这是一种**以代码库为先**的方法。你拥有 TypeScript Drizzle 模式作为真实来源，并且
Drizzle 允许你根据模式变化导出 SQL 语句，使用 [`drizzle-kit export`](/docs/drizzle-kit-generate)，然后
你可以通过 [Atlas](https://atlasgo.io/guides/orms/drizzle) 或其他外部 SQL 迁移工具将它们应用到数据库。

<Section>
```typescript filename="src/schema.ts"
import * as p from "drizzle-orm/pg-core";

export const users = p.pgTable("users", {
  id: p.serial().primaryKey(),
  name: p.text(),
  email: p.text().unique(),
});
```
```                                  
┌────────────────────────┐                  
│ $ drizzle-kit export   │                  
└─┬──────────────────────┘                  
  │                                           
  └ 1. read your drizzle schema
    2. generated SQL representation of your schema
  ┌ 3. outputs to console
  │    
  │        
  v
```
```sql
CREATE TABLE "users" (
 "id" SERIAL PRIMARY KEY,
 "name" TEXT,
 "email" TEXT UNIQUE
);
```
```
┌───────────────────────────────────┐                  
│ (._.) now you run your migrations │           
└─┬─────────────────────────────────┘  
  │
 via Atlas
  │                                    ┌──────────────┐
  │  ┌────────────────────┐            │              │
  └──│ Atlas              ├───────────>│  Database    │      
     └────────────────────┘            │              │       
                                       └──────────────┘

[✓] done!                                                 
```
</Section>
</Callout>

<rem/>
<rem/>


Source: https://drizzle.zhcndoc.com/docs/operators

import IsSupportedChipGroup from '@mdx/IsSupportedChipGroup.astro';
import Section from '@mdx/Section.astro';

# 过滤器和条件运算符
我们原生支持所有特定于方言的过滤器和条件运算符。

您可以从 `drizzle-orm` 导入所有过滤器和条件：
```typescript copy
import { eq, ne, gt, gte, ... } from "drizzle-orm";
```

### eq
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'MySQL': true, 'SQLite': true, 'SingleStore': true }} />
  
值等于 `n`
<Section>
```typescript copy
import { eq } from "drizzle-orm";

db.select().from(table).where(eq(table.column, 5));
```

```sql copy
SELECT * FROM table WHERE table.column = 5
```
</Section>


<Section>
```typescript
import { eq } from "drizzle-orm";

db.select().from(table).where(eq(table.column1, table.column2));
```

```sql
SELECT * FROM table WHERE table.column1 = table.column2
```
</Section>


### ne
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'MySQL': true, 'SQLite': true, 'SingleStore': true }} />
  
值不等于 `n`  
<Section>
```typescript
import { ne } from "drizzle-orm";

db.select().from(table).where(ne(table.column, 5));
```

```sql
SELECT * FROM table WHERE table.column <> 5
```
</Section>


<Section>
```typescript
import { ne } from "drizzle-orm";

db.select().from(table).where(ne(table.column1, table.column2));
```

```sql
SELECT * FROM table WHERE table.column1 <> table.column2
```
</Section>

## ---

### gt
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'MySQL': true, 'SQLite': true, 'SingleStore': true }} /> 
  
值大于 `n`
<Section>
```typescript
import { gt } from "drizzle-orm";

db.select().from(table).where(gt(table.column, 5));
```

```sql
SELECT * FROM table WHERE table.column > 5
```
</Section>


<Section>
```typescript
import { gt } from "drizzle-orm";

db.select().from(table).where(gt(table.column1, table.column2));
```

```sql
SELECT * FROM table WHERE table.column1 > table.column2
```
</Section>

### gte
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'MySQL': true, 'SQLite': true, 'SingleStore': true }} />
  
值大于或等于 `n`
<Section>
```typescript
import { gte } from "drizzle-orm";

db.select().from(table).where(gte(table.column, 5));
```

```sql
SELECT * FROM table WHERE table.column >= 5
```
</Section>


<Section>
```typescript
import { gte } from "drizzle-orm";

db.select().from(table).where(gte(table.column1, table.column2));
```

```sql
SELECT * FROM table WHERE table.column1 >= table.column2
```
</Section>

### lt
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'MySQL': true, 'SQLite': true, 'SingleStore': true }} />
  
值小于 `n`
<Section>
```typescript
import { lt } from "drizzle-orm";

db.select().from(table).where(lt(table.column, 5));
```

```sql
SELECT * FROM table WHERE table.column < 5
```
</Section>


<Section>
```typescript
import { lt } from "drizzle-orm";

db.select().from(table).where(lt(table.column1, table.column2));
```

```sql
SELECT * FROM table WHERE table.column1 < table.column2
```
</Section>

### lte
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'MySQL': true, 'SQLite': true, 'SingleStore': true }} />
  
值小于或等于 `n`。

<Section>
```typescript
import { lte } from "drizzle-orm";

db.select().from(table).where(lte(table.column, 5));
```

```sql
SELECT * FROM table WHERE table.column <= 5
```
</Section>

<Section>
```typescript
import { lte } from "drizzle-orm";

db.select().from(table).where(lte(table.column1, table.column2));
```

```sql
SELECT * FROM table WHERE table.column1 <= table.column2
```
</Section>

## ---

### exists
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'MySQL': true, 'SQLite': true, 'SingleStore': true }} />
  
值存在
<Section>
```typescript
import { exists } from "drizzle-orm";

const query = db.select().from(table2)
db.select().from(table).where(exists(query));
```

```sql
SELECT * FROM table WHERE EXISTS (SELECT * from table2)
```
</Section>

### notExists

<Section>
```typescript
import { notExists } from "drizzle-orm";

const query = db.select().from(table2)
db.select().from(table).where(notExists(query));
```

```sql
SELECT * FROM table WHERE NOT EXISTS (SELECT * from table2)
```
</Section>

### isNull
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'MySQL': true, 'SQLite': true, 'SingleStore': true }} />
  
值为 `null`
<Section>
```typescript
import { isNull } from "drizzle-orm";

db.select().from(table).where(isNull(table.column));
```

```sql
SELECT * FROM table WHERE table.column IS NULL
```
</Section>


### isNotNull
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'MySQL': true, 'SQLite': true, 'SingleStore': true }} />
  
值不为 `null`
<Section>
```typescript
import { isNotNull } from "drizzle-orm";

db.select().from(table).where(isNotNull(table.column));
```

```sql
SELECT * FROM table WHERE table.column IS NOT NULL
```
</Section>

## ---

### inArray
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'MySQL': true, 'SQLite': true, 'SingleStore': true }} />
  
值在值的数组中
<Section>
```typescript
import { inArray } from "drizzle-orm";

db.select().from(table).where(inArray(table.column, [1, 2, 3, 4]));
```

```sql
SELECT * FROM table WHERE table.column in (1, 2, 3, 4)
```
</Section>

<Section>
```typescript
import { inArray } from "drizzle-orm";

const query = db.select({ data: table2.column }).from(table2);
db.select().from(table).where(inArray(table.column, query));
```

```sql
SELECT * FROM table WHERE table.column IN (SELECT table2.column FROM table2)
```
</Section>

### notInArray
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'MySQL': true, 'SQLite': true, 'SingleStore': true }} />
  
值不在值的数组中
<Section>
```typescript
import { notInArray } from "drizzle-orm";

db.select().from(table).where(notInArray(table.column, [1, 2, 3, 4]));
```

```sql
SELECT * FROM table WHERE table.column NOT in (1, 2, 3, 4)
```
</Section>

<Section>
```typescript
import { notInArray } from "drizzle-orm";

const query = db.select({ data: table2.column }).from(table2);
db.select().from(table).where(notInArray(table.column, query));
```

```sql
SELECT * FROM table WHERE table.column NOT IN (SELECT table2.column FROM table2)
```
</Section>

## ---

### between
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'MySQL': true, 'SQLite': true, 'SingleStore': true }} />
  
值在两个值之间
<Section>
```typescript
import { between } from "drizzle-orm";

db.select().from(table).where(between(table.column, 2, 7));
```

```sql
SELECT * FROM table WHERE table.column BETWEEN 2 AND 7
```
</Section>

### notBetween
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'MySQL': true, 'SQLite': true, 'SingleStore': true }} />
  
值不在两个值之间
<Section>
```typescript
import { notBetween } from "drizzle-orm";

db.select().from(table).where(notBetween(table.column, 2, 7));
```

```sql
SELECT * FROM table WHERE table.column NOT BETWEEN 2 AND 7
```
</Section>

## ---

### like
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'MySQL': true, 'SQLite': true, 'SingleStore': true }} />
  
值类似于其他值，区分大小写
<Section>
```typescript
import { like } from "drizzle-orm";

db.select().from(table).where(like(table.column, "%llo wor%"));
```

```sql
SELECT * FROM table WHERE table.column LIKE '%llo wor%'
```
</Section>

### ilike
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'MySQL': false, 'SQLite': false, 'SingleStore': false }} />
  
值与某个其他值相似，不区分大小写
<Section>
```typescript
import { ilike } from "drizzle-orm";

db.select().from(table).where(ilike(table.column, "%llo wor%"));
```

```sql
SELECT * FROM table WHERE table.column ILIKE '%llo wor%'
```
</Section>

### notIlike
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'MySQL': true, 'SQLite': true, 'SingleStore': true }} />
  
值与某个其他值不相似，不区分大小写
<Section>
```typescript
import { notIlike } from "drizzle-orm";

db.select().from(table).where(notIlike(table.column, "%llo wor%"));
```

```sql
SELECT * FROM table WHERE table.column NOT ILIKE '%llo wor%'
```
</Section>

## ---

### not
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'MySQL': true, 'SQLite': true, 'SingleStore': true }} />
  
所有条件必须返回 `false`。

<Section>
```typescript
import { eq, not } from "drizzle-orm";

db.select().from(table).where(not(eq(table.column, 5)));
```

```sql
SELECT * FROM table WHERE NOT (table.column = 5)
```
</Section>

### and
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'MySQL': true, 'SQLite': true, 'SingleStore': true }} />
  
所有条件必须返回 `true`。

<Section>
```typescript
import { gt, lt, and } from "drizzle-orm";

db.select().from(table).where(and(gt(table.column, 5), lt(table.column, 7)));
```

```sql
SELECT * FROM table WHERE (table.column > 5 AND table.column < 7)
```
</Section>

### or
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'MySQL': true, 'SQLite': true, 'SingleStore': true }} />
  
一个或多个条件必须返回 `true`。

<Section>
```typescript
import { gt, lt, or } from "drizzle-orm";

db.select().from(table).where(or(gt(table.column, 5), lt(table.column, 7)));
```

```sql
SELECT * FROM table WHERE (table.column > 5 OR table.column < 7)
```
</Section>

## ---

### arrayContains
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'MySQL': false, 'SQLite': false, 'SingleStore': false }} />
  
测试某个列或表达式是否包含作为第二个参数传递的列表中的所有元素

<Section>
```typescript
import { arrayContains } from "drizzle-orm";

const contains = await db.select({ id: posts.id }).from(posts)
  .where(arrayContains(posts.tags, ['Typescript', 'ORM']));

const withSubQuery = await db.select({ id: posts.id }).from(posts)
  .where(arrayContains(
    posts.tags,
    db.select({ tags: posts.tags }).from(posts).where(eq(posts.id, 1)),
  ));
```

```sql
select "id" from "posts" where "posts"."tags" @> {Typescript,ORM};
select "id" from "posts" where "posts"."tags" @> (select "tags" from "posts" where "posts"."id" = 1);
```
</Section>

### arrayContained
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'MySQL': false, 'SQLite': false, 'SingleStore': false }} />
  
测试作为第二个参数传递的列表是否包含某个列或表达式中的所有元素

<Section>
```typescript
import { arrayContained } from "drizzle-orm";

const contained = await db.select({ id: posts.id }).from(posts)
  .where(arrayContained(posts.tags, ['Typescript', 'ORM']));
```

```sql
select "id" from "posts" where "posts"."tags" <@ {Typescript,ORM};
```
</Section>

### arrayOverlaps
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'MySQL': false, 'SQLite': false, 'SingleStore': false }} />
  
测试某个列或表达式是否包含作为第二个参数传递的列表中的任何元素。

<Section>
```typescript
import { arrayOverlaps } from "drizzle-orm";

const overlaps = await db.select({ id: posts.id }).from(posts)
  .where(arrayOverlaps(posts.tags, ['Typescript', 'ORM']));
```

```sql
select "id" from "posts" where "posts"."tags" && {Typescript,ORM}
```
</Section>


Source: https://drizzle.zhcndoc.com/docs/overview

import Callout from '@mdx/Callout.astro';
import CodeTabs from '@mdx/CodeTabs.astro';
import YoutubeCards from '@mdx/YoutubeCards.astro';
import GetStartedLinks from '@mdx/GetStartedLinks/index.astro'

# Drizzle ORM

Drizzle ORM 是一个无头的 TypeScript ORM。🐲
> Drizzle 是一个会在你需要的时候陪伴你，而在你需要空间时不打扰你的好朋友。

它看起来和感觉都很简单，并且在你项目的 _1000_ 天之际表现出色，\
让你按照自己的方式做事，当你需要它时，它就在你身边。

**它是唯一同时拥有 [关系](/docs/rqb) 和 [SQL-like](/docs/select) 查询 API 的 ORM，** 
在访问你的关系数据时为你提供了两全其美的选择。 
Drizzle 轻巧、性能卓越、安全类型、无乳糖、无麸质、清醒、灵活，并且是 **天生支持无服务器的设计**。
Drizzle 不仅仅是一个库，它是一种体验。🤩

[![Drizzle bestofjs](@/assets/images/bestofjs.jpg)](https://bestofjs.org/projects/drizzle-orm)

## 无头 ORM？
首先，Drizzle 是一个库和一组可选的补充工具。

**ORM** 代表 _对象关系映射_，开发者通常将类似 Django 或 Spring 的工具称为 ORM。 
我们相信这是一种源于遗留命名的误解，我们称之为 **数据框架**。

<Callout type="error" emoji="️💔">
  使用数据框架，你必须围绕它们构建项目，而不是与它们一起构建。
</Callout>

**Drizzle** 让你以自己想要的方式构建项目，而不干扰你的项目或结构。

使用 Drizzle，你可以在 TypeScript 中定义和管理数据库架构，
按 SQL-like 或关系的方式访问你的数据，
并利用可选工具将你的开发者体验提升到一个新的高度。🤯

## 为什么 SQL-like？
**如果你懂 SQL，你就懂 Drizzle。**

其他 ORM 和数据框架往往使你远离 SQL，
这导致了双重学习曲线：需要同时了解 SQL 和框架的 API。

Drizzle 则恰恰相反。 
我们拥抱 SQL，构建 Drizzle 使其在核心上类似 SQL，这样你就几乎没有学习曲线，
并且可以完全发挥 SQL 的力量。

我们带来了所有熟悉的 **[SQL 架构](/docs/sql-schema-declaration)**、**[查询](/docs/select)**、 
**[自动迁移](/docs/migrations)** 和 **[另外一项](/docs/rqb)**。✨

<CodeTabs items={["index.ts", "schema.ts", "migration.sql"]}>
```typescript copy
// 访问你的数据
await db
	.select()
	.from(countries)
	.leftJoin(cities, eq(cities.countryId, countries.id))
	.where(eq(countries.id, 10))
```
```typescript copy
// 管理你的架构
export const countries = pgTable('countries', {
  id: serial('id').primaryKey(),
  name: varchar('name', { length: 256 }),
});

export const cities = pgTable('cities', {
  id: serial('id').primaryKey(),
  name: varchar('name', { length: 256 }),
  countryId: integer('country_id').references(() => countries.id),
});
```
```sql
-- 生成迁移
CREATE TABLE IF NOT EXISTS "countries" (
	"id" serial PRIMARY KEY NOT NULL,
	"name" varchar(256)
);

CREATE TABLE IF NOT EXISTS "cities" (
	"id" serial PRIMARY KEY NOT NULL,
	"name" varchar(256),
	"country_id" integer
);

ALTER TABLE "cities" ADD CONSTRAINT "cities_country_id_countries_id_fk" FOREIGN KEY ("country_id") REFERENCES "countries"("id") ON DELETE no action ON UPDATE no action;
```
</CodeTabs>

## 为什么不 SQL-like？
我们始终在追求一个完美平衡的解决方案，虽然 SQL-like 100% 满足需求， 
但在某些常见场景中，您可以更好地查询数据。

我们为你构建了 **[查询 API](/docs/rqb)**，这样你就可以以最便捷和高效的方式从数据库中获取关系嵌套数据，
而无需考虑连接和数据映射。

**Drizzle 始终输出准确的 1 条 SQL 查询。** 可以放心地将其与无服务器数据库一起使用，不用担心性能或往返成本！

```ts
const result = await db.query.users.findMany({
	with: {
		posts: true
	},
});
```

## 无服务器？
<Callout type="info" emoji="🥳">
  最棒的一点就是没有。**Drizzle 具有 0 个依赖！**
</Callout>


![Drizzle 轻便且准备好无服务器](@/assets/images/drizzle31kb.jpg)

Drizzle ORM 是特定于方言的，轻巧、高效，并且 **天生支持无服务器**。

我们花了大量时间确保你拥有一流的 SQL 方言支持，包括 Postgres、MySQL 和其他。

Drizzle 通过行业标准的数据库驱动程序原生运行。我们支持所有主要的 **[PostgreSQL](/docs/get-started-postgresql)**、**[MySQL](/docs/get-started-mysql)**、**[SQLite](/docs/get-started-sqlite)** 或 **[SingleStore](/docs/get-started-singlestore)**  驱动程序，并且我们正在 **[非常快速地](https://twitter.com/DrizzleORM/status/1653082492742647811?s=20)** 添加新的驱动程序。


## 欢迎加入！
越来越多的公司在生产中采用 Drizzle，体验到开发者体验和性能的巨大好处。

**我们始终在这里提供帮助，因此请随时联系我们。我们很乐意在你的 Drizzle 之旅中协助你！**

我们有一个杰出的 **[Discord 社区](https://driz.link/discord)**，欢迎所有开发者加入我们的 **[Twitter](https://twitter.com/drizzleorm)**。

现在去用 Drizzle 和你的 **[PostgreSQL](/docs/get-started-postgresql)**、**[MySQL](/docs/get-started-mysql)** 或 **[SQLite](/docs/get-started-sqlite)** 数据库构建一些令人惊叹的东西吧。🚀

### 视频展示

{/* tRPC + NextJS 应用路由 = 简单类型安全 API
Jack Herrington 19:17
https://www.youtube.com/watch?v=qCLV0Iaq9zU */}
{/* https://www.youtube.com/watch?v=qDunJ0wVIec */}
{/* https://www.youtube.com/watch?v=NZpPMlSAez0 */}

 {/* https://www.youtube.com/watch?v=-A0kMiJqQRY */}

<YoutubeCards cards={[
	{
		id: "vyU5mJGCJMw",
		title: "初学者的完整 Drizzle 课程",
		description: "Code Genix",
		time: "1:37:39",
	},
	{
		id: "7-NZ0MlPpJA",
		title: "60分钟学会 Drizzle",
		description: "Web Dev Simplified",
		time: "56:09"
	},
	{
		id: "i_mAHOhpBSA",
		title: "100秒了解 Drizzle ORM",
		description: "Fireship",
		time: "2:55"
	},
	{
		id: "hIYNOiZXQ7Y",
		title: "13分钟内学会 Drizzle ORM（速成课程）",
		description: "Neon",
		time: "14:00"
	},
	{
		id: "4ZhtoOFKFP8",
		title: "在 Next.js 14 中使用 Turso 和 Drizzle 设置数据库最简单的方法",
		description: "Sam Meech-Ward",
		time: '38:08'
	}, 
	{
		id: "NfVELsEZFsA",
		title: "Next.js 项目与 Vercel、Neon、Drizzle、TailwindCSS、FlowBite 等！",
		description: "CodingEntrepreneurs",
		time: '5:46:28'
	}, 
	{
		id: "_SLxGYzv6jo",
		title: "我有了一个新的最爱数据库工具",
		description: "Theo - t3.gg",
		time: '5:46'
	}, 
	{
		id: "Qo-RXkSwOtc",
		title: "Drizzle ORM 的初步印象 - 迁移、关系、查询！",
		description: "Marius Espejo",
		time: '33:52'
	},
	{
		id: "yXNEqyvA0OY",
		title: "我想学习 Drizzle ORM，因此我开始了另一个 next14 项目",
		description: "Web Dev Cody",
		time: "9:00"
	},
	{
		id: "h7vVhR-dFYo",
		title: "选择 ORM 变得越来越难...",
		description: "Ben Davis",
		time: "5:18"
	},
	{
		id: "8met6WTk0mQ",
		title: "这个新数据库工具真是游戏规则改变者",
		description: "Josh tried coding",
		time: "8:49"
	},
	{
		id: "woWW1T9DXEY",
		title: "我最喜欢的数据库工具变得更好",
		description: "Josh tried coding",
		time: "4:23"
	},
	{
		id: "A3l6YYkXzzg",
		title: "拥有实时光标的 SaaS Notion 克隆，Nextjs 13、Stripe、Drizzle ORM、Tailwind、Supabase、Sockets",
		description: "Web Prodigies",
		time: "11:41:46"
	},
	{
		id: "EQfaw5bDE1s",
		title: "SvelteKit + Drizzle 代码解析",
		description: "Ben Davis",
		time: "12:18"
	},
	{
		id: "b6VhN_HHDiQ",
		title: "构建一个多租户、基于角色的访问控制系统",
		description: "TomDoesTech",
		time: "2:01:29"
	},
	{
		id: "3tl9XCiQErA",
		title: "Prisma 的杀手终于来了",
		description: "SST",
		time: "5:42"
	},
	{
		id: "VQFjyEa8vGE",
		title: "学习 Drizzle ORM 并在一个 next14 项目上工作",
		description: "Web Dev Cody",
		time: "1:07:41"
	},
	{
		id: "5G0upg4sxgE",
		title: "这个技巧让我的最爱数据库工具变得更好",
		description: "Josh tried coding",
		time: "6:01"
	},
	{
		id: "-JnEuvPmt-Q",
		title: "在 Next.js 14 中轻松认证：使用 Auth.js 和 Drizzle ORM 实现安全登录",
		description: "Sam Meech-Ward",
		time: "26:29"
	},
]} />


Source: https://drizzle.zhcndoc.com/docs/perf-queries

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';

# 查询性能
谈到 **Drizzle** — 我们是一个薄薄的 TypeScript 层，位于 SQL 之上，几乎没有开销，
为了使其真正达到 0，您可以利用我们的预编译语句 API。

**当您在数据库上运行查询时，会发生几件事：**
- 查询构建器的所有配置都被连接到 SQL 字符串
- 该字符串和参数被发送到数据库驱动程序
- 驱动程序将 SQL 查询编译为二进制 SQL 执行格式并发送到数据库

通过预编译语句，您只需在 Drizzle ORM 端进行一次 SQL 连接，
然后数据库驱动程序就能够重用预编译的二进制 SQL，而不是每次都解析查询。
这在处理大型 SQL 查询时具有极大的性能优势。

不同的数据库驱动程序以不同的方式支持预编译语句，有时
Drizzle ORM 可以比 [**更好的 sqlite3 驱动程序更快。**](https://twitter.com/_alexblokh/status/1593593415907909634)

## 预编译语句
<Tabs items={["PostgreSQL", "MySQL", "SQLite", "SingleStore"]}>
  <Tab>
    ```typescript copy {3}
    const db = drizzle(...);

    const prepared = db.select().from(customers).prepare("statement_name");
    
    const res1 = await prepared.execute();
    const res2 = await prepared.execute();
    const res3 = await prepared.execute();
    ```
  </Tab> 
  <Tab>
    ```typescript copy {3}
    const db = drizzle(...);

    const prepared = db.select().from(customers).prepare();
    
    const res1 = await prepared.execute();
    const res2 = await prepared.execute();
    const res3 = await prepared.execute();
    ```
  </Tab> 
  <Tab>
    ```typescript copy {3}
    const db = drizzle(...);

    const prepared = db.select().from(customers).prepare();
    
    const res1 = prepared.all();
    const res2 = prepared.all();
    const res3 = prepared.all();
    ```
  </Tab> 
  <Tab>
    ```typescript copy {3}
    const db = drizzle(...);

    const prepared = db.select().from(customers).prepare();
    
    const res1 = await prepared.execute();
    const res2 = await prepared.execute();
    const res3 = await prepared.execute();
    ```
  </Tab> 
</Tabs>

## 占位符
每当您需要嵌入动态运行时值时 - 您可以使用 `sql.placeholder(...)` API
<Tabs items={["PostgreSQL", "MySQL", "SQLite", "SingleStore"]}>
  <Tab>
    ```ts {6,9-10,15,18}
    import { sql } from "drizzle-orm";

    const p1 = db
      .select()
      .from(customers)
      .where(eq(customers.id, sql.placeholder('id')))
      .prepare("p1")

    await p1.execute({ id: 10 }) // SELECT * FROM customers WHERE id = 10
    await p1.execute({ id: 12 }) // SELECT * FROM customers WHERE id = 12

    const p2 = db
      .select()
      .from(customers)
      .where(sql`lower(${customers.name}) like ${sql.placeholder('name')}`)
      .prepare("p2");

    await p2.execute({ name: '%an%' }) // SELECT * FROM customers WHERE name ilike '%an%'
    ```
  </Tab>
  <Tab>
    ```ts copy {6,9-10,15,18}
    import { sql } from "drizzle-orm";

    const p1 = db
      .select()
      .from(customers)
      .where(eq(customers.id, sql.placeholder('id')))
      .prepare()

    await p1.execute({ id: 10 }) // SELECT * FROM customers WHERE id = 10
    await p1.execute({ id: 12 }) // SELECT * FROM customers WHERE id = 12

    const p2 = db
      .select()
      .from(customers)
      .where(sql`lower(${customers.name}) like ${sql.placeholder('name')}`)
      .prepare();

    await p2.execute({ name: '%an%' }) // SELECT * FROM customers WHERE name ilike '%an%'
    ```
  </Tab>
  <Tab>
    ```ts copy {6,9-10,15,18}
    import { sql } from "drizzle-orm";

    const p1 = db
      .select()
      .from(customers)
      .where(eq(customers.id, sql.placeholder('id')))
      .prepare()

    p1.get({ id: 10 }) // SELECT * FROM customers WHERE id = 10
    p1.get({ id: 12 }) // SELECT * FROM customers WHERE id = 12

    const p2 = db
      .select()
      .from(customers)
      .where(sql`lower(${customers.name}) like ${sql.placeholder('name')}`)
      .prepare();

    p2.all({ name: '%an%' }) // SELECT * FROM customers WHERE name ilike '%an%'
    ```
  </Tab> 
  <Tab>
    ```ts copy {6,9-10,15,18}
    import { sql } from "drizzle-orm";

    const p1 = db
      .select()
      .from(customers)
      .where(eq(customers.id, sql.placeholder('id')))
      .prepare()

    await p1.execute({ id: 10 }) // SELECT * FROM customers WHERE id = 10
    await p1.execute({ id: 12 }) // SELECT * FROM customers WHERE id = 12

    const p2 = db
      .select()
      .from(customers)
      .where(sql`lower(${customers.name}) like ${sql.placeholder('name')}`)
      .prepare();

    await p2.execute({ name: '%an%' }) // SELECT * FROM customers WHERE name ilike '%an%'
    ```
  </Tab>
</Tabs>


Source: https://drizzle.zhcndoc.com/docs/perf-serverless

# Drizzle 无服务器性能

使用 `无服务器函数`（如 AWS Lambda 或 Vercel Server Functions，它们基于 AWS Lambda）可以获得巨大的好处，
因为它们可以运行最长达 15 分钟，并且可以重用数据库连接和预编译语句。

另一方面，`边缘函数` 在被调用后往往会立即清理，因此几乎没有性能优势。

要重用您的数据库连接和预编译语句，您只需在处理程序作用域之外声明它们：
```ts
const databaseConnection = ...;
const db = drizzle({ client: databaseConnection });
const prepared = db.select().from(...).prepare();

// AWS 处理程序
export const handler = async (event: APIGatewayProxyEvent) => {
  return prepared.execute();
}
```


Source: https://drizzle.zhcndoc.com/docs/prisma

import Npm from '@mdx/Npm.astro';
import Tabs from '@mdx/Tabs.astro';
import Tab from '@mdx/Tab.astro';
import CodeTabs from '@mdx/CodeTabs.astro';
import CodeTab from '@mdx/CodeTab.astro';
import Steps from '@mdx/Steps.astro';

# Drizzle 扩展用于 Prisma

如果您有一个现有的 Prisma 项目并想尝试 Drizzle 或逐步采用它，
您可以使用我们的优质扩展，该扩展会将 Drizzle API 添加到您的 Prisma 客户端中。
它将允许您在使用现有数据库连接的同时，结合使用 Drizzle 和 Prisma 查询。

## 如何使用

<Steps>
#### 安装依赖

您需要安装 Drizzle 本身和一个生成器包，该包将从 Prisma 模式生成 Drizzle 模式。
<Npm>
drizzle-orm@latest
-D drizzle-prisma-generator
</Npm>

#### 更新您的 Prisma 模式

将 Drizzle 生成器添加到您的 Prisma 模式中。`output` 是生成的 Drizzle 模式 TS 文件将放置的路径。
```prisma copy filename="schema.prisma" {5-8}
generator client {
  provider = "prisma-client-js"
}

generator drizzle {
  provider = "drizzle-prisma-generator"
  output   = "./drizzle" // 生成的 Drizzle 表的放置位置
}

// 其余 Prisma 模式

datasource db {
  provider = "postgresql"
  url      = env("DB_URL")
}

model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
}

...
```

#### 生成 Drizzle 模式

```bash
prisma generate
```

#### 将 Drizzle 扩展添加到您的 Prisma 客户端

<CodeTabs items={["PostgreSQL", "MySQL", "SQLite"]}>
<CodeTab>
```ts copy
import { PrismaClient } from '@prisma/client';
import { drizzle } from 'drizzle-orm/prisma/pg';

const prisma = new PrismaClient().$extends(drizzle());
```
</CodeTab>
<CodeTab>
```ts copy
import { PrismaClient } from '@prisma/client';
import { drizzle } from 'drizzle-orm/prisma/mysql';

const prisma = new PrismaClient().$extends(drizzle());
```
</CodeTab>
<CodeTab>
```ts copy
import { PrismaClient } from '@prisma/client';
import { drizzle } from 'drizzle-orm/prisma/sqlite';

const prisma = new PrismaClient().$extends(drizzle());
```
</CodeTab>
</CodeTabs>

#### 通过 `prisma.$drizzle` 运行 Drizzle 查询 ✨

为了使用 Drizzle 查询生成器，您需要对 Drizzle 表的引用。
您可以从您在生成器配置中指定的输出路径导入它们。

```ts copy
import { User } from './drizzle';

await prisma.$drizzle.insert().into(User).values({ email: 'sorenbs@drizzle.team', name: 'Søren' });
const users = await prisma.$drizzle.select().from(User);
```

</Steps>

## 限制

- 由于 [Prisma 驱动程序的限制](https://github.com/prisma/prisma/issues/17576)，不支持 [关系查询](/docs/rqb)。因此，Prisma 无法以数组格式返回查询结果，而这对于关系查询的工作是必需的。
- 在 SQLite 中，`.values()`（例如 `await db.select().from(table).values()`）不受支持，原因与上述相同。
- [预处理语句](/docs/perf-queries#prepared-statement) 的支持有限 - `.prepare()` 仅会在 Drizzle 端构建 SQL 查询，因为没有用于预处理查询的 Prisma API。


Source: https://drizzle.zhcndoc.com/docs/query-utils

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Callout from '@mdx/Callout.astro';
import Section from '@mdx/Section.astro';
import IsSupportedChipGroup from '@mdx/IsSupportedChipGroup.astro';
import $count from '@mdx/$count.mdx';

# Drizzle 查询工具

### $count
<$count/>

Source: https://drizzle.zhcndoc.com/docs/quick

import Npm from "@mdx/Npm.astro";

# 快速开始
让我们构建一个快速启动的应用程序，使用 `PostgreSQL` + `postgresjs` 并运行我们的第一个迁移。

我们需要做的第一件事是安装 `drizzle-orm` 和 `drizzle-kit`：

<Npm>
drizzle-orm postgres
-D drizzle-kit
</Npm>

现在让我们声明我们的 `schema.ts`：

```plaintext {4}
📦 <项目根目录>
 ├ ...
 ├ 📂 src
 │ └ 📜 schema.ts
 └ 📜 package.json
```
```ts copy filename="schema.ts"
import { serial, text, timestamp, pgTable } from "drizzle-orm/pg-core";

export const user = pgTable("user", {
  id: serial("id"),
  name: text("name"),
  email: text("email"),
  password: text("password"),
  role: text("role").$type<"admin" | "customer">(),
  createdAt: timestamp("created_at"),
  updatedAt: timestamp("updated_at"),
});
```

现在让我们添加 drizzle 配置文件：
```plaintext {4}
📦 <项目根目录>
 ├ ...
 ├ 📂 src
 ├ 📜 drizzle.config.ts
 └ 📜 package.json
```
```ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql",
  schema: "./src/schema.ts",
  out: "./drizzle",
});
```

将 `generate` 和 `migrate` 命令添加到 `package.json`，并运行我们的第一个迁移生成：

```json filename="package.json" {5,6}
{
  "name": "第一次?",
  "version": "0.0.1",
  "scripts": {
    "generate": "drizzle-kit generate",
    "migrate": "drizzle-kit migrate"
  }, 
}
```
```shell filename="terminal"
$ npm run generate
...

[✓] 你的 SQL 迁移文件 ➜ drizzle/0000_pale_mister_fear.sql 🚀
```

完成！我们现在有了我们的第一个 SQL 迁移文件 🥳
```plaintext {4}
📦 <项目根目录>
 ├ 📂 drizzle
 │ ├ 📂 _meta
 │ └ 📜 0000_pale_mister_fear.sql
 ├ 📂 src
 ├ 📜 drizzle.config.ts
 └ 📜 package.json
```
现在让我们将第一个迁移运行到数据库中：

```shell filename="terminal"
$ npm run migrate
```

就是这样，各位！  

**我个人的祝贺 🎉**

Source: https://drizzle.zhcndoc.com/docs/read-replicas

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';

# 阅读副本

当您的项目涉及一组读取副本实例，并且您需要一种便捷的方法来管理来自读取副本的 
SELECT 查询，以及在主实例上执行创建、删除和更新操作时，您可以在 Drizzle 中利用 
`withReplicas()` 函数。

<Tabs items={["PostgreSQL", "MySQL", "SQLite", "SingleStore"]}>
<Tab>
```ts copy
import { sql } from 'drizzle-orm';
import { drizzle } from 'drizzle-orm/node-postgres';
import { boolean, jsonb, pgTable, serial, text, timestamp, withReplicas } from 'drizzle-orm/pg-core';

const usersTable = pgTable('users', {
	id: serial('id' as string).primaryKey(),
	name: text('name').notNull(),
	verified: boolean('verified').notNull().default(false),
	jsonb: jsonb('jsonb').$type<string[]>(),
	createdAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),
});

const primaryDb = drizzle("postgres://user:password@host:port/primary_db");
const read1 = drizzle("postgres://user:password@host:port/read_replica_1");
const read2 = drizzle("postgres://user:password@host:port/read_replica_2");

const db = withReplicas(primaryDb, [read1, read2]);
```
</Tab>
<Tab>
```ts copy
import { drizzle } from "drizzle-orm/mysql2";
import mysql from "mysql2/promise";
import { boolean, mysqlTable, serial, text, withReplicas } from 'drizzle-orm/mysql-core';

const usersTable = mysqlTable('users', {
	id: serial('id' as string).primaryKey(),
	name: text('name').notNull(),
	verified: boolean('verified').notNull().default(false),
});

const primaryClient = await mysql.createConnection({
  host: "host",
  user: "user",
  database: "primary_db",
})
const primaryDb = drizzle({ client: primaryClient });

const read1Client = await mysql.createConnection({
  host: "host",
  user: "user",
  database: "read_1",
})
const read1 = drizzle({ client: read1Client });

const read2Client = await mysql.createConnection({
  host: "host",
  user: "user",
  database: "read_2",
})
const read2 = drizzle({ client: read2Client });

const db = withReplicas(primaryDb, [read1, read2]);
```
</Tab>
<Tab>
```ts copy
import { sql } from 'drizzle-orm';
import { sqliteTable, int, text, withReplicas } from 'drizzle-orm/sqlite-core';
import { createClient } from '@libsql/client';
import { drizzle } from 'drizzle-orm/libsql';

const usersTable = sqliteTable('users', {
	id: int('id' as string).primaryKey(),
	name: text('name').notNull(),
});

const primaryDb = drizzle({ client: createClient({ url: 'DATABASE_URL', authToken: 'DATABASE_AUTH_TOKEN' }) });
const read1 = drizzle({ client: createClient({ url: 'DATABASE_URL', authToken: 'DATABASE_AUTH_TOKEN' }) });
const read2 = drizzle({ client: createClient({ url: 'DATABASE_URL', authToken: 'DATABASE_AUTH_TOKEN' }) });

const db = withReplicas(primaryDb, [read1, read2]);
```
</Tab>
<Tab>
```ts copy
import { drizzle } from "drizzle-orm/singlestore";
import mysql from "mysql2/promise";
import { boolean, singlestoreTable, serial, text, withReplicas } from 'drizzle-orm/singlestore-core';

const usersTable = singlestoreTable('users', {
	id: serial('id' as string).primaryKey(),
	name: text('name').notNull(),
	verified: boolean('verified').notNull().default(false),
});

const primaryClient = await mysql.createConnection({
  host: "host",
  user: "user",
  database: "primary_db",
})
const primaryDb = drizzle({ client: primaryClient });

const read1Client = await mysql.createConnection({
  host: "host",
  user: "user",
  database: "read_1",
})
const read1 = drizzle({ client: read1Client });

const read2Client = await mysql.createConnection({
  host: "host",
  user: "user",
  database: "read_2",
})
const read2 = drizzle({ client: read2Client });

const db = withReplicas(primaryDb, [read1, read2]);
```
</Tab>
</Tabs>

您现在可以像之前一样使用 `db` 实例。
Drizzle 将自动处理读取副本和主实例之间的选择。

```ts
// 从 read1 连接或 read2 连接读取
await db.select().from(usersTable)

// 使用主数据库进行删除操作
await db.delete(usersTable).where(eq(usersTable.id, 1))
```

您可以使用 `$primary` 键强制即使在读取操作中也使用主实例。

```ts
// 从主实例读取
await db.$primary.select().from(usersTable);
```

使用 Drizzle，您还可以指定选择读取副本的自定义逻辑。
您可以做出加权决定或任何其他自定义选择方法以随机选择读取副本。
以下是选择读取副本的自定义逻辑实现示例，
第一个副本被选择的概率为 70%，
第二个副本被选择的概率为 30%。

请记住，您可以实施任何类型的随机选择方法来选择读取副本。

```ts
const db = withReplicas(primaryDb, [read1, read2], (replicas) => {
    const weight = [0.7, 0.3];
    let cumulativeProbability = 0;
    const rand = Math.random();

    for (const [i, replica] of replicas.entries()) {
      cumulativeProbability += weight[i]!;
      if (rand < cumulativeProbability) return replica;
    }
    return replicas[0]!
});

await db.select().from(usersTable)
```

Source: https://drizzle.zhcndoc.com/docs/relations

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import IsSupportedChipGroup from '@mdx/IsSupportedChipGroup.astro';
import Callout from '@mdx/Callout.astro';
import Section from '@mdx/Section.astro';

import CodeTab from '@mdx/CodeTab.astro';
import CodeTabs from '@mdx/CodeTabs.astro';

# Drizzle 软关系
Drizzle 关系的唯一目的是让您以最简单和简洁的方式查询您的关系数据：

<CodeTabs items={["关系查询", "带连接的选择"]}>
<Section>
```ts
import * as schema from './schema';
import { drizzle } from 'drizzle-orm/…';

const db = drizzle(client, { schema });

const result = db.query.users.findMany({
  with: {
    posts: true,
  },
});
```
```ts
[{
  id: 10,
  name: "Dan",
  posts: [
    {
      id: 1,
      content: "SQL 很棒",
      authorId: 10,
    },
    {
      id: 2,
      content: "但请检查关系查询",
      authorId: 10,
    }
  ]
}]
```
</Section>
<Section>
```ts
import { drizzle } from 'drizzle-orm/…';
import { eq } from 'drizzle-orm';
import { posts, users } from './schema';

const db = drizzle(client);

const res = await db.select()
                    .from(users)
                    .leftJoin(posts, eq(posts.authorId, users.id))
                    .orderBy(users.id)
const mappedResult =  
```
</Section>
</CodeTabs>


### 一对一
Drizzle ORM 为您提供 API，通过 `relations` 操作符定义表之间的 `一对一` 关系。

一个用户可以邀请另一个用户的 `一对一` 关系示例（此示例使用自引用）：

```typescript copy {10-15}
import { pgTable, serial, text, integer, boolean } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';

export const users = pgTable('users', {
	id: serial('id').primaryKey(),
	name: text('name'),
	invitedBy: integer('invited_by'),
});

export const usersRelations = relations(users, ({ one }) => ({
	invitee: one(users, {
		fields: [users.invitedBy],
		references: [users.id],
	}),
}));
```

另一个示例是用户在单独的表中存储的个人信息。在这种情况下，因为外键存储在“profile_info”表中，用户关系既没有字段也没有引用。这告诉 TypeScript `user.profileInfo` 是可选的：

```typescript copy {9-17}
import { pgTable, serial, text, integer, jsonb } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';

export const users = pgTable('users', {
	id: serial('id').primaryKey(),
	name: text('name'),
});

export const usersRelations = relations(users, ({ one }) => ({
	profileInfo: one(profileInfo),
}));

export const profileInfo = pgTable('profile_info', {
	id: serial('id').primaryKey(),
	userId: integer('user_id').references(() => users.id),
	metadata: jsonb('metadata'),
});

export const profileInfoRelations = relations(profileInfo, ({ one }) => ({
	user: one(users, { fields: [profileInfo.userId], references: [users.id] }),
}));

const user = await queryUserWithProfileInfo();
//____^? type { id: number, profileInfo: { ... } | null  }
```

### 一对多
Drizzle ORM 为您提供 API，通过 `relations` 操作符定义表之间的 `一对多` 关系。

用户与他们撰写的文章之间的 `一对多` 关系示例：

```typescript copy {9-11, 19-24}
import { pgTable, serial, text, integer } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';

export const users = pgTable('users', {
	id: serial('id').primaryKey(),
	name: text('name'),
});

export const usersRelations = relations(users, ({ many }) => ({
	posts: many(posts),
}));

export const posts = pgTable('posts', {
	id: serial('id').primaryKey(),
	content: text('content'),
	authorId: integer('author_id'),
});

export const postsRelations = relations(posts, ({ one }) => ({
	author: one(users, {
		fields: [posts.authorId],
		references: [users.id],
	}),
}));
```

现在让我们为文章添加评论：
```typescript copy {14,17-22,24-29}
...

export const posts = pgTable('posts', {
	id: serial('id').primaryKey(),
	content: text('content'),
	authorId: integer('author_id'),
});

export const postsRelations = relations(posts, ({ one, many }) => ({
	author: one(users, {
		fields: [posts.authorId],
		references: [users.id],
	}),
	comments: many(comments)
}));

export const comments = pgTable('comments', {
	id: serial('id').primaryKey(),
	text: text('text'),
	authorId: integer('author_id'),
	postId: integer('post_id'),
});

export const commentsRelations = relations(comments, ({ one }) => ({
	post: one(posts, {
		fields: [comments.postId],
		references: [posts.id],
	}),
}));
```


### 多对多
Drizzle ORM 为您提供 API，通过所谓的 `junction` 或 `join` 表定义表之间的 `多对多` 关系，
它们必须显式定义并存储相关表之间的关联。

用户与组之间的 `多对多` 关系示例：
```typescript copy {9-11, 18-20, 37-46}
import { relations } from 'drizzle-orm';
import { integer, pgTable, primaryKey, serial, text } from 'drizzle-orm/pg-core';

export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name'),
});

export const usersRelations = relations(users, ({ many }) => ({
  usersToGroups: many(usersToGroups),
}));

export const groups = pgTable('groups', {
  id: serial('id').primaryKey(),
  name: text('name'),
});

export const groupsRelations = relations(groups, ({ many }) => ({
  usersToGroups: many(usersToGroups),
}));

export const usersToGroups = pgTable(
  'users_to_groups',
  {
    userId: integer('user_id')
      .notNull()
      .references(() => users.id),
    groupId: integer('group_id')
      .notNull()
      .references(() => groups.id),
  },
  (t) => [
		primaryKey({ columns: [t.userId, t.groupId] })
	],
);

export const usersToGroupsRelations = relations(usersToGroups, ({ one }) => ({
  group: one(groups, {
    fields: [usersToGroups.groupId],
    references: [groups.id],
  }),
  user: one(users, {
    fields: [usersToGroups.userId],
    references: [users.id],
  }),
}));
```

### 外键

您可能已经注意到，`relations` 看起来与外键相似——它们甚至有一个 `references` 属性。那么区别是什么呢？

虽然外键也服务于相似的目的，定义表之间的关系，但它们与 `relations` 在不同级别上工作。

外键是一个数据库级别的约束，它们在每个 `insert`/`update`/`delete` 操作时都会被检查，如果违反约束则会抛出错误。
另一方面，`relations` 是一个更高层次的抽象，仅用于在应用程序级别定义表之间的关系。
它们不会以任何方式影响数据库模式，并且不会隐式创建外键。

这意味着 `relations` 和外键可以一起使用，但它们彼此之间并不依赖。
您可以定义 `relations` 而不使用外键（反之亦然），这使得它们与不支持外键的数据库一起使用成为可能。

以下两个示例在使用 Drizzle 关系查询时，查询数据的方式完全相同。
<CodeTabs items={["schema1.ts", "schema2.ts"]}>
<CodeTab>
```ts {15}
export const users = pgTable('users', {
	id: serial('id').primaryKey(),
	name: text('name'),
});

export const usersRelations = relations(users, ({ one, many }) => ({
	profileInfo: one(users, {
		fields: [profileInfo.userId],
		references: [users.id],
	}),
}));

export const profileInfo = pgTable('profile_info', {
	id: serial('id').primaryKey(),
	userId: integer("user_id"),
	metadata: jsonb("metadata"),
});
```
</CodeTab>
<CodeTab>
```ts {15}
export const users = pgTable('users', {
	id: serial('id').primaryKey(),
	name: text('name'),
});

export const usersRelations = relations(users, ({ one, many }) => ({
	profileInfo: one(users, {
		fields: [profileInfo.userId],
		references: [users.id],
	}),
}));

export const profileInfo = pgTable('profile_info', {
	id: serial('id').primaryKey(),
	userId: integer("user_id").references(() => users.id),
	metadata: jsonb("metadata"),
});
```
</CodeTab>
</CodeTabs>

### 外键操作

有关更多信息，请查看 [PostgreSQL 外键文档](https://www.postgresql.org/docs/current/ddl-constraints.html#DDL-CONSTRAINTS-FK)。

您可以指定在父表中引用的数据被修改时应发生的操作。这些操作称为“外键操作”。PostgreSQL 提供了几种选项用于这些操作。

删除/更新操作

- `CASCADE`：删除父表中的行时，子表中的所有相应行也将被删除。这确保了子表中不存在孤立行。

- `NO ACTION`：这是默认操作。如果子表中有相关行，它会阻止删除父表中的行。父表中的 DELETE 操作将失败。

- `RESTRICT`：与 NO ACTION 类似，如果子表中有依赖行，它会阻止删除父行。它基本上与 NO ACTION 相同，并由于兼容性原因被包含在内。

- `SET DEFAULT`：如果父表中的行被删除，子表中的外键列将被设置为其默认值（如果有）。如果没有默认值，DELETE 操作将失败。

- `SET NULL`：当父表中的行被删除时，子表中的外键列将被设置为 NULL。此操作假设子表中的外键列允许 NULL 值。

> 与 ON DELETE 类似，当引用的列被更改（更新）时，还存在 ON UPDATE。可能的操作是相同的，只是 SET NULL 和 SET DEFAULT 不能指定列列表。在这种情况下，CASCADE 意味着引用列的更新值应复制到引用行。
在 drizzle 中，您可以使用 `references()` 的第二个参数添加外键操作。

操作类型

```typescript
export type UpdateDeleteAction = 'cascade' | 'restrict' | 'no action' | 'set null' | 'set default';

// references 接口的第二个参数
actions?: {
		onUpdate?: UpdateDeleteAction;
		onDelete?: UpdateDeleteAction;
	} | undefined
```

在以下示例中，将 `onDelete: 'cascade'` 添加到 `posts` 模式中的作者字段意味着删除 `user` 也将删除所有相关的 Post 记录。


```typescript {11}
import { pgTable, serial, text, integer } from 'drizzle-orm/pg-core';

export const users = pgTable('users', {
	id: serial('id').primaryKey(),
	name: text('name'),
});

export const posts = pgTable('posts', {
	id: serial('id').primaryKey(),
	name: text('name'),
	author: integer('author').references(() => users.id, {onDelete: 'cascade'}).notNull(),
});
```

对于使用 `foreignKey` 操作符指定的约束，外键操作的定义语法为：

```typescript {18-19}
import { foreignKey, pgTable, serial, text, integer } from 'drizzle-orm/pg-core';

export const users = pgTable('users', {
	id: serial('id').primaryKey(),
	name: text('name'),
});

export const posts = pgTable('posts', {
	id: serial('id').primaryKey(),
	name: text('name'),
	author: integer('author').notNull(),
}, (table) => [
	foreignKey({
		name: "author_fk",
		columns: [table.author],
		foreignColumns: [users.id],
	})
		.onDelete('cascade')
		.onUpdate('cascade')
]);
```

### 消歧义关系

Drizzle 还提供 `relationName` 
选项作为在您定义相同两张表之间的多个关系时消歧义的方式。
例如，如果您定义一张包含 `author` 和 `reviewer` 
关系的 `posts` 表。

```ts {9-12, 21-32}
import { pgTable, serial, text, integer } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';
 
export const users = pgTable('users', {
	id: serial('id').primaryKey(),
	name: text('name'),
});
 
export const usersRelations = relations(users, ({ many }) => ({
	author: many(posts, { relationName: 'author' }),
	reviewer: many(posts, { relationName: 'reviewer' }),
}));
 
export const posts = pgTable('posts', {
	id: serial('id').primaryKey(),
	content: text('content'),
	authorId: integer('author_id'),
	reviewerId: integer('reviewer_id'),
});
 
export const postsRelations = relations(posts, ({ one }) => ({
	author: one(users, {
		fields: [posts.authorId],
		references: [users.id],
		relationName: 'author',
	}),
	reviewer: one(users, {
		fields: [posts.reviewerId],
		references: [users.id],
		relationName: 'reviewer',
	}),
}));
```


Source: https://drizzle.zhcndoc.com/docs/rls

import Callout from '@mdx/Callout.astro';

# 行级安全性 (RLS)

使用 Drizzle，您可以为任何 Postgres 表启用行级安全性 (RLS)，创建具有各种选项的策略，并定义和管理这些策略所应用的角色。

Drizzle 支持 Postgres 策略和角色的原始表示，您可以以任何方式使用它们。 这与流行的 Postgres 数据库提供者如 `Neon` 和 `Supabase` 一起工作。

在 Drizzle 中，我们为两个数据库提供者提供了特定的预定义 RLS 角色和函数，但您也可以定义自己的逻辑。

## 启用 RLS

如果您只想在表上启用 RLS 而不添加策略，可以使用 `.enableRLS()`

正如 PostgreSQL 文档中所提到的：

> 如果表中不存在策略，则使用默认拒绝策略，这意味着没有行可以被查看或修改。
适用于整个表的操作，如 TRUNCATE 和 REFERENCES，不受行安全性的限制。

```ts
import { integer, pgTable } from 'drizzle-orm/pg-core';

export const users = pgTable('users', {
	id: integer(),
}).enableRLS();
```

<Callout title='重要'>
如果您向表添加策略，RLS 将自动启用。因此，在向表添加策略时无需显式启用 RLS。
</Callout>

## 角色

目前，Drizzle 支持通过几种不同的选项定义角色，如下所示。将来版本将添加对更多选项的支持。

```ts
import { pgRole } from 'drizzle-orm/pg-core';

export const admin = pgRole('admin', { createRole: true, createDb: true, inherit: true });
```

如果数据库中已经存在角色，并且您不想让 drizzle-kit “看到”它或包含它在迁移中，可以将角色标记为现有。

```ts
import { pgRole } from 'drizzle-orm/pg-core';

export const admin = pgRole('admin').existing();
```

## 策略

要充分利用 RLS，您可以在 Drizzle 表中定义策略。

<Callout title='信息'>
在 PostgreSQL 中，策略应该与现有表关联。由于策略总是与特定表相关联，我们决定将策略定义作为 `pgTable` 的参数进行定义。
</Callout>

**pgPolicy 的示例，包含所有可用属性**
```ts
import { sql } from 'drizzle-orm';
import { integer, pgPolicy, pgRole, pgTable } from 'drizzle-orm/pg-core';

export const admin = pgRole('admin');

export const users = pgTable('users', {
	id: integer(),
}, (t) => [
	pgPolicy('policy', {
		as: 'permissive',
		to: admin,
		for: 'delete',
		using: sql``,
		withCheck: sql``,
	}),
]);
```

**策略选项**
|                          |                                                                                                                                           |
| :----------------------- | :---------------------------------------------------------------------------------------------------------------------------------------- |
| `as`                     | 可能的值为 `permissive` 或 `restrictive`                                                                                                 |
| `to`                     | 指定策略适用的角色。可能的值包括 `public`、`current_role`、`current_user`、`session_user`，或任何其他角色名作为字符串。您也可以引用一个 `pgRole` 对象。 |
| `for`                    | 定义此策略将应用的命令。可能的值为 `all`、`select`、`insert`、`update`、`delete`。                                                       |
| `using`                  | 将应用于策略创建语句的 `USING` 部分的 SQL 语句。                                                                                             |
| `withCheck`              | 将应用于策略创建语句的 `WITH CHECK` 部分的 SQL 语句。                                                                                        |


**将策略链接到现有表**

在某些情况下，您需要将策略链接到数据库中的现有表。 
最常见的用例是与 `Neon` 或 `Supabase` 等数据库提供者一起使用，您需要向其现有表中添加策略。
在这种情况下，您可以使用 `.link()` API。

```ts
import { sql } from "drizzle-orm";
import { pgPolicy } from "drizzle-orm/pg-core";
import { authenticatedRole, realtimeMessages } from "drizzle-orm/supabase";

export const policy = pgPolicy("authenticated role insert policy", {
  for: "insert",
  to: authenticatedRole,
  using: sql``,
}).link(realtimeMessages);
```

{/* <Callout title='重要'>
<Callout> */}

## 迁移

如果您使用 drizzle-kit 来管理您的架构和角色，可能会出现您想引用未在 Drizzle 架构中定义的角色的情况。在这种情况下，您可能希望 drizzle-kit 跳过管理这些角色，而不必在您的 drizzle 架构中定义每个角色，并标记为 `.existing()`。

在这些情况下，您可以在 `drizzle.config.ts` 中使用 `entities.roles`。有关完整的参考，请参阅 [`drizzle.config.ts`](docs/drizzle-config-file) 文档。

默认情况下，`drizzle-kit` 不会为您管理角色，因此您需要在 `drizzle.config.ts` 中启用此功能。

```ts {12-14}
// drizzle.config.ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: 'postgresql',
  schema: "./drizzle/schema.ts",
  dbCredentials: {
    url: process.env.DATABASE_URL!
  },
  verbose: true,
  strict: true,
  entities: {
    roles: true
  }
});
```

如果您需要其他配置选项，我们可以看一些更多的示例。

**您有一个 `admin` 角色，并希望将其排除在可管理角色列表之外**

```ts
// drizzle.config.ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  ...
  entities: {
    roles: {
      exclude: ['admin']
    }
  }
});
```

**您有一个 `admin` 角色，并希望将其包括在可管理角色列表中**

```ts
// drizzle.config.ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  ...
  entities: {
    roles: {
      include: ['admin']
    }
  }
});
```

**如果您使用 `Neon`，并希望排除 Neon 定义的角色，则可以使用提供者选项**

```ts
// drizzle.config.ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  ...
  entities: {
    roles: {
      provider: 'neon'
    }
  }
});
```

**如果您使用 `Supabase`，并希望排除 Supabase 定义的角色，则可以使用提供者选项**

```ts
// drizzle.config.ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  ...
  entities: {
    roles: {
      provider: 'supabase'
    }
  }
});
```

<Callout title='重要'>
您可能会遇到 Drizzle 与数据库提供者指定的新角色相比略显过时的情况。 
在这种情况下，您可以使用 `provider` 选项和 `exclude` 除其他角色：

```ts
// drizzle.config.ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  ...
  entities: {
    roles: {
      provider: 'supabase',
      exclude: ['new_supabase_role']
    }
  }
});
```
</Callout>

## RLS 在视图上

使用 Drizzle，您还可以在视图上指定 RLS 策略。为此，您需要在视图的 WITH 选项中使用 `security_invoker`。这是一个小示例：

```ts {5}
...

export const roomsUsersProfiles = pgView("rooms_users_profiles")
  .with({
    securityInvoker: true,
  })
  .as((qb) =>
    qb
      .select({
        ...getTableColumns(roomsUsers),
        email: profiles.email,
      })
      .from(roomsUsers)
      .innerJoin(profiles, eq(roomsUsers.userId, profiles.id))
  );
```

## 与 Neon 一起使用

Neon 团队帮助我们实现了他们对我们原始策略 API 的包装器的愿景。我们定义了一个特定的 
`/neon` 导入，其中包含 `crudPolicy` 函数，其中包含预定义函数和 Neon 的默认角色。

这是如何使用 `crudPolicy` 函数的示例：

```ts
import { crudPolicy } from 'drizzle-orm/neon';
import { integer, pgRole, pgTable } from 'drizzle-orm/pg-core';

export const admin = pgRole('admin');

export const users = pgTable('users', {
	id: integer(),
}, (t) => [
	crudPolicy({ role: admin, read: true, modify: false }),
]);
```

此策略等效于：

```ts
import { sql } from 'drizzle-orm';
import { integer, pgPolicy, pgRole, pgTable } from 'drizzle-orm/pg-core';

export const admin = pgRole('admin');

export const users = pgTable('users', {
	id: integer(),
}, (t) => [
	pgPolicy(`crud-${admin.name}-policy-insert`, {
		for: 'insert',
		to: admin,
		withCheck: sql`false`,
	}),
	pgPolicy(`crud-${admin.name}-policy-update`, {
		for: 'update',
		to: admin,
		using: sql`false`,
		withCheck: sql`false`,
	}),
	pgPolicy(`crud-${admin.name}-policy-delete`, {
		for: 'delete',
		to: admin,
		using: sql`false`,
	}),
	pgPolicy(`crud-${admin.name}-policy-select`, {
		for: 'select',
		to: admin,
		using: sql`true`,
	}),
]);
```

`Neon` 公开了预定义的 `authenticated` 和 `anonymous` 角色及相关函数。如果您使用 `Neon` 进行 RLS，可以在您的 RLS 查询中使用这些标记为现有的角色以及相关函数。

```ts
// drizzle-orm/neon
export const authenticatedRole = pgRole('authenticated').existing();
export const anonymousRole = pgRole('anonymous').existing();

export const authUid = (userIdColumn: AnyPgColumn) => sql`(select auth.user_id() = ${userIdColumn})`;

export const neonIdentitySchema = pgSchema('neon_identity');

export const usersSync = neonIdentitySchema.table('users_sync', {
  rawJson: jsonb('raw_json').notNull(),
  id: text().primaryKey().notNull(),
  name: text(),
  email: text(),
  createdAt: timestamp('created_at', { withTimezone: true, mode: 'string' }),
  deletedAt: timestamp('deleted_at', { withTimezone: true, mode: 'string' }),
});
```

例如，您可以像这样使用 `Neon` 预定义的角色和函数：


```ts
import { sql } from 'drizzle-orm';
import { authenticatedRole } from 'drizzle-orm/neon';
import { integer, pgPolicy, pgRole, pgTable } from 'drizzle-orm/pg-core';

export const admin = pgRole('admin');

export const users = pgTable('users', {
	id: integer(),
}, (t) => [
	pgPolicy(`policy-insert`, {
		for: 'insert',
		to: authenticatedRole,
		withCheck: sql`false`,
	}),
]);
```

## 与 Supabase 一起使用

我们还有一个 `/supabase` 导入，带有一组标记为现有的预定义角色，您可以在架构中使用它。 
这个导入将在未来的发布中扩展，提供更多功能和帮助器，使 RLS 和 `Supabase` 的使用更加简单。

```ts
// drizzle-orm/supabase
export const anonRole = pgRole('anon').existing();
export const authenticatedRole = pgRole('authenticated').existing();
export const serviceRole = pgRole('service_role').existing();
export const postgresRole = pgRole('postgres_role').existing();
export const supabaseAuthAdminRole = pgRole('supabase_auth_admin').existing();
```

例如，您可以像这样使用 `Supabase` 预定义的角色：

```ts
import { sql } from 'drizzle-orm';
import { serviceRole } from 'drizzle-orm/supabase';
import { integer, pgPolicy, pgRole, pgTable } from 'drizzle-orm/pg-core';

export const admin = pgRole('admin');

export const users = pgTable('users', {
	id: integer(),
}, (t) => [
	pgPolicy(`policy-insert`, {
		for: 'insert',
		to: serviceRole,
		withCheck: sql`false`,
	}),
]);
```

`/supabase` 导入还包括您可以在应用程序中使用的预定义表和函数。

```ts
// drizzle-orm/supabase

const auth = pgSchema('auth');
export const authUsers = auth.table('users', {
	id: uuid().primaryKey().notNull(),
});

const realtime = pgSchema('realtime');
export const realtimeMessages = realtime.table(
	'messages',
	{
		id: bigserial({ mode: 'bigint' }).primaryKey(),
		topic: text().notNull(),
		extension: text({
			enum: ['presence', 'broadcast', 'postgres_changes'],
		}).notNull(),
	},
);

export const authUid = sql`(select auth.uid())`;
export const realtimeTopic = sql`realtime.topic()`;
```

这使您可以在代码中使用它，而 Drizzle Kit 将其视为现有数据库，
仅将其作为连接到其他实体的信息使用。

```ts
import { foreignKey, pgPolicy, pgTable, text, uuid } from "drizzle-orm/pg-core";
import { sql } from "drizzle-orm/sql";
import { authenticatedRole, authUsers } from "drizzle-orm/supabase";

export const profiles = pgTable(
  "profiles",
  {
    id: uuid().primaryKey().notNull(),
    email: text().notNull(),
  },
  (table) => [
    foreignKey({
      columns: [table.id],
	  // 从 Supabase 的 auth 表的引用
      foreignColumns: [authUsers.id],
      name: "profiles_id_fk",
    }).onDelete("cascade"),
    pgPolicy("authenticated can view all profiles", {
      for: "select",
	  // 使用来自 Supabase 的预定义角色
      to: authenticatedRole,
      using: sql`true`,
    }),
  ]
);
```

让我们检查一个向存在于 `Supabase` 的表添加策略的示例。

```ts
import { sql } from "drizzle-orm";
import { pgPolicy } from "drizzle-orm/pg-core";
import { authenticatedRole, realtimeMessages } from "drizzle-orm/supabase";

export const policy = pgPolicy("authenticated role insert policy", {
  for: "insert",
  to: authenticatedRole,
  using: sql``,
}).link(realtimeMessages);
```

我们还有一个很好的示例，展示了如何将 Drizzle RLS 与 Supabase 一起使用以及如何进行实际查询。 
它还包含一个很好的包装器 `createDrizzle`，可以处理与 Supabase 的所有事务工作。 
在即将发布的版本中，它将被转移到 drizzle-orm/supabase，允许您本地使用它。

请检查 [Drizzle SupaSecureSlack repo](https://github.com/rphlmr/drizzle-supabase-rls)

这是来自该库的一个实现示例：
```ts
type SupabaseToken = {
  iss?: string;
  sub?: string;
  aud?: string[] | string;
  exp?: number;
  nbf?: number;
  iat?: number;
  jti?: string;
  role?: string;
};

export function createDrizzle(token: SupabaseToken, { admin, client }: { admin: PgDatabase<any>; client: PgDatabase<any> }) {
  return {
    admin,
    rls: (async (transaction, ...rest) => {
      return await client.transaction(async (tx) => {
        // Supabase 暴露了 auth.uid() 和 auth.jwt()
        // https://supabase.com/docs/guides/database/postgres/row-level-security#helper-functions
        try {
          await tx.execute(sql`
          -- auth.jwt()
          select set_config('request.jwt.claims', '${sql.raw(
            JSON.stringify(token)
          )}', TRUE);
          -- auth.uid()
          select set_config('request.jwt.claim.sub', '${sql.raw(
            token.sub ?? ""
          )}', TRUE);												
          -- 设置本地角色
          set local role ${sql.raw(token.role ?? "anon")};
          `);
          return await transaction(tx);
        } finally {
          await tx.execute(sql`
            -- 重置
            select set_config('request.jwt.claims', NULL, TRUE);
            select set_config('request.jwt.claim.sub', NULL, TRUE);
            reset role;
            `);
        }
      }, ...rest);
    }) as typeof client.transaction,
  };
}
```

并且可以这样使用：

```ts
// https://github.com/orgs/supabase/discussions/23224
// 应该是安全的，因为我们使用签名的访问令牌，而不是直接从存储中读取的数据
export async function createDrizzleSupabaseClient() {
  const {
    data: { session },
  } = await createClient().auth.getSession();
  return createDrizzle(decode(session?.access_token ?? ""), { admin, client });
}

async function getRooms() {
  const db = await createDrizzleSupabaseClient();
  return db.rls((tx) => tx.select().from(rooms));
}
```

Source: https://drizzle.zhcndoc.com/docs/rqb

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Callout from '@mdx/Callout.astro';
import CodeTabs from '@mdx/CodeTabs.astro';
import CodeTab from '@mdx/CodeTab.astro';
import Section from '@mdx/Section.astro';
import IsSupportedChipGroup from '@mdx/IsSupportedChipGroup.astro';

# Drizzle 查询

<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'SQLite': true, 'MySQL': true, 'SingleStore': false }} />

Drizzle ORM 旨在成为 SQL 之上的一个薄型类型层。  
我们真心相信我们设计了从 TypeScript 操作 SQL 数据库的最佳方法，现在是时候使其更出色了。  
  
关系查询旨在为您提供出色的开发者体验，
以便从 SQL 数据库中查询嵌套的关系数据，避免多个连接和复杂的数据映射。  

它是现有模式定义和查询构建器的扩展。  
您可以根据自己的需求选择使用它。  
我们确保为您提供最优秀的开发者体验和性能。  

<CodeTabs items={["index.ts", "schema.ts"]}>
	<CodeTab>
	```typescript copy /schema/3
	import * as schema from './schema';
	import { drizzle } from 'drizzle-orm/...';

	const db = drizzle({ schema });

	const result = await db.query.users.findMany({
		with: {
			posts: true			
		},
	});
	```

	```ts
	[{
		id: 10,
		name: "Dan",
		posts: [
			{
				id: 1,
				content: "SQL 是很棒的",
				authorId: 10,
			},
			{
				id: 2,
				content: "但请检查关系查询",
				authorId: 10,
			}
		]
	}]
	```
	</CodeTab>

	```typescript copy
	import { integer, serial, text, pgTable } from 'drizzle-orm/pg-core';
	import { relations } from 'drizzle-orm';

	export const users = pgTable('users', {
		id: serial('id').primaryKey(),
		name: text('name').notNull(),
	});

	export const usersRelations = relations(users, ({ many }) => ({
		posts: many(posts),
	}));

	export const posts = pgTable('posts', {
		id: serial('id').primaryKey(),
		content: text('content').notNull(),
		authorId: integer('author_id').notNull(),
	});

	export const postsRelations = relations(posts, ({ one }) => ({
		author: one(users, { fields: [posts.authorId], references: [users.id] }),
	}));
	```
</CodeTabs>

⚠️ 如果您在多个文件中声明 SQL 模式，您可以这样做：
<CodeTabs items={["index.ts", "schema1.ts", "schema2.ts"]}>
	```typescript copy /schema/3
	import * as schema1 from './schema1';
	import * as schema2 from './schema2';
	import { drizzle } from 'drizzle-orm/...';

	const db = drizzle({ schema: { ...schema1, ...schema2 } });

	const result = await db.query.users.findMany({
		with: {
			posts: true			
		},
	});
	```
	
	```ts
	// 第一个文件中的模式声明
	```
	```ts
	// 第二个文件中的模式声明
	```
</CodeTabs>


## 模式
Drizzle 关系查询总是生成一个 SQL 语句在数据库上运行，并且有一些注意事项。  
为了对每种数据库提供最佳支持，我们引入了 **`modes`**。  

Drizzle 关系查询在底层使用子查询的侧向连接，目前 PlanetScale 不支持它们。

当使用 **mysql2** 驱动程序与常规 **MySQL** 数据库时 — 你应该指定 `mode: "default"`，
当使用 **mysql2** 驱动程序与 **PlanetScale** 时 — 你需要指定 `mode: "planetscale"`。

```ts copy
import * as schema from './schema';
import { drizzle } from "drizzle-orm/mysql2";
import mysql from "mysql2/promise";

const connection = await mysql.createConnection({
  uri: process.env.PLANETSCALE_DATABASE_URL,
});

const db = drizzle({ client: connection, schema, mode: 'planetscale' });
```

## 查询
关系查询是 Drizzle 原始 **[查询构建器](/docs/select)** 的一个扩展。  
您需要在 `drizzle()` 初始化时提供来自您的模式文件/文件的所有 `tables` 和 `relations` ，
然后只需使用 `db.query` API。  
<Callout type="info" emoji="ℹ️">  
	`drizzle` 的导入路径取决于您使用的 **[数据库驱动程序](/docs/connect-overview)**。  
</Callout>  
<CodeTabs items={["index.ts", "schema.ts"]}>
<CodeTab>
```ts
import * as schema from './schema';
import { drizzle } from 'drizzle-orm/...';

const db = drizzle({ schema });

await db.query.users.findMany(...);
```
```ts
// 如果您在多个文件中有模式
import * as schema1 from './schema1';
import * as schema2 from './schema2';
import { drizzle } from 'drizzle-orm/...';

const db = drizzle({ schema: { ...schema1, ...schema2 } });

await db.query.users.findMany(...);
```
</CodeTab>
```typescript copy
	import { type AnyPgColumn, boolean, integer, pgTable, primaryKey, serial, text, timestamp } from 'drizzle-orm/pg-core';

	import { relations } from 'drizzle-orm';

	export const users = pgTable('users', {
		id: serial('id').primaryKey(),
		name: text('name').notNull(),
		verified: boolean('verified').notNull(),
		invitedBy: integer('invited_by').references((): AnyPgColumn => users.id),
	});

	export const usersRelations = relations(users, ({ one, many }) => ({
		invitee: one(users, { fields: [users.invitedBy], references: [users.id] }),
		usersToGroups: many(usersToGroups),
		posts: many(posts),
	}));

	export const groups = pgTable('groups', {
		id: serial('id').primaryKey(),
		name: text('name').notNull(),
		description: text('description'),
	});

	export const groupsRelations = relations(groups, ({ many }) => ({
		usersToGroups: many(usersToGroups),
	}));

	export const usersToGroups = pgTable('users_to_groups', {
		id: serial('id').primaryKey(),
		userId: integer('user_id').notNull().references(() => users.id),
		groupId: integer('group_id').notNull().references(() => groups.id),
	}, (t) => [
		primaryKey({ columns: [t.userId, t.groupId] })
	]);

	export const usersToGroupsRelations = relations(usersToGroups, ({ one }) => ({
		group: one(groups, { fields: [usersToGroups.groupId], references: [groups.id] }),
		user: one(users, { fields: [usersToGroups.userId], references: [users.id] }),
	}));

	export const posts = pgTable('posts', {
		id: serial('id').primaryKey(),
		content: text('content').notNull(),
		authorId: integer('author_id').references(() => users.id),
		createdAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),
	});

	export const postsRelations = relations(posts, ({ one, many }) => ({
		author: one(users, { fields: [posts.authorId], references: [users.id] }),
		comments: many(comments),
	}));

	export const comments = pgTable('comments', {
		id: serial('id').primaryKey(),
		content: text('content').notNull(),
		creator: integer('creator').references(() => users.id),
		postId: integer('post_id').references(() => posts.id),
		createdAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),
	});

	export const commentsRelations = relations(comments, ({ one, many }) => ({
		post: one(posts, { fields: [comments.postId], references: [posts.id] }),
		author: one(users, { fields: [comments.creator], references: [users.id] }),
		likes: many(commentLikes),
	}));

	export const commentLikes = pgTable('comment_likes', {
		id: serial('id').primaryKey(),
		creator: integer('creator').references(() => users.id),
		commentId: integer('comment_id').references(() => comments.id),
		createdAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),
	});

	export const commentLikesRelations = relations(commentLikes, ({ one }) => ({
		comment: one(comments, { fields: [commentLikes.commentId], references: [comments.id] }),
		author: one(users, { fields: [commentLikes.creator], references: [users.id] }),
	}));
```
</CodeTabs>

Drizzle 提供 `.findMany()` 和 `.findFirst()` API。  
### 查找多个
<Section>
```typescript copy
const users = await db.query.users.findMany();
```
```ts
// 结果类型
const result: {
	id: number;
	name: string;
	verified: boolean;
	invitedBy: number | null;
}[];
```
</Section>

### 查找第一个
<Callout>
  `.findFirst()` 会在查询中添加 `limit 1`。
</Callout>
<Section>
```typescript copy
const user = await db.query.users.findFirst();
```
```ts
// 结果类型
const result: {
	id: number;
	name: string;
	verified: boolean;
	invitedBy: number | null;
};
```
</Section>

### 包括关系

`With` 操作符允许您从多个相关表中组合数据并正确聚合结果。

**获取所有带评论的帖子：**
```typescript copy
const posts = await db.query.posts.findMany({
	with: {
		comments: true,
	},
});
```

**获取第一个带评论的帖子：**
```typescript copy
const post = await db.query.posts.findFirst({
	with: {
		comments: true,
	},
});
```

您可以根据需要链式调用嵌套的 with 语句。  
对于任何嵌套的 `with` 查询，Drizzle 将使用 [Core Type API](/docs/goodies#type-api) 推断类型。
  
**获取所有用户及其帖子。每个帖子应包含评论列表：**
```typescript copy
const users = await db.query.users.findMany({
	with: {
		posts: {
			with: {
				comments: true,
			},
		},
	},
});
```

### 部分字段选择
`columns` 参数允许您包含或省略要从数据库中获取的列。

<Callout type="info" emoji="ℹ️">
  Drizzle 在查询级别执行部分选择，没有额外数据被从数据库中传输。

  请记住 **Drizzle 输出的是单个 SQL 语句**。
</Callout>

**仅获取带有 `id`、`content` 的所有帖子，并包括 `comments`：**
```typescript copy
const posts = await db.query.posts.findMany({
	columns: {
		id: true,
		content: true,
	},
	with: {
		comments: true,
	}
});
```

**获取没有 `content` 的所有帖子：**
```typescript copy
const posts = await db.query.posts.findMany({
	columns: {
		content: false,
	},
});
```

<Callout type="info" emoji="ℹ️">
当同时存在 `true` 和 `false` 的选择选项时，所有 `false` 的选项将被忽略。
</Callout>

如果您包含 `name` 字段并排除 `id` 字段，则 `id` 的排除将是多余的，
因为除了 `name` 的所有字段都将被排除。  
  
**在同一查询中排除和包含字段：**
<Section>
```typescript copy
const users = await db.query.users.findMany({
	columns: {
		name: true,
		id: false //被忽略
	},
});
```
```ts
// 结果类型
const users: {
	name: string;
};
```
</Section>

**仅包含来自嵌套关系的列：**
<Section>
```typescript copy
const res = await db.query.users.findMany({
	columns: {},
	with: {
		posts: true
	}
});
```
```ts
// 结果类型
const res: {
	posts: {
		id: number,
		text: string
	}
}[];
```
</Section>

### 嵌套部分字段选择
就像 **[`部分选择`](#partial-select)** 一样，您可以包含或排除嵌套关系的列：
```typescript copy
const posts = await db.query.posts.findMany({
	columns: {
		id: true,
		content: true,
	},
	with: {
		comments: {
			columns: {
				authorId: false
			}
		}
	}
});
```

### 选择过滤器
就像在我们的 SQL 风格查询构建器中一样，关系查询 API 允许您定义过滤器和条件，
使用我们 **[`运算符`](/docs/operators)** 的列表。

您可以从 `drizzle-orm` 导入它们，或使用回调语法直接使用：
<Section>
```typescript copy
import { eq } from 'drizzle-orm';

const users = await db.query.users.findMany({
	where: eq(users.id, 1)
})
```
```ts copy
const users = await db.query.users.findMany({
	where: (users, { eq }) => eq(users.id, 1),
})
```
</Section>

寻找 `id=1` 并且在特定日期之前创建的评论的帖子：
```typescript copy
await db.query.posts.findMany({
	where: (posts, { eq }) => (eq(posts.id, 1)),
	with: {
		comments: {
			where: (comments, { lt }) => lt(comments.createdAt, new Date()),
		},
	},
});
```

### 限制与偏移
Drizzle ORM 为查询和嵌套实体提供 `limit` 和 `offset` API。
  
**寻找 5 个帖子：**
```typescript copy
await db.query.posts.findMany({
	limit: 5,
});
```

**查找帖子并最多获取 3 条评论：**
```typescript copy
await db.query.posts.findMany({
	with: {
		comments: {
			limit: 3,
		},
	},
});
```

<Callout type="warning" emoji="⚠️">
  `offset` 仅适用于顶层查询。
</Callout>
```typescript 
await db.query.posts.findMany({
	limit: 5,
	offset: 2, // 正确 ✅
	with: {
		comments: {
			offset: 3, // 不正确 ❌
			limit: 3,
		},
	},
});
```

查找帖子并获取第 5 到第 10 个帖子的评论：
```typescript copy
await db.query.posts.findMany({
	limit: 5,
    offset: 5,
	with: {
		comments: true,
	},
});
```

### 排序
Drizzle 为关系查询构建器提供了排序 API。

您可以使用相同的排序 **[核心 API](/docs/select#order-by)**
或在没有导入的情况下使用回调中的 `order by` 运算符。  

<Section>
```typescript copy
import { desc, asc } from 'drizzle-orm';

await db.query.posts.findMany({
	orderBy: [asc(posts.id)],
});
```
```typescript copy
await db.query.posts.findMany({
	orderBy: (posts, { asc }) => [asc(posts.id)],
});
```
</Section>

**按 `asc` + `desc` 排序：**
```typescript copy
await db.query.posts.findMany({
	orderBy: (posts, { asc }) => [asc(posts.id)],
	with: {
		comments: {
			orderBy: (comments, { desc }) => [desc(comments.id)],
		},
	},
});
```

### 包括自定义字段
关系查询 API 允许您添加自定义附加字段。  
这在您需要检索数据并对其应用附加函数时非常有用。  
<Callout type="warning" emoji="⚠️">
	目前在 `extras` 中不支持聚合，请使用 **[`核心查询`](/docs/select)** 来处理。
</Callout>

<Section>
```typescript copy {5}
import { sql } from 'drizzle-orm';

await db.query.users.findMany({
	extras: {
		loweredName: sql`lower(${users.name})`.as('lowered_name'),
	},
})
```
```typescript copy {3}
await db.query.users.findMany({
	extras: {
		loweredName: (users, { sql }) => sql`lower(${users.name})`.as('lowered_name'),
	},
})
```
</Section>

`lowerName` 作为键将包括在返回对象的所有字段中。

<Callout type="warning" emoji="⚠️">
  您必须显式指定 `.as("<name_for_column>")`
</Callout>

要检索所有用户及其组，但包括 fullName 字段（它是 firstName 和 lastName 的连接），
您可以使用以下查询与 Drizzle 关系查询构建器。

<Section>
```typescript copy
const res = await db.query.users.findMany({
	extras: {
		fullName: sql<string>`concat(${users.name}, " ", ${users.name})`.as('full_name'),
	},
	with: {
		usersToGroups: {
			with: {
				group: true,
			},
		},
	},
});
```
```ts
// 结果类型
const res: {
	id: number;
	name: string;
	verified: boolean;
	invitedBy: number | null;
	fullName: string;
	usersToGroups: {
			group: {
					id: number;
					name: string;
					description: string | null;
			};
	}[];
}[];

```
</Section>


要检索所有带评论的帖子并添加一个额外字段以计算帖子内容和每条评论内容的大小：
<Section>
```typescript copy
const res = await db.query.posts.findMany({
	extras: (table, { sql }) => ({
		contentLength: (sql<number>`length(${table.content})`).as('content_length'),
	}),
	with: {
		comments: {
			extras: {
				commentSize: sql<number>`length(${comments.content})`.as('comment_size'),
			},
		},
	},
});
```
```ts
// 结果类型
const res: {
	id: number;
	createdAt: Date;
	content: string;
	authorId: number | null;
	contentLength: number;
	comments: {
			id: number;
			createdAt: Date;
			content: string;
			creator: number | null;
			postId: number | null;
			commentSize: number;
	}[];
};
```
</Section>

### 预编译语句
预编译语句旨在大幅提高查询性能 — [请查看此处.](/docs/perf-queries)

在本节中，您可以学习如何定义占位符以及如何使用
Drizzle 关系查询构建器执行预编译语句。

##### **`where` 中的占位符**
<Tabs items={['PostgreSQL', 'MySQL', 'SQLite']}>
<Tab>
<Section>
```ts copy
const prepared = db.query.users.findMany({
	where: ((users, { eq }) => eq(users.id, placeholder('id'))),
	with: {
		posts: {
			where: ((users, { eq }) => eq(users.id, placeholder('pid'))),
		},
	},
}).prepare('query_name');

const usersWithPosts = await prepared.execute({ id: 1 });
```
</Section>
</Tab>
<Tab>
<Section>
```ts copy
const prepared = db.query.users.findMany({
	where: ((users, { eq }) => eq(users.id, placeholder('id'))),
	with: {
		posts: {
			where: ((users, { eq }) => eq(users.id, placeholder('pid'))),
		},
	},
}).prepare();

const usersWithPosts = await prepared.execute({ id: 1 });
```
</Section>
</Tab>
<Tab>
<Section>
```ts copy
const prepared = db.query.users.findMany({
	where: ((users, { eq }) => eq(users.id, placeholder('id'))),
	with: {
		posts: {
			where: ((users, { eq }) => eq(users.id, placeholder('pid'))),
		},
	},
}).prepare();

const usersWithPosts = await prepared.execute({ id: 1 });
```
</Section>
</Tab>
</Tabs>


##### **`limit` 中的占位符**
<Tabs items={['PostgreSQL', 'MySQL', 'SQLite']}>
<Tab>
<Section>
```ts copy
const prepared = db.query.users.findMany({
	with: {
		posts: {
			limit: placeholder('limit'),
		},
	},
}).prepare('query_name');

const usersWithPosts = await prepared.execute({ limit: 1 });
```
</Section>
</Tab>
<Tab>
<Section>
```ts copy
const prepared = db.query.users.findMany({
	with: {
		posts: {
			limit: placeholder('limit'),
		},
	},
}).prepare();

const usersWithPosts = await prepared.execute({ limit: 1 });
```
</Section>
</Tab>
<Tab>
<Section>
```ts copy
const prepared = db.query.users.findMany({
	with: {
		posts: {
			limit: placeholder('limit'),
		},
	},
}).prepare();

const usersWithPosts = await prepared.execute({ limit: 1 });
```
</Section>
</Tab>
</Tabs>


##### **`offset` 中的占位符**
<Tabs items={['PostgreSQL', 'MySQL', 'SQLite']}>
<Tab>
<Section>
```ts copy
const prepared = db.query.users.findMany({
	offset: placeholder('offset'),
	with: {
		posts: true,
	},
}).prepare('query_name');

const usersWithPosts = await prepared.execute({ offset: 1 });
```
</Section>
</Tab>
<Tab>
<Section>
```ts copy
const prepared = db.query.users.findMany({
	offset: placeholder('offset'),
	with: {
		posts: true,
	},
}).prepare();

const usersWithPosts = await prepared.execute({ offset: 1 });
```
</Section>
</Tab>
<Tab>
<Section>
```ts copy
const prepared = db.query.users.findMany({
	offset: placeholder('offset'),
	with: {
		posts: true,
	},
}).prepare();

const usersWithPosts = await prepared.execute({ offset: 1 });
```
</Section>
</Tab>
</Tabs>

##### **多个占位符**
<Tabs items={['PostgreSQL', 'MySQL', 'SQLite']}>
<Tab>
<Section>
```ts copy
const prepared = db.query.users.findMany({
	limit: placeholder('uLimit'),
	offset: placeholder('uOffset'),
	where: ((users, { eq, or }) => or(eq(users.id, placeholder('id')), eq(users.id, 3))),
	with: {
		posts: {
			where: ((users, { eq }) => eq(users.id, placeholder('pid'))),
			limit: placeholder('pLimit'),
		},
	},
}).prepare('query_name');

const usersWithPosts = await prepared.execute({ pLimit: 1, uLimit: 3, uOffset: 1, id: 2, pid: 6 });
```
</Section>
</Tab>
<Tab>
<Section>
```ts copy
const prepared = db.query.users.findMany({
	limit: placeholder('uLimit'),
	offset: placeholder('uOffset'),
	where: ((users, { eq, or }) => or(eq(users.id, placeholder('id')), eq(users.id, 3))),
	with: {
		posts: {
			where: ((users, { eq }) => eq(users.id, placeholder('pid'))),
			limit: placeholder('pLimit'),
		},
	},
}).prepare();

const usersWithPosts = await prepared.execute({ pLimit: 1, uLimit: 3, uOffset: 1, id: 2, pid: 6 });
```
</Section>
</Tab>
<Tab>
<Section>
```ts copy
const prepared = db.query.users.findMany({
	limit: placeholder('uLimit'),
	offset: placeholder('uOffset'),
	where: ((users, { eq, or }) => or(eq(users.id, placeholder('id')), eq(users.id, 3))),
	with: {
		posts: {
			where: ((users, { eq }) => eq(users.id, placeholder('pid'))),
			limit: placeholder('pLimit'),
		},
	},
}).prepare();

const usersWithPosts = await prepared.execute({ pLimit: 1, uLimit: 3, uOffset: 1, id: 2, pid: 6 });
```
</Section>
</Tab>
</Tabs>


Source: https://drizzle.zhcndoc.com/docs/schemas

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import IsSupportedChipGroup from '@mdx/IsSupportedChipGroup.astro';
import Section from '@mdx/Section.astro';
import Callout from '@mdx/Callout.astro';

# 表结构

<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'MySQL': true, 'SQLite': false, 'SingleStore': true }} />

Drizzle ORM 为 PostgreSQL 和 MySQL 方言提供了一个用于声明 SQL 架构的 API。

如果在架构中声明了一个实体，查询构建器会在查询中添加架构名称：<br/>
`select * from "schema"."users"`

<Tabs items={['PostgreSQL', 'MySQL', "SQLite", "SingleStore"]}>
  <Tab>
    <Section>
    ```ts copy {3,5,7}
    import { serial, text, pgSchema } from "drizzle-orm/pg-core";

    export const mySchema = pgSchema("my_schema");

    export const colors = mySchema.enum('colors', ['red', 'green', 'blue']);

    export const mySchemaUsers = mySchema.table('users', {
      id: serial('id').primaryKey(),
      name: text('name'),
      color: colors('color').default('red'),
    });

    
    ```
    ```sql
    CREATE SCHEMA "my_schema";

    CREATE TYPE "my_schema"."colors" AS ENUM ('red', 'green', 'blue');

    CREATE TABLE "my_schema"."users" (
      "id" serial PRIMARY KEY,
      "name" text,
      "color" "my_schema"."colors" DEFAULT 'red'
    );
    ```
    </Section>
  </Tab>
  <Tab>
    <Section>
    ```ts {3,5}
    import { int, text, mysqlSchema } from "drizzle-orm/mysql-core";

    export const mySchema = mysqlSchema("my_schema")

    export const mySchemaUsers = mySchema.table("users", {
      id: int("id").primaryKey().autoincrement(),
      name: text("name"),
    });
    ```
    ```sql
    CREATE SCHEMA "my_schema";

    CREATE TABLE "my_schema"."users" (
      "id" serial PRIMARY KEY,
      "name" text
    );
    ```
    </Section>
  </Tab>
  <Tab>
  SQLite 不支持架构 😕
  </Tab>
  <Tab>
    <Section>
    ```ts {3,5}
    import { int, text, singlestoreSchema } from "drizzle-orm/singlestore-core";

    export const mySchema = singlestoreSchema("my_schema")

    export const mySchemaUsers = mySchema.table("users", {
      id: int("id").primaryKey().autoincrement(),
      name: text("name"),
    });
    ```
    ```sql
    CREATE SCHEMA "my_schema";

    CREATE TABLE "my_schema"."users" (
      "id" serial PRIMARY KEY,
      "name" text
    );
    ```
    </Section>
  </Tab>
</Tabs>

{/* TODO: ??? 示例 > **警告**
> 如果你在不同的架构中有同名表，则 drizzle 会在结果类型中响应 `never[]` 错误，并从数据库返回错误
>
> 在这种情况下，你可以使用 [别名语法](./joins#join-aliases-and-self-joins) */}


Source: https://drizzle.zhcndoc.com/docs/seed-functions

import Callout from '@mdx/Callout.astro';

# 生成器

<Callout title='warning'>
目前，在支持的生成器中同时指定 `arraySize` 和 `isUnique` 将导致生成唯一值（而不是唯一数组），然后这些值将被打包成数组。
</Callout>

## ---

### `default`

<rem025 />
每次调用生成器时会生成相同的给定值。

|  | param          | default     | type
|:-| :--------      | :--------   | :--------
|  |`defaultValue`  |--           |`any`
|  |`arraySize`     |--           |`number`

<rem025 />

```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  posts: {
    columns: {
      content: funcs.default({
        // 要生成的值
        defaultValue: "帖子内容",

        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```

### `valuesFromArray`

<rem025 />
从给定数组生成值

|  | param      | default                   | type
|:-| :--------  | :--------                 | :--------
|  |`values`    |--                         |`any[]` \| `{ weight: number; values: any[] }[]`
|  |`isUnique`  |数据库列的唯一性         |`boolean`
|  |`arraySize` |--                         |`number`


<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  posts: {
    columns: {
      title: funcs.valuesFromArray({
        // 要生成的值数组（可以是加权值数组）
        values: ["标题1", "标题2", "标题3", "标题4", "标题5"],

        // 控制生成值是否唯一的属性
        isUnique: true,
        
        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```

### `intPrimaryKey`

<rem025 />
生成从 1 开始的顺序整数。

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |--          |--          |--

<rem025 />

```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  posts: {
    columns: {
      id: funcs.intPrimaryKey(),
    },
  },
}));

```

### `number`

<rem025 />
在给定范围内生成带小数的数字

|  | param      | default                                                                                               | type
|:-| :--------  | :--------                                                                                             | :--------
|  |`isUnique`  |数据库列的唯一性                                                                                     |`boolean`
|  |`precision` |`100`                                                                                                  |`number`
|  |`maxValue`  |``` `precision * 1000` 如果 isUnique 为 false ``` ``` `precision * count` 如果 isUnique 为 true ```  |`number`
|  |`minValue`  |`-maxValue`                                                                                            |`number`
|  |`arraySize` |--                                                                                                     |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  products: {
    columns: {
      unitPrice: funcs.number({
        // 范围的下边界。
        minValue: 10,

        // 范围的上边界。
        maxValue: 120,
        
        // 生成数字的精度：
        // 精度为 10 意味着值精确到十分之一 (1.2, 34.6);
        // 精度为 100 意味着值精确到百分之一 (1.23, 34.67)。
        precision: 100,

        // 控制生成值是否唯一的属性。
        isUnique: false,

        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```

### `int`

<rem025 />
在给定范围内生成整数

|  | param      | default                                                                            | type
|:-| :--------  | :--------                                                                          | :--------
|  |`isUnique`  |数据库列的唯一性                                                                  |`boolean`
|  |`maxValue`  |``` `1000` 如果 isUnique 为 false ``` ``` `count * 10` 如果 isUnique 为 true ```  |`number \| bigint`
|  |`minValue`  |`-maxValue`                                                                       |`number \| bigint`
|  |`arraySize` |--                                                                                |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  products: {
    columns: {
      unitsInStock: funcs.int({
        // 范围的下边界。
        minValue: 0,

        // 范围的上边界。
        maxValue: 100,

        // 控制生成值是否唯一的属性。
        isUnique: false,

        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```

### `boolean`

<rem025 />
生成布尔值（真或假）

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`arraySize` |--          |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      isAvailable: funcs.boolean({
        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```

### `date`

<rem025 />
在给定范围内生成日期

|  | param      | default                 | type
|:-| :--------  | :--------------         | :--------
|  |`minDate`   |`new Date('2020-05-08')` | `string \| Date`
|  |`maxDate`   |`new Date('2028-05-08')` | `string \| Date`
|  |`arraySize` |--                       |`number`

<Callout type='warning'>
如果只提供了一个参数（`minDate` 或 `maxDate`），则未指定的参数将通过在指定参数上加减 8 年来计算
</Callout>

<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      birthDate: funcs.date({
        // 范围的下边界。
        minDate: "1990-01-01",

        // 范围的上边界。
        maxDate: "2010-12-31",

        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```

### `time`

<rem025 />
生成 24 小时制的时间

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`arraySize` |--          |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      birthTime: funcs.time({
        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```

### `timestamp`

<rem025 />
生成时间戳

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`arraySize` |--          |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  orders: {
    columns: {
      shippedDate: funcs.timestamp({
        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```

### `datetime`

<rem025 />
生成日期时间对象

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`arraySize` |--          |`number`
<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  orders: {
    columns: {
      shippedDate: funcs.datetime({
        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```

### `year`

<rem025 />
生成 `YYYY` 格式的年份

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`arraySize` |--          |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      birthYear: funcs.year({
        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```

### `json`

<rem025 />
生成具有固定结构的 JSON 对象

```ts
{ email, name, isGraduated, hasJob, salary, startedWorking, visitedCountries}

// 或者

{ email, name, isGraduated, hasJob, visitedCountries }
```

> JSON 结构将随机选择

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`arraySize` |--          |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      metadata: funcs.json({
        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```

### `interval`

<rem025 />
生成时间间隔。

生成值的示例： `1 year 12 days 5 minutes`

|  | param      | default            | type
|:-| :--------  | :--------          | :--------
|  |`isUnique`  | 列唯一性           |`boolean`
|  |`arraySize` |--                  |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      timeSpentOnWebsite: funcs.interval({
        // `isUnique` - 属性控制生成值是否将唯一
        isUnique: true,

        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```

### `string`

<rem025 />
生成随机字符串

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`isUnique`  |--          |`boolean`
|  |`arraySize` |--          |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      hashedPassword: funcs.string({
        // `isUnique` - 属性控制生成值是否将唯一
        isUnique: false,
        
        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```

### `uuid`

<rem025 />
生成 v4 UUID 字符串

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`arraySize` |--          |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";
await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  products: {
    columns: {
      id: funcs.uuid({
        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));
```

### `firstName`

<rem025 />
生成一个人的名字

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`isUnique`  |--          |`boolean`
|  |`arraySize` |--          |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      firstName: funcs.firstName({
        // `isUnique` - 属性控制生成值是否将唯一
        isUnique: true,

        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```

### `lastName`

<rem025 />
生成一个人的姓氏

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`isUnique`  |--          |`boolean`
|  |`arraySize` |--          |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      lastName: funcs.lastName({
        // `isUnique` - 属性控制生成值是否将唯一
        isUnique: false,
        
        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```

### `fullName`

<rem025 />
生成一个人的全名

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`isUnique`  |--          |`boolean`
|  |`arraySize` |--          |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      fullName: funcs.fullName({
        // `isUnique` - 属性控制生成值是否将唯一
        isUnique: true,

        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```

### `email`

<rem025 />
生成唯一的电子邮件地址

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`arraySize` |--          |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      email: funcs.email({
        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```

### `phoneNumber`

<rem025 />
生成唯一的电话号码

|  | param                    | default                                         | type
|:-| :--------                | :--------                                       | :--------
|  |`template`                |--                                               |`string`
|  |`prefixes`                |[用于前缀的数据集](https://github.com/OleksiiKH0240/drizzle-orm/blob/main/drizzle-seed/src/datasets/phonesInfo.ts)   |`string[]`
|  |`generatedDigitsNumbers`  | `7` - `如果定义了前缀`                       |`number \| number[]`
|  |`arraySize`               |--                                               |`number`

<rem025 />
```ts 
import { seed } from "drizzle-seed";

//使用模板属性生成电话号码
await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      phoneNumber: funcs.phoneNumber({ 
        // `template` - 电话号码模板，其中所有 '#' 符号将被生成的数字替换。
        template: "+(380) ###-####",

        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```
```ts 
import { seed } from "drizzle-seed";

//使用前缀和生成的数字数量属性生成电话号码
await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      phoneNumber: funcs.phoneNumber({
        // `prefixes` - 你希望作为电话号码前缀的任何字符串的数组。（与 `template` 属性不兼容）
        prefixes: ["+380 99", "+380 67"],

        // `generatedDigitsNumbers` - 将添加到前缀后的数字数量。（与 `template` 属性不兼容）
        generatedDigitsNumbers: 7,

        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```
```ts 
import { seed } from "drizzle-seed";

//使用前缀和生成的数字数量属性生成电话号码，但为前缀使用不同的生成数字数量
await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      phoneNumber: funcs.phoneNumber({
        // `prefixes` - 你希望作为电话号码前缀的任何字符串的数组。（与 `template` 属性不兼容）
        prefixes: ["+380 99", "+380 67", "+1"],

        // `generatedDigitsNumbers` - 将添加到前缀后的数字数量。（与 `template` 属性不兼容）
        generatedDigitsNumbers: [7, 7, 10],

        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```
### `country`

<rem025 />
生成国家名称

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`isUnique`  |--          |`boolean`
|  |`arraySize` |--          |`number`

<rem025 />

```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      country: funcs.country({
        // `isUnique` - 属性控制生成值是否将唯一
        isUnique: false,
        
        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```

### `city`

<rem025 />
生成城市名称

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`isUnique`  |--          |`boolean`
|  |`arraySize` |--          |`number`

<rem025 />

```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      city: funcs.city({
        // `isUnique` - 属性控制生成值是否将唯一
        isUnique: false,

        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```

### `streetAddress`

<rem025 />
生成街道地址

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`isUnique`  |--          |`boolean`

<rem025 />

```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      streetAddress: funcs.streetAddress({
        // `isUnique` - 属性控制生成值是否将唯一
        isUnique: false,
        
        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3 
      }),
    },
  },
}));

```

### `jobTitle`

<rem025 />
生成职位名称

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`arraySize` |--          |`number`

<rem025 />

```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      jobTitle: funcs.jobTitle({
        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```

### `postcode`

<rem025 />
生成邮政编码

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`isUnique`  |--          |`boolean`
|  |`arraySize` |--          |`number`

<rem025 />

```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      postcode: funcs.postcode({
        // `isUnique` - 属性控制生成值是否将唯一
        isUnique: true,

        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```

### `state`

<rem025 />
生成美国州名

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`arraySize` |--          |`number`

<rem025 />

```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      state: funcs.state({
        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```

### `companyName`

<rem025 />
生成随机公司的名称

|  | param      | default    | type
|:-| :--------  | :--------  | :--------
|  |`isUnique`  |--          |`boolean`
|  |`arraySize` |--          |`number`

<rem025 />

```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  users: {
    columns: {
      company: funcs.companyName({ 
        // `isUnique` - 属性控制生成值是否将唯一
        isUnique: true,

        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```
### `loremIpsum`

<rem025 />
生成 `lorem ipsum` 文本句子。

|  | param            | default    | type
|:-| :--------        | :--------  | :--------
|  |`sentencesCount`  | 1          |`number`
|  |`arraySize`       |--          |`number`

<rem025 />

```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  posts: {
    columns: {
      content: funcs.loremIpsum({
        // `sentencesCount` - 你希望生成作为一个生成值（字符串）的句子数量。
        sentencesCount: 2,

        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```

### `point`

<rem025 />
生成在 x 和 y 坐标的指定范围内的二维点。

|  | param       | default                                                                                 | type
|:-| :--------   | :--------                                                                               | :--------
|  |`isUnique`   |数据库列的唯一性                                                                       |`boolean`
|  |`maxXValue`  |``` `10 * 1000` 如果 isUnique 为 false ``` ``` `10 * count` 如果 isUnique 为 true ```  |`number`
|  |`minXValue`  |`-maxXValue`                                                                             |`number`
|  |`maxYValue`  |``` `10 * 1000` 如果 isUnique 为 false ``` ``` `10 * count` 如果 isUnique 为 true ```  |`number`
|  |`minYValue`  |`-maxYValue`                                                                             |`number`
|  |`arraySize`  |--                                                                                       |`number`


<rem025 />

```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  triangles: {
    columns: {
      pointCoords: funcs.point({
        // `isUnique` - 属性控制生成值是否将唯一
        isUnique: true,

        // `minXValue` - x 坐标的下边界。
        minXValue: -5,

        // `maxXValue` - x 坐标的上边界。
        maxXValue: 20,

        // `minYValue` - y 坐标的下边界。
        minYValue: 0,

        // `maxYValue` - y 坐标的上边界。
        maxYValue: 30,

        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```

### `line`

<rem025 />
生成在指定范围内的二维线的 a、b 和 c 参数。

```
线方程： a*x + b*y + c = 0
```

|  | param       | default                                                                                 | type
|:-| :--------   | :--------                                                                               | :--------
|  |`isUnique`   |数据库列的唯一性                                                                       |`boolean`
|  |`maxAValue`  |``` `10 * 1000` 如果 isUnique 为 false ``` ``` `10 * count` 如果 isUnique 为 true ```  |`number`
|  |`minAValue`  |`-maxAValue`                                                                             |`number`
|  |`maxBValue`  |``` `10 * 1000` 如果 isUnique 为 false ``` ``` `10 * count` 如果 isUnique 为 true ```  |`number`
|  |`minBValue`  |`-maxBValue`                                                                             |`number`
|  |`maxCValue`  |``` `10 * 1000` 如果 isUnique 为 false ``` ``` `10 * count` 如果 isUnique 为 true ```  |`number`
|  |`minCValue`  |`-maxCValue`                                                                             |`number`
|  |`arraySize`  |--                                                                                       |`number`
<rem025 />

```ts 
import { seed } from "drizzle-seed";

await seed(db, schema, { count: 1000 }).refine((funcs) => ({
  lines: {
    columns: {
      lineParams: funcs.point({
        // `isUnique` - 属性控制生成值是否将唯一
        isUnique: true,

        // `minAValue` - a 参数的下边界。
        minAValue: -5,

        // `maxAValue` - a 参数的上边界。
        maxAValue: 20,

        // `minBValue` - b 参数的下边界。
        minBValue: 0,

        // `maxBValue` - b 参数的上边界。
        maxBValue: 30,

        // `minCValue` - c 参数的下边界。
        minCValue: 0,

        // `maxCValue` - c 参数的上边界。
        maxCValue: 10,

        // 每个一维数组中的元素数量。 
        // （如指定，将生成数组。）
        arraySize: 3
      }),
    },
  },
}));

```


Source: https://drizzle.zhcndoc.com/docs/seed-limitations

// type limitations for third param

Source: https://drizzle.zhcndoc.com/docs/seed-overview

import Npm from "@mdx/Npm.astro";
import Tab from "@mdx/Tab.astro";
import Tabs from "@mdx/Tabs.astro";
import Callout from '@mdx/Callout.astro';
import CodeTabs from "@mdx/CodeTabs.astro";
import Section from "@mdx/Section.astro";
import IsSupportedChipGroup from '@mdx/IsSupportedChipGroup.astro';

# Drizzle Seed

<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'SQLite': true, 'MySQL': true, 'SingleStore': false }} />

<Callout type='warning'>
  `drizzle-seed` 只能与 `drizzle-orm@0.36.4` 或更高版本一起使用。低于此版本的版本在运行时可能能工作，但可能存在类型问题和标识列问题，因为此补丁是从 `drizzle-orm@0.36.4` 开始引入的
</Callout>

`drizzle-seed` 是一个 TypeScript 库，帮助你生成确定性的、但又逼真的假数据来填充你的数据库。通过利用一个可设置种子的伪随机数生成器（pRNG），它保证你生成的数据在不同运行间保持一致且可复现。这对于测试、开发和调试尤为有用。

#### 什么是确定性数据生成？

确定性数据生成意味着相同的输入总是产生相同的输出。在 `drizzle-seed` 的上下文中，当你用相同的种子数字初始化库时，它每次都会生成同样的假数据序列。这允许数据集是可预测和可重复的。

#### 伪随机数生成器（pRNG）

伪随机数生成器是一种算法，用以生成近似随机数性质的数字序列。但由于它基于一个初始值称为种子，你可以控制它的随机性。使用相同的种子，pRNG 会生成相同的数字序列，使你的数据生成过程可复现。

#### 使用 pRNG 的好处：

- 一致性：保证测试每次都使用相同的数据。
- 调试：通过提供一致的数据集，使得复现和修复错误更容易。
- 协作：团队成员可共享种子编号，以便使用相同的数据集。

使用 drizzle-seed，你可以兼得生成逼真假数据的能力和随时复现这些数据的控制权。

## 安装

<Npm>drizzle-seed</Npm>

## 基本用法

这个示例中，我们将创建 10 个具有随机名称和 ID 的用户

```ts {12}
import { pgTable, integer, text } from "drizzle-orm/pg-core";
import { drizzle } from "drizzle-orm/node-postgres";
import { seed } from "drizzle-seed";

const users = pgTable("users", {
  id: integer().primaryKey(),
  name: text().notNull(),
});

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);
  await seed(db, { users });
}

main();
```

## 配置选项

**`count`**

默认情况下，`seed` 函数会创建 10 个实体。如果测试需要更多数据，可以在 seed 的选项对象中指定

```ts
await seed(db, schema, { count: 1000 });
```

**`seed`**

如果你想针对后续运行生成不同的数据集，可以在 `seed` 选项中定义一个不同的数字。不同的数字将生成唯一的数据集

```ts
await seed(db, schema, { seed: 12345 });
```

## 重置数据库

使用 `drizzle-seed` 可以轻松重置数据库并用新值填充，例如在测试套件中

```ts
// 指向你想重置的 schema 文件的路径
import * as schema from "./schema.ts";
import { reset } from "drizzle-seed";

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);
  await reset(db, schema);
}

main();
```

不同数据库方言有不同的重置策略

<Tabs items={['PostgreSQL', 'MySQL', 'SQLite']}>
<Tab>
针对 PostgreSQL，`drizzle-seed` 包会生成带有 `CASCADE` 选项的 `TRUNCATE` 语句，
确保运行 reset 函数后所有表都为空

```sql
TRUNCATE tableName1, tableName2, ... CASCADE;
```

</Tab>
<Tab>
针对 MySQL，`drizzle-seed` 包会先禁用 `FOREIGN_KEY_CHECKS` 以防止后续步骤失败，然后生成 `TRUNCATE` 语句来清空所有表的内容

```sql
SET FOREIGN_KEY_CHECKS = 0;
TRUNCATE tableName1;
TRUNCATE tableName2;
...
SET FOREIGN_KEY_CHECKS = 1;
```

</Tab>
<Tab>
针对 SQLite，`drizzle-seed` 包会先禁用 `foreign_keys` pragma 以防止后续步骤失败，然后生成 `DELETE FROM` 语句清空所有表的内容

```sql
PRAGMA foreign_keys = OFF;
DELETE FROM tableName1;
DELETE FROM tableName2;
...
PRAGMA foreign_keys = ON;
```

</Tab>
</Tabs>

## 精细化定制

如果你需要更改 `drizzle-seed` 默认使用的种子生成函数的行为，可以指定你自己的实现，甚至自己定义值列表用于种子过程。

`.refine` 是一个回调函数，会接收所有 `drizzle-seed` 中可用生成器函数的列表。它需要返回一个对象，键是你想要精细化定制的表名，值定义这些表的行为。
每个表可以指定多个属性来简化数据库的种子过程：

<rem025 />

- `columns`：通过指定所需的生成器函数，精细化调整每列的默认行为。
- `count`：指定插入数据库的行数。默认是 10。如果你在 `seed()` 函数选项里定义了全局的 count，这里指定的 count 会覆盖该表的全局 count。
- `with`：如果你想生成关联实体，定义为每个父表创建多少个被引用实体。

<Callout title='info'>
你还可以为要创建的被引用值数量指定加权随机分布。关于该 API 的细节可以参考 [加权随机（Weighted Random）文档](#weighted-random) 部分。
</Callout>

**API**
```ts
await seed(db, schema).refine((f) => ({
  users: {
    columns: {},
    count: 10,
    with: {
        posts: 10
    }
  },
}));
```

下面是一些带解释的示例：

```ts filename='schema.ts'
import { pgTable, integer, text } from "drizzle-orm/pg-core";

export const users = pgTable("users", {
  id: integer().primaryKey(),
  name: text().notNull(),
});

export const posts = pgTable("posts", {
  id: integer().primaryKey(),
  description: text(),
  userId: integer().references(() => users.id),
});
```

**示例1**：只对 `users` 表进行种子，生成 20 个实体，并对 `name` 列应用精细化的种子逻辑
```ts filename='index.ts'
import { drizzle } from "drizzle-orm/node-postgres";
import { seed } from "drizzle-seed";
import * as schema from './schema.ts'

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);

  await seed(db, { users: schema.users }).refine((f) => ({
    users: {
        columns: {
            name: f.fullName(),
        },
        count: 20
    }
  }));
}

main();
```

**示例2**：对 `users` 表插入 20 个实体，并且为每个用户生成 10 个 `posts`，通过给 `posts` 表种子并建立其到 `users` 表的引用实现关联
```ts filename='index.ts'
import { drizzle } from "drizzle-orm/node-postgres";
import { seed } from "drizzle-seed";
import * as schema from './schema.ts'

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);

  await seed(db, schema).refine((f) => ({
    users: {
        count: 20,
        with: {
            posts: 10
        }
    }
  }));
}

main();
```

**示例3**：对 `users` 表种子 5 个实体，且向数据库插入 100 个 `posts`，但不与 `users` 实体关联。针对 `users` 的 `id` 精细化为给出 `10000` 到 `20000` 之间且唯一的整数，对 `posts` 的 `description` 精细化为从自定义数组里获取值
```ts filename='index.ts'
import { drizzle } from "drizzle-orm/node-postgres";
import { seed } from "drizzle-seed";
import * as schema from './schema.ts'

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);

  await seed(db, schema).refine((f) => ({
    users: {
        count: 5,
        columns: {
            id: f.int({
              minValue: 10000,
              maxValue: 20000,
              isUnique: true,
            }),
        }
    },
    posts: {
        count: 100,
        columns: {
            description: f.valuesFromArray({
            values: [
                "太阳落山，山后染上橙紫色的天空", 
                "我真不敢相信这自制披萨做得这么好！", 
                "有时候，你只需要一本好书和一个安静的角落。", 
                "谁认为雨天是刷老电影的绝佳日子？", 
                "今天试了条新徒步路线，发现了最棒的瀑布！",
                // ...
            ],
          })
        }
    }
  }));
}

main();
```

<Callout type='warning'>
此文档中将定义更多可能性，目前你可以先浏览这些部分。查看 [生成器（Generators）](/docs/seed-functions) 部分，熟悉所有可用的生成器函数。

一个特别棒的功能是可以使用加权随机，无论是针对列生成的值，还是 `drizzle-seed` 生成相关实体数量时。

请参考 [加权随机（Weighted Random）文档](#weighted-random) 获取更多信息。
</Callout>


## 加权随机（Weighted Random）

有时你可能需要使用多个数据集以不同优先级在种子阶段插入数据库。针对这种情况，drizzle-seed 提供了一个称作加权随机的 API。

Drizzle Seed 包在以下场景支持加权随机：

- 每个表的列细化中
- `with` 属性中，用于确定要创建的相关实体数量

下面给出两个示例：

```ts filename="schema.ts"
import { pgTable, integer, text, varchar, doublePrecision } from "drizzle-orm/pg-core";

export const orders = pgTable(
  "orders",
  {
    id: integer().primaryKey(),
    name: text().notNull(),
    quantityPerUnit: varchar().notNull(),
    unitPrice: doublePrecision().notNull(),
    unitsInStock: integer().notNull(),
    unitsOnOrder: integer().notNull(),
    reorderLevel: integer().notNull(),
    discontinued: integer().notNull(),
  }
);

export const details = pgTable(
  "details",
  {
    unitPrice: doublePrecision().notNull(),
    quantity: integer().notNull(),
    discount: doublePrecision().notNull(),

    orderId: integer()
      .notNull()
      .references(() => orders.id, { onDelete: "cascade" }),
  }
);
```

**示例1**：精细化 `unitPrice` 的生成逻辑，生成 5000 条随机价格数据，其中 30% 是 10-100 之间的价格，70% 是 100-300 之间的价格

```ts filename="index.ts"
import { drizzle } from "drizzle-orm/node-postgres";
import { seed } from "drizzle-seed";
import * as schema from './schema.ts'

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);

  await seed(db, schema).refine((f) => ({
    orders: {
       count: 5000,
       columns: {
           unitPrice: f.weightedRandom(
               [
                   {
                       weight: 0.3,
                       value: funcs.int({ minValue: 10, maxValue: 100 })
                   },
                   {
                       weight: 0.7,
                       value: funcs.number({ minValue: 100, maxValue: 300, precision: 100 })
                   }
               ]
           ),
       }
    }
  }));
}

main();
```

**示例2**：为每个订单生成 1 到 3 条详情的概率为 60%，生成 5 到 7 条详情概率为 30%，生成 8 到 10 条详情概率为 10%

```ts filename="index.ts"
import { drizzle } from "drizzle-orm/node-postgres";
import { seed } from "drizzle-seed";
import * as schema from './schema.ts'

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);

  await seed(db, schema).refine((f) => ({
    orders: {
       with: {
           details:
               [
                   { weight: 0.6, count: [1, 2, 3] },
                   { weight: 0.3, count: [5, 6, 7] },
                   { weight: 0.1, count: [8, 9, 10] },
               ]
       }
    }
  }));
}

main();
```

## 复杂示例

<CodeTabs items={["main.ts", "schema.ts"]}>
<Section>
```ts
import { seed } from "drizzle-seed";
import * as schema from "./schema.ts";

const main = async () => {
    const titlesOfCourtesy = ["Ms.", "Mrs.", "Dr."];
    const unitsOnOrders = [0, 10, 20, 30, 50, 60, 70, 80, 100];
    const reorderLevels = [0, 5, 10, 15, 20, 25, 30];
    const quantityPerUnit = [
        "100 - 100 g pieces",
        "100 - 250 g bags",
        "10 - 200 g glasses",
        "10 - 4 oz boxes",
        "10 - 500 g pkgs.",
        "10 - 500 g pkgs."
    ];
    const discounts = [0.05, 0.15, 0.2, 0.25];

    await seed(db, schema).refine((funcs) => ({
        customers: {
            count: 10000,
            columns: {
                companyName: funcs.companyName(),
                contactName: funcs.fullName(),
                contactTitle: funcs.jobTitle(),
                address: funcs.streetAddress(),
                city: funcs.city(),
                postalCode: funcs.postcode(),
                region: funcs.state(),
                country: funcs.country(),
                phone: funcs.phoneNumber({ template: "(###) ###-####" }),
                fax: funcs.phoneNumber({ template: "(###) ###-####" })
            }
        },
        employees: {
            count: 200,
            columns: {
                firstName: funcs.firstName(),
                lastName: funcs.lastName(),
                title: funcs.jobTitle(),
                titleOfCourtesy: funcs.valuesFromArray({ values: titlesOfCourtesy }),
                birthDate: funcs.date({ minDate: "2010-12-31", maxDate: "2010-12-31" }),
                hireDate: funcs.date({ minDate: "2010-12-31", maxDate: "2024-08-26" }),
                address: funcs.streetAddress(),
                city: funcs.city(),
                postalCode: funcs.postcode(),
                country: funcs.country(),
                homePhone: funcs.phoneNumber({ template: "(###) ###-####" }),
                extension: funcs.int({ minValue: 428, maxValue: 5467 }),
                notes: funcs.loremIpsum()
            }
        },
        orders: {
            count: 50000,
            columns: {
                shipVia: funcs.int({ minValue: 1, maxValue: 3 }),
                freight: funcs.number({ minValue: 0, maxValue: 1000, precision: 100 }),
                shipName: funcs.streetAddress(),
                shipCity: funcs.city(),
                shipRegion: funcs.state(),
                shipPostalCode: funcs.postcode(),
                shipCountry: funcs.country()
            },
            with: {
                details:
                    [
                        { weight: 0.6, count: [1, 2, 3, 4] },
                        { weight: 0.2, count: [5, 6, 7, 8, 9, 10] },
                        { weight: 0.15, count: [11, 12, 13, 14, 15, 16, 17] },
                        { weight: 0.05, count: [18, 19, 20, 21, 22, 23, 24, 25] },
                    ]
            }
        },
        suppliers: {
            count: 1000,
            columns: {
                companyName: funcs.companyName(),
                contactName: funcs.fullName(),
                contactTitle: funcs.jobTitle(),
                address: funcs.streetAddress(),
                city: funcs.city(),
                postalCode: funcs.postcode(),
                region: funcs.state(),
                country: funcs.country(),
                phone: funcs.phoneNumber({ template: "(###) ###-####" })
            }
        },
        products: {
            count: 5000,
            columns: {
                name: funcs.companyName(),
                quantityPerUnit: funcs.valuesFromArray({ values: quantityPerUnit }),
                unitPrice: funcs.weightedRandom(
                    [
                        {
                            weight: 0.5,
                            value: funcs.int({ minValue: 3, maxValue: 300 })
                        },
                        {
                            weight: 0.5,
                            value: funcs.number({ minValue: 3, maxValue: 300, precision: 100 })
                        }
                    ]
                ),
                unitsInStock: funcs.int({ minValue: 0, maxValue: 125 }),
                unitsOnOrder: funcs.valuesFromArray({ values: unitsOnOrders }),
                reorderLevel: funcs.valuesFromArray({ values: reorderLevels }),
                discontinued: funcs.int({ minValue: 0, maxValue: 1 })
            }
        },
        details: {
            columns: {
                unitPrice: funcs.number({ minValue: 10, maxValue: 130 }),
                quantity: funcs.int({ minValue: 1, maxValue: 130 }),
                discount: funcs.weightedRandom(
                    [
                        { weight: 0.5, value: funcs.valuesFromArray({ values: discounts }) },
                        { weight: 0.5, value: funcs.default({ defaultValue: 0 }) }
                    ]
                )
            }
        }
    }));
}

main();

```
</Section>
<Section>
```ts
import type { AnyPgColumn } from "drizzle-orm/pg-core";
import { integer, numeric, pgTable, text, timestamp, varchar } from "drizzle-orm/pg-core";

export const customers = pgTable('customer', {
	id: varchar({ length: 256 }).primaryKey(),
	companyName: text().notNull(),
	contactName: text().notNull(),
	contactTitle: text().notNull(),
	address: text().notNull(),
	city: text().notNull(),
	postalCode: text(),
	region: text(),
	country: text().notNull(),
	phone: text().notNull(),
	fax: text(),
});

export const employees = pgTable(
	'employee',
	{
		id: integer().primaryKey(),
		lastName: text().notNull(),
		firstName: text(),
		title: text().notNull(),
		titleOfCourtesy: text().notNull(),
		birthDate: timestamp().notNull(),
		hireDate: timestamp().notNull(),
		address: text().notNull(),
		city: text().notNull(),
		postalCode: text().notNull(),
		country: text().notNull(),
		homePhone: text().notNull(),
		extension: integer().notNull(),
		notes: text().notNull(),
		reportsTo: integer().references((): AnyPgColumn => employees.id),
		photoPath: text(),
	},
);

export const orders = pgTable('order', {
	id: integer().primaryKey(),
	orderDate: timestamp().notNull(),
	requiredDate: timestamp().notNull(),
	shippedDate: timestamp(),
	shipVia: integer().notNull(),
	freight: numeric().notNull(),
	shipName: text().notNull(),
	shipCity: text().notNull(),
	shipRegion: text(),
	shipPostalCode: text(),
	shipCountry: text().notNull(),

	customerId: text().notNull().references(() => customers.id, { onDelete: 'cascade' }),

	employeeId: integer().notNull().references(() => employees.id, { onDelete: 'cascade' }),
});

export const suppliers = pgTable('supplier', {
	id: integer().primaryKey(),
	companyName: text().notNull(),
	contactName: text().notNull(),
	contactTitle: text().notNull(),
	address: text().notNull(),
	city: text().notNull(),
	region: text(),
	postalCode: text().notNull(),
	country: text().notNull(),
	phone: text().notNull(),
});

export const products = pgTable('product', {
	id: integer().primaryKey(),
	name: text().notNull(),
	quantityPerUnit: text().notNull(),
	unitPrice: numeric().notNull(),
	unitsInStock: integer().notNull(),
	unitsOnOrder: integer().notNull(),
	reorderLevel: integer().notNull(),
	discontinued: integer().notNull(),

	supplierId: integer().notNull().references(() => suppliers.id, { onDelete: 'cascade' }),
});

export const details = pgTable('order_detail', {
	unitPrice: numeric().notNull(),
	quantity: integer().notNull(),
	discount: numeric().notNull(),

	orderId: integer().notNull().references(() => orders.id, { onDelete: 'cascade' }),

	productId: integer().notNull().references(() => products.id, { onDelete: 'cascade' }),
});

```
</Section>
</CodeTabs>

## 限制

#### `with` 的类型限制

由于 TypeScript 的某些限制以及 Drizzle 当前的 API，无法正确推断表之间的引用，尤其是在表之间存在循环依赖的情况下。

这意味着 `with` 选项会显示 schema 中的所有表，你需要手动选择具有一对多关系的表。

<Callout title='warning'>
`with` 选项仅针对一对多关系有效。例如，如果有一个 `user` 其对应多个 `posts`，可以用 `users with posts`，但不能用 `posts with users`
</Callout>

#### Drizzle 表第三个参数的类型限制：

目前，我们没有针对 Drizzle 表的第三个参数的类型支持。虽然运行时能工作，但类型层面不能正确识别。


Source: https://drizzle.zhcndoc.com/docs/seed-versioning

import Tab from "@mdx/Tab.astro";
import Tabs from "@mdx/Tabs.astro";
import Callout from "@mdx/Callout.astro";
import TableWrapper from "@mdx/TableWrapper.astro";

# 版本控制

`drizzle-seed` 使用版本控制来管理静态和动态数据的输出。为确保真正的确定性，请确保在使用相同的 `seed` 编号时值保持不变。如果对静态数据源或动态数据生成逻辑进行更改，版本将会更新，这样您可以选择坚持使用以前的版本或使用最新版本。

您可以升级到最新的 `drizzle-seed` 版本以获得新功能，例如额外的生成器，同时在需要时保持确定性输出的旧版本。这在您需要依赖现有确定性数据同时访问新功能时特别有用。

```ts
await seed(db, schema, { version: '2' });
```

## 历史
<TableWrapper>
|          API 版本  |   npm 版本    |     更改的生成器                             |
|  :-------------- | :-------------- | :-------------                         |
|       `v1`            | `0.1.1`          |                                         |
|       `v2 (LTS) `       | `0.2.1`          |`string()`, `interval({ isUnique: true })` |
</TableWrapper>

<Callout collapsed="底层工作原理？">
> 这不是实际的 API 更改；这只是我们如何进行 `drizzle-seed` 版本控制的一个示例。

例如，`lastName` 生成器发生了变化，新的版本 `V2` 的此生成器可用。

后来，`firstName` 生成器发生了改变，生成了此生成器的 `V3` 版本。

|                  |       `V1`       |      `V2`       |   `V3(最新)`   |
| :--------------: | :--------------: | :-------------: | :--------------: |
| **LastNameGen**  | `LastNameGenV1`  | `LastNameGenV2` |                  |
| **FirstNameGen** | `FirstNameGenV1` |                 | `FirstNameGenV3` |


##### 使用版本 3 的 `firstName` 生成器和版本 2 的 `lastName` 生成器
```ts
await seed(db, schema);
```

如果您尚未准备好立即使用最新的生成器版本，可以指定最大使用版本

##### 使用版本 1 的 `firstName` 生成器和版本 2 的 `lastName` 生成器
```ts
await seed(db, schema, { version: '2' });
```

##### 使用版本 1 的 `firstName` 生成器和版本 1 的 `lastName` 生成器。
```ts
await seed(db, schema, { version: '1' });
```

</Callout>

## 版本 2
#### 唯一的 `interval` 生成器已更改

<Callout title='升级原因'>
较旧版本的生成器可能生成类似 `1 minute 60 seconds` 和 `2 minutes 0 seconds` 的间隔，将它们视为不同的间隔。
然而，当将 `1 minute 60 seconds` 间隔插入到 PostgreSQL 数据库时，它会自动转换为 `2 minutes 0 seconds`。因此，在之后尝试将 `2 minutes 0 seconds` 间隔插入唯一列将会导致错误。
</Callout>

如果您的表包含类型为 `interval` 的唯一列，则会受到影响：
<Tabs items={['PostgreSQL']}>
<Tab>
```ts
import { drizzle } from "drizzle-orm/node-postgres";
import { pgTable, interval } from "drizzle-orm/pg-core";
import { seed } from "drizzle-seed";

const intervals = pgTable("intervals", {
    interval: interval().unique()
});

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);

  await seed(db, { intervals });
}

main();
```
</Tab>
</Tabs>

如果您在种子脚本中使用唯一的 `interval` 生成器，如下面的脚本所示，也会受到影响：
<Tabs items={['PostgreSQL', 'MySQL', 'SQLite']}>
<Tab>
```ts
import { drizzle } from "drizzle-orm/node-postgres";
import { pgTable, interval, char, varchar, text } from "drizzle-orm/pg-core";
import { seed } from "drizzle-seed";

const intervals = pgTable("intervals", {
    interval: interval().unique(),
    interval1: interval(),
    interval2: char({ length: 256 }).unique(),
    interval3: char({ length: 256 }),
    interval4: varchar().unique(),
    interval5: varchar(),
    interval6: text().unique(),
    interval7: text(),
});

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);

  await seed(db, { intervals }).refine((f) => ({
    intervals: {
        columns: {
            interval: f.interval({ isUnique: true }),
            interval1: f.interval({ isUnique: true }),
            interval2: f.interval({ isUnique: true }),
            interval3: f.interval({ isUnique: true }),
            interval4: f.interval({ isUnique: true }),
            interval5: f.interval({ isUnique: true }),
            interval6: f.interval({ isUnique: true }),
            interval7: f.interval({ isUnique: true }),
        }
    }
  }));
}

main();
```
</Tab>
<Tab>
```ts
import { binary, char, mysqlTable, text, varbinary, varchar } from 'drizzle-orm/mysql-core';
import { drizzle } from 'drizzle-orm/mysql2';
import { seed } from "drizzle-seed";

const intervals = mysqlTable('intervals', {
	interval1: char({ length: 255 }).unique(),
	interval2: char({ length: 255 }),
	interval3: varchar({ length: 255 }).unique(),
	interval4: varchar({ length: 255 }),
	interval5: binary({ length: 255 }).unique(),
	interval6: binary({ length: 255 }),
	interval7: varbinary({ length: 255 }).unique(),
	interval8: varbinary({ length: 255 }),
	interval9: text(),
});

async function main() {
	const db = drizzle(process.env.DATABASE_URL!);

	await seed(db, { intervals }, { version: '2' }).refine((f) => ({
		intervals: {
			columns: {
				interval: f.interval({ isUnique: true }),
				interval1: f.interval({ isUnique: true }),
				interval2: f.interval({ isUnique: true }),
				interval3: f.interval({ isUnique: true }),
				interval4: f.interval({ isUnique: true }),
				interval5: f.interval({ isUnique: true }),
				interval6: f.interval({ isUnique: true }),
				interval7: f.interval({ isUnique: true }),
				interval8: f.interval({ isUnique: true }),
				interval9: f.interval({ isUnique: true }),
			},
		},
	}));
}

main();

```
</Tab>
<Tab>
```ts
import { blob, sqliteTable, text } from 'drizzle-orm/sqlite-core';
import { drizzle } from 'drizzle-orm/better-sqlite3';
import { seed } from 'drizzle-seed';

const intervals = sqliteTable('intervals', {
	interval1: text().unique(),
	interval2: text(),
	interval3: blob().unique(),
	interval4: blob(),
});

async function main() {
	const db = drizzle(process.env.DATABASE_URL!);

	await seed(db, { intervals }).refine((f) => ({
		intervals: {
			columns: {
				interval1: f.interval({ isUnique: true }),
				interval2: f.interval({ isUnique: true }),
				interval3: f.interval({ isUnique: true }),
				interval4: f.interval({ isUnique: true }),
			},
		},
	}));
}

main();

```
</Tab>
</Tabs>

#### `string` 生成器已更改：包括非唯一和唯一的

<Callout title='升级原因'>
能够根据文本列的长度生成唯一字符串（例如，`varchar(20)`）
</Callout>

如果您的表包含具有最大长度参数的文本类型列或唯一文本类型列，则会受到影响：
<Tabs items={['PostgreSQL', 'MySQL', 'SQLite']}>
<Tab>
```ts
import { drizzle } from "drizzle-orm/node-postgres";
import { pgTable, char, varchar, text } from "drizzle-orm/pg-core";
import { seed } from "drizzle-seed";

const strings = pgTable("strings", {
    string2: char({ length: 256 }).unique(),
    string3: char({ length: 256 }),
    string4: varchar().unique(),
    string5: varchar({ length: 256 }).unique(),
    string6: varchar({ length: 256 }),
    string7: text().unique(),
});

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);

  await seed(db, { strings });
}

main();
```
</Tab>
<Tab>
```ts
import { binary, char, mysqlTable, varbinary, varchar } from 'drizzle-orm/mysql-core';
import { drizzle } from 'drizzle-orm/mysql2';
import { seed } from "drizzle-seed";

const strings = mysqlTable('strings', {
	string1: char({ length: 255 }).unique(),
	string2: char({ length: 255 }),
	string3: varchar({ length: 255 }).unique(),
	string4: varchar({ length: 255 }),
	string5: binary({ length: 255 }).unique(),
	string6: binary({ length: 255 }),
	string7: varbinary({ length: 255 }).unique(),
	string8: varbinary({ length: 255 }),
});

async function main() {
	const db = drizzle(process.env.DATABASE_URL!);

	await seed(db, { strings });
}

main();

```
</Tab>
<Tab>
```ts
import { drizzle } from 'drizzle-orm/better-sqlite3';
import { blob, sqliteTable, text } from 'drizzle-orm/sqlite-core';
import { seed } from "drizzle-seed";

const strings = sqliteTable('strings', {
	string1: text().unique(),
	string2: text({ length: 256 }),
	string3: text({ length: 256 }).unique(),
	string4: blob().unique(),
});

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);

  await seed(db, { strings });
}

main();
```
</Tab>
</Tabs>

如果您在种子脚本中使用 `string` 生成器，如下面的脚本所示，也会受到影响：
<Tabs items={['PostgreSQL', 'MySQL', 'SQLite']}>
<Tab>
```ts
import { drizzle } from "drizzle-orm/node-postgres";
import { pgTable, char, varchar, text } from "drizzle-orm/pg-core";
import { seed } from "drizzle-seed";

const strings = pgTable("strings", {
    string1: char({ length: 256 }).unique(),
    string2: char({ length: 256 }),
    string3: char({ length: 256 }),
    string4: varchar(),
    string5: varchar().unique(),
    string6: varchar({ length: 256 }).unique(),
    string7: varchar({ length: 256 }),
    string8: varchar({ length: 256 }),
    string9: text().unique(),
    string10: text(),
});

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);

  await seed(db, { strings }).refine((f) => ({
    strings: {
        columns: {
            string1: f.string({ isUnique: true }),
            string2: f.string(),
            string3: f.string({ isUnique: true }),
            string4: f.string({ isUnique: true }),
            string5: f.string({ isUnique: true }),
            string6: f.string({ isUnique: true }),
            string7: f.string(),
            string8: f.string({ isUnique: true }),
            string9: f.string({ isUnique: true }),
            string10: f.string({ isUnique: true }),
        }
    }
  }));
}

main();
```
</Tab>
<Tab>
```ts
import { binary, char, mysqlTable, text, varbinary, varchar } from 'drizzle-orm/mysql-core';
import { drizzle } from 'drizzle-orm/mysql2';
import { seed } from "drizzle-seed";

const strings = mysqlTable('strings', {
	string1: char({ length: 255 }).unique(),
	string2: char({ length: 255 }),
	string3: char({ length: 255 }),
	string4: varchar({ length: 255 }).unique(),
	string5: varchar({ length: 255 }),
	string6: varchar({ length: 255 }),
	string7: binary({ length: 255 }).unique(),
	string8: binary({ length: 255 }),
	string9: binary({ length: 255 }),
	string10: varbinary({ length: 255 }).unique(),
	string11: varbinary({ length: 255 }),
	string12: varbinary({ length: 255 }),
	string13: text(),
});

async function main() {
	const db = drizzle(process.env.DATABASE_URL!);

	await seed(db, { strings }).refine((f) => ({
		strings: {
			columns: {
				string1: f.string({ isUnique: true }),
				string2: f.string({ isUnique: true }),
				string3: f.string(),
				string4: f.string({ isUnique: true }),
				string5: f.string({ isUnique: true }),
				string6: f.string(),
				string7: f.string({ isUnique: true }),
				string8: f.string({ isUnique: true }),
				string9: f.string(),
				string10: f.string({ isUnique: true }),
				string11: f.string({ isUnique: true }),
				string12: f.string(),
				string13: f.string({ isUnique: true }),
			},
		},
	}));
}

main();
```
</Tab>
<Tab>
```ts
import { blob, sqliteTable, text } from 'drizzle-orm/sqlite-core';
import { drizzle } from 'drizzle-orm/better-sqlite3';
import { seed } from "drizzle-seed";

const strings = sqliteTable("strings", {
    string1: text().unique(),
	string2: text(),
	string3: text({ length: 256 }).unique(),
	string4: text({ length: 256 }),
	string5: text({ length: 256 }),
	string6: blob().unique(),
	string7: blob(),
});

async function main() {
	const db = drizzle(process.env.DATABASE_URL!);

	await seed(db, { strings }).refine((f) => ({
		strings: {
			columns: {
				string1: f.string({ isUnique: true }),
				string2: f.string({ isUnique: true }),
				string3: f.string({ isUnique: true }),
				string4: f.string({ isUnique: true }),
				string5: f.string(),
				string6: f.string({ isUnique: true }),
				string7: f.string({ isUnique: true }),
			},
		},
	}));
}

main();
```
</Tab>
</Tabs>

Source: https://drizzle.zhcndoc.com/docs/select

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import CodeTabs from '@mdx/CodeTabs.astro';
import Callout from '@mdx/Callout.astro';
import Section from '@mdx/Section.astro';
import IsSupportedChipGroup from '@mdx/IsSupportedChipGroup.astro';
import $count from '@mdx/$count.mdx';

# SQL 选择
Drizzle 为您提供了从数据库中获取数据的最 SQL 风格的方法，同时保持类型安全和可组合性。
它原生支持几乎每种方言的所有查询特性和能力，
而其尚不支持的功能，可以通过强大的 [`sql`](/docs/sql) 操作符由用户添加。

假设您有一个如下面定义的 `users` 表：
<Tabs items={['PostgreSQL', 'MySQL', 'SQLite', 'SingleStore']}>
<Tab>
```typescript
import { pgTable, serial, text } from 'drizzle-orm/pg-core';

export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  age: integer('age'),
});
```
</Tab>
<Tab>
```typescript
import { mysqlTable, serial, text, int } from 'drizzle-orm/mysql-core';

export const users = mysqlTable('users', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  age: int('age'),
});
```
</Tab>
<Tab>
```typescript
import { sqliteTable, integer, text } from 'drizzle-orm/sqlite-core';

export const users = sqliteTable('users', {
  id: integer('id').primaryKey(),
  name: text('name').notNull(),
  age: integer('age'),
});
```
</Tab>
<Tab>
```typescript
import { singlestoreTable, serial, text, int } from 'drizzle-orm/singlestore-core';

export const users = singlestoreTable('users', {
  id: int('id').primaryKey(),
  name: text('name').notNull(),
  age: int('age'),
});
```
</Tab>
</Tabs>

### 基本选择
从一个表中选择所有行，包括所有列：

<Section>
```typescript
const result = await db.select().from(users);
/*
  {
    id: number;
    name: string;
    age: number | null;
  }[]
*/
```
```sql
select "id", "name", "age" from "users";
```
</Section>

注意结果类型是根据表的定义自动推断的，包括列的可空性。

<Callout type="info">
Drizzle 始终在 `select` 子句中明确列出列，而不是使用 `select *`。<br />
这是内部要求的，以保证查询结果中的字段顺序，也是通常认为的良好实践。
</Callout>

### 部分选择
在某些情况下，您可能只想选择表中的一部分列。
您可以通过向 `.select()` 方法提供选择对象来实现：
<Section>
```typescript copy
const result = await db.select({
  field1: users.id,
  field2: users.name,
}).from(users);

const { field1, field2 } = result[0];
```
```sql
select "id", "name" from "users";
```
</Section>

与 SQL 一样，您可以使用任意表达式作为选择字段，而不仅仅是表列：

<Section>
```typescript
const result = await db.select({
  id: users.id,
  lowerName: sql<string>`lower(${users.name})`,
}).from(users);
```
```sql
select "id", lower("name") from "users";
```
</Section>

<Callout type="warning">
通过指定 `sql<string>`，您告诉 Drizzle 该字段的 **预期** 类型为 `string`。<br />
如果您错误地指定（例如，对将作为字符串返回的字段使用 `sql<number>`），运行时值将与预期类型不匹配。
Drizzle 不能根据提供的类型泛型执行任何类型转换，因为该信息在运行时不可用。

如果您需要对返回值应用运行时转换，您可以使用 [`.mapWith()`](/docs/sql#sqlmapwith) 方法。
</Callout>

### 条件选择

您可以基于某个条件拥有动态选择对象：

```typescript
async function selectUsers(withName: boolean) {
  return db
    .select({
      id: users.id,
      ...(withName ? { name: users.name } : {}),
    })
    .from(users);
}

const users = await selectUsers(true);
```

### 不重复选择

您可以使用 `.selectDistinct()` 代替 `.select()` 以仅从数据集中检索唯一行：
<Section>
```ts
await db.selectDistinct().from(users).orderBy(users.id, users.name);

await db.selectDistinct({ id: users.id }).from(users).orderBy(users.id);
```
```sql
select distinct "id", "name" from "users" order by "id", "name";

select distinct "id" from "users" order by "id";
```
</Section>

在 PostgreSQL 中，您还可以使用 `distinct on` 子句指定唯一行的确定方式：
<Callout type='warning'>
`distinct on` 子句仅在 PostgreSQL 中受支持。
</Callout>
<Section>
```ts
await db.selectDistinctOn([users.id]).from(users).orderBy(users.id);
await db.selectDistinctOn([users.name], { name: users.name }).from(users).orderBy(users.name);
```
```sql
select distinct on ("id") "id", "name" from "users" order by "id";
select distinct on ("name") "name" from "users" order by "name";
```
</Section>



### 高级选择
借助 TypeScript，Drizzle API 让您以各种灵活的方式构建选择查询。

高级部分选择的预览，更多详细的高级用法示例请参阅我们[专门的指南](/docs/guides/include-or-exclude-columns)。
<CodeTabs items={["示例 1", "示例 2", "示例 3", "示例 4"]}>
```ts
import { getTableColumns, sql } from 'drizzle-orm';

await db.select({
    ...getTableColumns(posts),
    titleLength: sql<number>`length(${posts.title})`,
  }).from(posts);
```
```ts
import { getTableColumns } from 'drizzle-orm';

const { content, ...rest } = getTableColumns(posts); // 排除 "content" 列
await db.select({ ...rest }).from(posts); // 选择所有其他列
```
```ts
await db.query.posts.findMany({
  columns: {
    title: true,
  },
});
```
```ts
await db.query.posts.findMany({
  columns: {
    content: false,
  },
});
```
</CodeTabs>

## ---

### 过滤器

您可以使用 [过滤操作符](/docs/operators) 在 `.where()` 方法中过滤查询结果：

<Section>
```typescript copy
import { eq, lt, gte, ne } from 'drizzle-orm';

await db.select().from(users).where(eq(users.id, 42));
await db.select().from(users).where(lt(users.id, 42));
await db.select().from(users).where(gte(users.id, 42));
await db.select().from(users).where(ne(users.id, 42));
...
```
```sql
select "id", "name", "age" from "users" where "id" = 42;
select "id", "name", "age" from "users" where "id" < 42;
select "id", "name", "age" from "users" where "id" >= 42;
select "id", "name", "age" from "users" where "id" <> 42;
```
</Section>

所有过滤操作符都使用 [`sql`](/docs/sql) 函数实现。
您可以自行使用它编写任意 SQL 过滤器，或构建自己的操作符。
有关灵感，您可以查看 Drizzle 提供的操作符是如何[实现](https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sql/expressions/conditions.ts)的。
<Section>
```typescript copy
import { sql } from 'drizzle-orm';

function equals42(col: Column) {
  return sql`${col} = 42`;
}

await db.select().from(users).where(sql`${users.id} < 42`);
await db.select().from(users).where(sql`${users.id} = 42`);
await db.select().from(users).where(equals42(users.id));
await db.select().from(users).where(sql`${users.id} >= 42`);
await db.select().from(users).where(sql`${users.id} <> 42`);
await db.select().from(users).where(sql`lower(${users.name}) = 'aaron'`);
```
```sql
select "id", "name", "age" from "users" where 'id' < 42;
select "id", "name", "age" from "users" where 'id' = 42;
select "id", "name", "age" from "users" where 'id' = 42;
select "id", "name", "age" from "users" where 'id' >= 42;
select "id", "name", "age" from "users" where 'id' <> 42;
select "id", "name", "age" from "users" where lower("name") = 'aaron';
```
</Section>

<Callout type='info'>
所有提供给过滤操作符和 `sql` 函数的值都会自动参数化。
例如，这个查询：
```ts
await db.select().from(users).where(eq(users.id, 42));
```
将被翻译为：
```sql
select "id", "name", "age" from "users" where "id" = $1; -- params: [42]
```
</Callout>

使用 `not` 操作符反转条件：
<Section>
```typescript copy
import { eq, not, sql } from 'drizzle-orm';

await db.select().from(users).where(not(eq(users.id, 42)));
await db.select().from(users).where(sql`not ${users.id} = 42`);
```
```sql
select "id", "name", "age" from "users" where not ("id" = 42);
select "id", "name", "age" from "users" where not ("id" = 42);
```
</Section>

<Callout type="info">
您可以安全地更改模式，重命名表和列
并且由于模板插值，它将在您的查询中自动反映出来，
而不是在编写原始 SQL 时硬编码列或表名。
</Callout>

### 组合过滤器
您可以逻辑上结合过滤操作符与 `and()` 和 `or()` 操作符：
<Section>
```typescript copy
import { eq, and, sql } from 'drizzle-orm';

await db.select().from(users).where(
  and(
    eq(users.id, 42),
    eq(users.name, 'Dan')
  )
);
await db.select().from(users).where(sql`${users.id} = 42 and ${users.name} = 'Dan'`);
```
```sql
select "id", "name", "age" from "users" where "id" = 42 and "name" = 'Dan';
select "id", "name", "age" from "users" where "id" = 42 and "name" = 'Dan';
```
</Section>

<Section>
```typescript copy
import { eq, or, sql } from 'drizzle-orm';

await db.select().from(users).where(
  or(
    eq(users.id, 42), 
    eq(users.name, 'Dan')
  )
);
await db.select().from(users).where(sql`${users.id} = 42 or ${users.name} = 'Dan'`);
```
```sql
select "id", "name", "age" from "users" where "id" = 42 or "name" = 'Dan';
select "id", "name", "age" from "users" where "id" = 42 or "name" = 'Dan';
```
</Section>

### 高级过滤器
结合 TypeScript，Drizzle API 为您提供强大而灵活的方式来组合查询中的过滤器。

条件过滤的预览，更多详细的高级用法示例请参阅我们[专门的指南](/docs/guides/conditional-filters-in-query)。
<CodeTabs items={["示例 1", "示例 2"]}>
```ts
const searchPosts = async (term?: string) => {
  await db
    .select()
    .from(posts)
    .where(term ? ilike(posts.title, term) : undefined);
};
await searchPosts();
await searchPosts('AI');
```
```ts
const searchPosts = async (filters: SQL[]) => {
  await db
    .select()
    .from(posts)
    .where(and(...filters));
};
const filters: SQL[] = [];
filters.push(ilike(posts.title, 'AI'));
filters.push(inArray(posts.category, ['Tech', 'Art', 'Science']));
filters.push(gt(posts.views, 200));
await searchPosts(filters);
```
</CodeTabs>

## ---

### 限制与偏移
使用 `.limit()` 和 `.offset()` 向查询添加 `limit` 和 `offset` 子句 - 例如，实现分页：
<Section>
```typescript
await db.select().from(users).limit(10);
await db.select().from(users).limit(10).offset(10);
```
```sql
select "id", "name", "age" from "users" limit 10;
select "id", "name", "age" from "users" limit 10 offset 10;
```
</Section>

### 排序
使用 `.orderBy()` 向查询添加 `order by` 子句，按指定字段对结果进行排序：
<Section>
```typescript
import { asc, desc } from 'drizzle-orm';

await db.select().from(users).orderBy(users.name);
await db.select().from(users).orderBy(desc(users.name));

// 按多个字段排序
await db.select().from(users).orderBy(users.name, users.name2);
await db.select().from(users).orderBy(asc(users.name), desc(users.name2));
```
```sql
select "id", "name", "age" from "users" order by "name";
select "id", "name", "age" from "users" order by "name" desc;

select "id", "name", "age" from "users" order by "name", "name2";
select "id", "name", "age" from "users" order by "name" asc, "name2" desc;
```
</Section>

### 高级分页
由 TypeScript 驱动，Drizzle APIs 允许您实现所有可能的 SQL 分页和排序方法。

高级分页的预览，更多详细的高级使用示例 - 
请参见我们专门的 [限制偏移分页](/docs/guides/limit-offset-pagination) 和
[游标分页](/docs/guides/cursor-based-pagination) 指南。

<CodeTabs items={["示例 1", "示例 2", "示例 3", "示例 4"]}>
```ts
await db
  .select()
  .from(users)
  .orderBy(asc(users.id)) // order by 是必须的
  .limit(4) // 返回的行数
  .offset(4); // 跳过的行数
```
```ts
const getUsers = async (page = 1, pageSize = 3) => {
  await db.query.users.findMany({
    orderBy: (users, { asc }) => asc(users.id),
    limit: pageSize,
    offset: (page - 1) * pageSize,
  });
};
await getUsers();
```
```ts
const getUsers = async (page = 1, pageSize = 10) => {
   const sq = db
    .select({ id: users.id })
    .from(users)
    .orderBy(users.id)
    .limit(pageSize)
    .offset((page - 1) * pageSize)
    .as('subquery');
   await db.select().from(users).innerJoin(sq, eq(users.id, sq.id)).orderBy(users.id);
};
```
```ts
const nextUserPage = async (cursor?: number, pageSize = 3) => {
  await db
    .select()
    .from(users)
    .where(cursor ? gt(users.id, cursor) : undefined) // 如果提供了游标，则获取该游标之后的行
    .limit(pageSize) // 返回的行数
    .orderBy(asc(users.id)); // 排序
};
// 传递前一页最后一行的游标 (id)
await nextUserPage(3);
```
</CodeTabs>

## ---

### WITH 子句

<Callout>
  查看如何与 [插入](/docs/insert#with-insert-clause), [更新](/docs/update#with-update-clause), [删除](/docs/delete#with-delete-clause) 一起使用 WITH 语句
</Callout>

使用 `with` 子句可以通过将复杂查询拆分成较小的子查询（称为公共表表达式（CTEs））来简化查询：
<Section>
```typescript copy
const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));

const result = await db.with(sq).select().from(sq);
```
```sql
with sq as (select "id", "name", "age" from "users" where "id" = 42)
select "id", "name", "age" from sq;
```
</Section>

您还可以在 `with` 中提供 `insert`、`update` 和 `delete` 语句。

<Section>
```typescript copy
const sq = db.$with('sq').as(
    db.insert(users).values({ name: 'John' }).returning(),
);

const result = await db.with(sq).select().from(sq);
```
```sql
with "sq" as (insert into "users" ("id", "name") values (default, 'John') returning "id", "name") 
select "id", "name" from "sq"
```
</Section>

<Section>
```typescript copy
const sq = db.$with('sq').as(
    db.update(users).set({ age: 25 }).where(eq(users.name, 'John')).returning(),
);
const result = await db.with(sq).select().from(sq);
```
```sql
with "sq" as (update "users" set "age" = 25 where "users"."name" = 'John' returning "id", "name", "age") 
select "id", "name", "age" from "sq"
```
</Section>

<Section>
```typescript copy
const sq = db.$with('sq').as(
  db.delete(users).where(eq(users.name, 'John')).returning(),
);

const result = await db.with(sq).select().from(sq);
```
```sql
with "sq" as (delete from "users" where "users"."name" = $1 returning "id", "name", "age") 
select "id", "name", "age" from "sq"
```
</Section>

若要选择 CTE 中的任意 SQL 值作为字段并在其他 CTE 或主查询中引用它们，
您需要为它们添加别名：
```typescript copy

const sq = db.$with('sq').as(db.select({ 
  name: sql<string>`upper(${users.name})`.as('name'),
})
.from(users));

const result = await db.with(sq).select({ name: sq.name }).from(sq);
```
如果您不提供别名，字段类型将变为 `DrizzleTypeError`，您将无法在其他查询中引用它。
如果忽略类型错误并仍然尝试使用该字段，
您将得到运行时错误，因为没有方法可以在没有别名的情况下引用该字段。

### 从子查询中选择
就像在 SQL 中一样，您可以通过使用子查询 API 将查询嵌套到其他查询中：
<Section>
```typescript copy
const sq = db.select().from(users).where(eq(users.id, 42)).as('sq');
const result = await db.select().from(sq);
```
```sql
select "id", "name", "age" from (select "id", "name", "age" from "users" where "id" = 42) "sq";
```
</Section>

子查询可以在任何可以使用表的位置使用，例如在联接中：
<Section>
```typescript copy
const sq = db.select().from(users).where(eq(users.id, 42)).as('sq');
const result = await db.select().from(users).leftJoin(sq, eq(users.id, sq.id));
```
```sql
select "users"."id", "users"."name", "users"."age", "sq"."id", "sq"."name", "sq"."age" from "users"
  left join (select "id", "name", "age" from "users" where "id" = 42) "sq"
    on "users"."id" = "sq"."id";
```
</Section>

## ---

### 聚合
使用 Drizzle，您可以通过使用 `sum`、`count`、`avg` 等函数进行聚合，
通过 `.groupBy()` 和 `.having()` 分别进行分组和过滤，就像在原始 SQL 中一样：

<Section>
```typescript
import { gt } from 'drizzle-orm';

await db.select({
  age: users.age,
  count: sql<number>`cast(count(${users.id}) as int)`,
})
  .from(users)
  .groupBy(users.age);

await db.select({
  age: users.age,
  count: sql<number>`cast(count(${users.id}) as int)`,
})
  .from(users)
  .groupBy(users.age)
  .having(({ count }) => gt(count, 1));
```
```sql
select "age", cast(count("id") as int)
  from "users"
  group by "age";

select "age", cast(count("id") as int)
  from "users"
  group by "age"
  having cast(count("id") as int) > 1;
```
</Section>

<Callout type="info">
`cast(... as int)` 是必要的，因为 `count()` 在 PostgreSQL 中返回 `bigint`，在 MySQL 中返回 `decimal`，这些被视为字符串值而不是数字。
或者，您可以使用 [`.mapWith(Number)`](/docs/sql#sqlmapwith) 在运行时将值转换为数字。

如果您需要计数聚合 - 建议使用我们的 [`$count`](/docs/select#count) API
</Callout>

### 聚合助手

Drizzle 具有一系列封装的 `sql` 函数，因此您无需为应用中的常见情况编写
`sql` 模板。

<Callout type="info">
 请记住，聚合函数通常与 SELECT 语句的 GROUP BY 子句一起使用。
 因此，如果您在一个查询中选择使用聚合函数和其他列， 
 请确保使用 `.groupBy` 子句。
</Callout>


**count**

返回 `expression` 中的值的数量。
<Section>
```ts
import { count } from 'drizzle-orm'

await db.select({ value: count() }).from(users);
await db.select({ value: count(users.id) }).from(users);
```
```sql
select count("*") from "users";
select count("id") from "users";
```
```ts
// 相当于写
await db.select({ 
  value: sql`count('*'))`.mapWith(Number) 
}).from(users);

await db.select({ 
  value: sql`count(${users.id})`.mapWith(Number) 
}).from(users);
```
</Section>

**countDistinct**

返回 `expression` 中非重复值的数量。
<Section>
```ts
import { countDistinct } from 'drizzle-orm'

await db.select({ value: countDistinct(users.id) }).from(users);
```
```sql
select count(distinct "id") from "users";
```
```ts
// 相当于写
await db.select({ 
  value: sql`count(${users.id})`.mapWith(Number) 
}).from(users);
```
</Section>

**avg**

返回 `expression` 中所有非空值的平均值（算术平均数）。
<Section>
```ts
import { avg } from 'drizzle-orm'

await db.select({ value: avg(users.id) }).from(users);
```
```sql
select avg("id") from "users";
```
```ts
// 相当于写
await db.select({ 
  value: sql`avg(${users.id})`.mapWith(String) 
}).from(users);
```
</Section>

**avgDistinct**

返回 `expression` 中所有非空值的平均值（算术平均数）。
<Section>
```ts
import { avgDistinct } from 'drizzle-orm'

await db.select({ value: avgDistinct(users.id) }).from(users);
```
```sql
select avg(distinct "id") from "users";
```
```ts
// 相当于写
await db.select({ 
  value: sql`avg(distinct ${users.id})`.mapWith(String) 
}).from(users);
```
</Section>

**sum**

返回 `expression` 中所有非空值的和。
<Section>
```ts
import { sum } from 'drizzle-orm'

await db.select({ value: sum(users.id) }).from(users);
```
```sql
select sum("id") from "users";
```
```ts
// 相当于写
await db.select({ 
  value: sql`sum(${users.id})`.mapWith(String) 
}).from(users);
```
</Section>

**sumDistinct**

返回 `expression` 中所有非空和非重复值的和。
<Section>
```ts
import { sumDistinct } from 'drizzle-orm'

await db.select({ value: sumDistinct(users.id) }).from(users);
```
```sql
select sum(distinct "id") from "users";
```
```ts
// 相当于写
await db.select({ 
  value: sql`sum(distinct ${users.id})`.mapWith(String) 
}).from(users);
```
</Section>

**max**

返回 `expression` 中的最大值。
<Section>
```ts
import { max } from 'drizzle-orm'

await db.select({ value: max(users.id) }).from(users);
```
```sql
select max("id") from "users";
```
```ts
// 相当于写
await db.select({ 
  value: sql`max(${expression})`.mapWith(users.id) 
}).from(users);
```
</Section>

**min**

返回 `expression` 中的最小值。
<Section>
```ts
import { min } from 'drizzle-orm'

await db.select({ value: min(users.id) }).from(users);
```
```sql
select min("id") from "users";
```
```ts
// 相当于写
await db.select({ 
  value: sql`min(${users.id})`.mapWith(users.id) 
}).from(users);
```
</Section>

更高级的示例：

```typescript copy
const orders = sqliteTable('order', {
  id: integer('id').primaryKey(),
  orderDate: integer('order_date', { mode: 'timestamp' }).notNull(),
  requiredDate: integer('required_date', { mode: 'timestamp' }).notNull(),
  shippedDate: integer('shipped_date', { mode: 'timestamp' }),
  shipVia: integer('ship_via').notNull(),
  freight: numeric('freight').notNull(),
  shipName: text('ship_name').notNull(),
  shipCity: text('ship_city').notNull(),
  shipRegion: text('ship_region'),
  shipPostalCode: text('ship_postal_code'),
  shipCountry: text('ship_country').notNull(),
  customerId: text('customer_id').notNull(),
  employeeId: integer('employee_id').notNull(),
});

const details = sqliteTable('order_detail', {
  unitPrice: numeric('unit_price').notNull(),
  quantity: integer('quantity').notNull(),
  discount: numeric('discount').notNull(),
  orderId: integer('order_id').notNull(),
  productId: integer('product_id').notNull(),
});


db
  .select({
    id: orders.id,
    shippedDate: orders.shippedDate,
    shipName: orders.shipName,
    shipCity: orders.shipCity,
    shipCountry: orders.shipCountry,
    productsCount: sql<number>`cast(count(${details.productId}) as int)`,
    quantitySum: sql<number>`sum(${details.quantity})`,
    totalPrice: sql<number>`sum(${details.quantity} * ${details.unitPrice})`,
  })
  .from(orders)
  .leftJoin(details, eq(orders.id, details.orderId))
  .groupBy(orders.id)
  .orderBy(asc(orders.id))
  .all();
```

### $count
<$count />

## ---

### 迭代器

<IsSupportedChipGroup chips={{ 'MySQL': true, 'PostgreSQL[WIP]': false, 'SQLite[WIP]': false, 'SingleStore[WIP]': false }} />

如果您需要从查询中返回大量行而不希望将它们全部加载到内存中，可以使用 `.iterator()` 将查询转换为异步迭代器：

```ts copy
const iterator = await db.select().from(users).iterator();

for await (const row of iterator) {
  console.log(row);
}
```

它也适用于准备好的语句：

```ts copy
const query = await db.select().from(users).prepare();
const iterator = await query.iterator();

for await (const row of iterator) {
  console.log(row);
}
```

## ---

### 使用索引

`USE INDEX` 提示告诉优化器在处理查询时考虑哪些索引。优化器不会强制使用这些索引，但如果它们合适，会优先使用它们。

<IsSupportedChipGroup chips={{ 'MySQL': true, 'PostgreSQL': false, 'SQLite': false, 'SingleStore': false }} />

```ts copy
export const users = mysqlTable('users', {
	id: int('id').primaryKey(),
	name: varchar('name', { length: 100 }).notNull(),
}, () => [usersTableNameIndex]);

const usersTableNameIndex = index('users_name_index').on(users.name);

await db.select()
  .from(users, { useIndex: usersTableNameIndex })
  .where(eq(users.name, 'David'));
```

您还可以在任何您想要的连接上使用此选项

```ts
await db.select()
  .from(users)
  .leftJoin(posts, eq(posts.userId, users.id), { useIndex: usersTableNameIndex })
  .where(eq(users.name, 'David'));
```

### 忽略索引

`IGNORE INDEX` 提示告诉优化器避免使用特定的索引来处理查询。MySQL 将考虑所有其他索引（如果有的话），或在必要时执行全表扫描。

<IsSupportedChipGroup chips={{ 'MySQL': true, 'PostgreSQL': false, 'SQLite': false, 'SingleStore': false }} />

```ts copy
export const users = mysqlTable('users', {
	id: int('id').primaryKey(),
	name: varchar('name', { length: 100 }).notNull(),
}, () => [usersTableNameIndex]);

const usersTableNameIndex = index('users_name_index').on(users.name);

await db.select()
  .from(users, { ignoreIndex: usersTableNameIndex })
  .where(eq(users.name, 'David'));
```

您还可以在任何您想要的连接上使用此选项

```ts
await db.select()
  .from(users)
  .leftJoin(posts, eq(posts.userId, users.id), { useIndex: usersTableNameIndex })
  .where(eq(users.name, 'David'));
```


### 强制索引

`FORCE INDEX`提示强制优化器使用指定的索引进行查询。如果指定的索引无法使用，MySQL不会回退到其他索引；它可能会改为进行全表扫描。

<IsSupportedChipGroup chips={{ 'MySQL': true, 'PostgreSQL': false, 'SQLite': false, 'SingleStore': false }} />

```ts copy
export const users = mysqlTable('users', {
	id: int('id').primaryKey(),
	name: varchar('name', { length: 100 }).notNull(),
}, () => [usersTableNameIndex]);

const usersTableNameIndex = index('users_name_index').on(users.name);

await db.select()
  .from(users, { forceIndex: usersTableNameIndex })
  .where(eq(users.name, 'David'));
```

您还可以在任何您想要的连接上使用此选项

```ts
await db.select()
  .from(users)
  .leftJoin(posts, eq(posts.userId, users.id), { useIndex: usersTableNameIndex })
  .where(eq(users.name, 'David'));
```


Source: https://drizzle.zhcndoc.com/docs/sequences

import IsSupportedChipGroup from '@mdx/IsSupportedChipGroup.astro';
import Callout from '@mdx/Callout.astro';

# 序列

<Callout type="info">
要使用此功能，您需要安装 `drizzle-orm@0.32.0` 或更高版本，以及 `drizzle-kit@0.23.0` 或更高版本
</Callout>

<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'SQLite': false, 'MySQL': false, 'SingleStore': false }} />

PostgreSQL 中的序列是特殊的单行表，用于生成唯一标识符，通常用于自动递增的主键值。它们提供了一种线程安全的方式，以在多个会话中生成唯一的连续值。
<br/>

**关键特性**
- 创建和初始化：使用 CREATE SEQUENCE 创建新序列。可以指定增量值、起始值、最小/最大值和缓存大小等参数。

- 操作函数
    - `nextval('sequence_name')`：推进序列并返回下一个值。
    - `currval('sequence_name')`：返回当前会话中序列的当前值。
    - `setval('sequence_name', value)`：设置序列的当前值。
    - `lastval()`：返回当前会话中由 nextval 返回的最后一个值。

- 所有权：序列可以通过 OWNED BY 子句与表列链接。删除表或列时，将自动删除相关序列。
- 循环：当序列达到其最大值或最小值时，可以使用 CYCLE 选项设置为循环。默认值为 NO CYCLE。
- 缓存：可以使用 CACHE 选项预分配序列值以提高性能。
<br/>

**限制**
- 间隙：序列不是无间隙的。已中止的事务或崩溃可能导致序列值出现间隙。
- 并发性：虽然序列在会话之间提供唯一值，但考虑所有会话时，这些值可能会乱序。
- 不可回滚：如果事务失败，则序列的更改不会回滚。这确保了唯一值，但可能会导致间隙。
- 崩溃恢复：未记录的序列或在崩溃前已修改的序列可能无法正确恢复到其先前状态。
<br/>

**实际使用**
- 默认行为：默认情况下，序列每次递增 1，从 1 开始。
- 自定义行为：可以指定自定义的起始点、增量、最小/最大值和循环。
- 关联性：通常与表列关联，用于自动递增字段，使唯一标识符的管理变得无缝。
<br/>

**使用示例**
```ts
import { pgSchema, pgSequence } from "drizzle-orm/pg-core";

// 未指定参数
export const customSequence = pgSequence("name");

// 带参数的序列
export const customSequence = pgSequence("name", {
      startWith: 100,
      maxValue: 10000,
      minValue: 100,
      cycle: true,
      cache: 10,
      increment: 2
});

// 自定义架构中的序列
export const customSchema = pgSchema('custom_schema');
export const customSequence = customSchema.sequence("name");
```

Source: https://drizzle.zhcndoc.com/docs/set-operations

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import CodeTabs from '@mdx/CodeTabs.astro';
import CodeTab from '@mdx/CodeTab.astro';
import Callout from '@mdx/Callout.astro';

# 集合操作

SQL 集合操作将多个查询块的结果结合成单个结果。
SQL 标准定义了以下三种集合操作：`UNION`、`INTERSECT`、`EXCEPT`、`UNION ALL`、`INTERSECT ALL`、`EXCEPT ALL`。

### 并集（Union）
将两个查询块的所有结果组合成单个结果，省略任何重复项。

获取 customers 和 users 表中的所有名称，不带重复。

<Tabs items={["PostgreSQL", "MySQL", "SQLite", "SingleStore"]}>
  <Tab>
  <CodeTabs items={["import-pattern", "builder-pattern", "schema.ts"]}>
	<CodeTab>
	```typescript copy
    import { union } from 'drizzle-orm/pg-core'
    import { users, customers } from './schema'

    const allNamesForUserQuery = db.select({ name: users.name }).from(users);

    const result = await union(
		allNamesForUserQuery,
		db.select({ name: customers.name }).from(customers)
	).limit(10);
    ```
    ```sql
    (select "name" from "sellers")
    union
    (select "name" from "customers")
    limit $1
    ```
    </CodeTab>
    <CodeTab>
    ```ts copy
    import { users, customers } from './schema'

    const result = await db
      .select({ name: users.name })
      .from(users)
      .union(db.select({ name: customers.name }).from(customers))
      .limit(10);
    ```
    ```sql
    (select "name" from "sellers")
    union
    (select "name" from "customers")
    limit $1
    ```
	</CodeTab>
    <CodeTab>
	```typescript copy
    import { integer, pgTable, text, varchar } from "drizzle-orm/pg-core";

    const users = pgTable('sellers', {
        id: integer('id').primaryKey(),
        name: varchar('name', { length: 256 }).notNull(),
        address: text('address'),
    });
    
    const customers = pgTable('customers', {
        id: integer('id').primaryKey(),
        name: varchar('name', { length: 256 }).notNull(),
        city: text('city'),
        email: varchar('email', { length: 256 }).notNull()
    });
    ```
    </CodeTab>
  </CodeTabs>
  </Tab> 
  <Tab>
  <CodeTabs items={["import-pattern", "builder-pattern", "schema.ts"]}>
	<CodeTab>
	```typescript copy
    import { union } from 'drizzle-orm/mysql-core'
    import { users, customers } from './schema'

    const allNamesForUserQuery = db.select({ name: users.name }).from(users);

    const result = await union(
		allNamesForUserQuery,
		db.select({ name: customers.name }).from(customers)
	).limit(10);
    ```
    ```sql
    (select `name` from `sellers`)
    union
    (select `name` from `customers`)
    limit ?
    ```
	</CodeTab>
    <CodeTab>
    ```ts copy
    import { users, customers } from './schema'

    const result = await db
      .select({ name: users.name })
      .from(users)
      .union(db.select({ name: customers.name }).from(customers))
      .limit(10);
    ```
    ```sql
    (select `name` from `sellers`)
    union
    (select `name` from `customers`)
    limit ?
    ```
    </CodeTab>
    <CodeTab>
	```typescript copy
    import { int, mysqlTable, text, varchar } from "drizzle-orm/mysql-core";

    const users = mysqlTable('sellers', {
        id: int('id').primaryKey(),
        name: varchar('name', { length: 256 }).notNull(),
        address: text('address'),
    });
    
    const customers = mysqlTable('customers', {
        id: int('id').primaryKey(),
        name: varchar('name', { length: 256 }).notNull(),
        city: text('city'),
        email: varchar('email', { length: 256 }).notNull()
    });
    ```
    </CodeTab>
  </CodeTabs>
  </Tab> 
  <Tab>
  <CodeTabs items={["import-pattern", "builder-pattern", "schema.ts"]}>
	<CodeTab>
	```typescript copy
    import { union } from 'drizzle-orm/sqlite-core'
    import { users, customers } from './schema'

    const allNamesForUserQuery = db.select({ name: users.name }).from(users);

    const result = await union(
		allNamesForUserQuery,
		db.select({ name: customers.name }).from(customers)
	).limit(10);
    ```
    ```sql
    (select "name" from "sellers")
    union 
    (select "name" from "customers")
    limit ?
    ```
	</CodeTab>
    <CodeTab>
    ```ts copy
    import { users, customers } from './schema'

    const result = await db
      .select({ name: users.name })
      .from(users)
      .union(db.select({ name: customers.name }).from(customers))
      .limit(10);
    ```
    ```sql
    select "name" from "sellers" union select "name" from "customers" limit ?
    ```
    </CodeTab>
    <CodeTab>
	```typescript copy
    import { int, sqliteTable, text } from "drizzle-orm/sqlite-core";

    const users = sqliteTable('sellers', {
        id: int('id').primaryKey(),
        name: text('name').notNull(),
        address: text('address'),
    });
    
    const customers = sqliteTable('customers', {
        id: int('id').primaryKey(),
        name: text('name').notNull(),
        city: text('city'),
        email: text('email').notNull()
    });
    ```
    </CodeTab>
  </CodeTabs>
  </Tab> 
  <Tab>
  <CodeTabs items={["import-pattern", "builder-pattern", "schema.ts"]}>
	<CodeTab>
	```typescript copy
    import { union } from 'drizzle-orm/singlestore-core'
    import { users, customers } from './schema'

    const allNamesForUserQuery = db.select({ name: users.name }).from(users);

    const result = await union(
		allNamesForUserQuery,
		db.select({ name: customers.name }).from(customers)
	).limit(10);
    ```
    ```sql
    (select `name` from `sellers`)
    union
    (select `name` from `customers`)
    limit ?
    ```
	</CodeTab>
    <CodeTab>
    ```ts copy
    import { users, customers } from './schema'

    const result = await db
      .select({ name: users.name })
      .from(users)
      .union(db.select({ name: customers.name }).from(customers))
      .limit(10);
    ```
    ```sql
    (select `name` from `sellers`)
    union
    (select `name` from `customers`)
    limit ?
    ```
    </CodeTab>
    <CodeTab>
	```typescript copy
    import { int, mysqlTable, text, varchar } from "drizzle-orm/singlestore-core";

    const users = mysqlTable('sellers', {
        id: int('id').primaryKey(),
        name: varchar('name', { length: 256 }).notNull(),
        address: text('address'),
    });
    
    const customers = mysqlTable('customers', {
        id: int('id').primaryKey(),
        name: varchar('name', { length: 256 }).notNull(),
        city: text('city'),
        email: varchar('email', { length: 256 }).notNull()
    });
    ```
    </CodeTab>
  </CodeTabs>
  </Tab> 
</Tabs>

### 并集所有（Union All）
将两个查询块的所有结果组合成单个结果，包括重复项。

考虑一个场景，你有两个表，一个表示在线销售，
另一个表示门店销售。在这种情况下，你想把两个表的数据结合成一个结果集。
由于可能会有重复的交易，
你希望保留所有记录，而不消除重复项。

<Tabs items={["PostgreSQL", "MySQL", "SQLite", "SingleStore"]}>
  <Tab>
  <CodeTabs items={["import-pattern", "builder-pattern", "schema.ts"]}>
	<CodeTab>
	```typescript copy
    import { unionAll } from 'drizzle-orm/pg-core'
    import { onlineSales, inStoreSales } from './schema'

    const onlineTransactions = db.select({ transaction: onlineSales.transactionId }).from(onlineSales);
    const inStoreTransactions = db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales);

    const result = await unionAll(onlineTransactions, inStoreTransactions);
    ```
    ```sql
    select "transaction_id" from "online_sales"
    union all
    select "transaction_id" from "in_store_sales"
    ```
    </CodeTab>
    <CodeTab>
    ```ts copy
    import { onlineSales, inStoreSales } from './schema'

    const result = await db
      .select({ transaction: onlineSales.transactionId })
      .from(onlineSales)
      .unionAll(
        db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
      );
    ```
    ```sql
    select "transaction_id" from "online_sales"
    union all
    select "transaction_id" from "in_store_sales"
    ```
	</CodeTab>
    <CodeTab>
	```typescript copy
    import { integer, pgTable, text, timestamp, varchar } from "drizzle-orm/pg-core";

    const onlineSales = pgTable('online_sales', {
        transactionId: integer('transaction_id').primaryKey(),
        productId: integer('product_id').unique(),
        quantitySold: integer('quantity_sold'),
        saleDate: timestamp('sale_date', { mode: 'date' }),
    });
    
    const inStoreSales = pgTable('in_store_sales', {
        transactionId: integer('transaction_id').primaryKey(),
        productId: integer('product_id').unique(),
        quantitySold: integer('quantity_sold'),
        saleDate: timestamp('sale_date', { mode: 'date' }),
    });
    ```
    </CodeTab>
  </CodeTabs>
  </Tab> 
<Tab>
  <CodeTabs items={["import-pattern", "builder-pattern", "schema.ts"]}>
	<CodeTab>
	```typescript copy
    import { unionAll } from 'drizzle-orm/mysql-core'
    import { onlineSales, inStoreSales } from './schema'

    const onlineTransactions = db.select({ transaction: onlineSales.transactionId }).from(onlineSales);
    const inStoreTransactions = db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales);

    const result = await unionAll(onlineTransactions, inStoreTransactions);
    ```
    ```sql
    select `transaction_id` from `online_sales`
    union all
    select `transaction_id` from `in_store_sales`
    ```
    </CodeTab>
    <CodeTab>
    ```ts copy
    import { onlineSales, inStoreSales } from './schema'

    const result = await db
      .select({ transaction: onlineSales.transactionId })
      .from(onlineSales)
      .unionAll(
        db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
      );
    ```
    ```sql
    (select `transaction_id` from `online_sales`)
    union all 
    (select `transaction_id` from `in_store_sales`)
    ```
	</CodeTab>
    <CodeTab>
	```typescript copy
    import { int, mysqlTable, text, timestamp, varchar } from "drizzle-orm/mysql-core";

    const onlineSales = mysqlTable('online_sales', {
        transactionId: int('transaction_id').primaryKey(),
        productId: int('product_id').unique(),
        quantitySold: int('quantity_sold'),
        saleDate: timestamp('sale_date', { mode: 'date' }),
    });
    
    const inStoreSales = mysqlTable('in_store_sales', {
        transactionId: int('transaction_id').primaryKey(),
        productId: int('product_id').unique(),
        quantitySold: int('quantity_sold'),
        saleDate: timestamp('sale_date', { mode: 'date' }),
    });
    ```
    </CodeTab>
  </CodeTabs>
  </Tab> 
  <Tab>
  <CodeTabs items={["import-pattern", "builder-pattern", "schema.ts"]}>
	<CodeTab>
	```typescript copy
    import { unionAll } from 'drizzle-orm/sqlite-core'
    import { onlineSales, inStoreSales } from './schema'

    const onlineTransactions = db.select({ transaction: onlineSales.transactionId }).from(onlineSales);
    const inStoreTransactions = db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales);

    const result = await unionAll(onlineTransactions, inStoreTransactions);
    ```
    ```sql
    select "transaction_id" from "online_sales" 
    union all 
    select "transaction_id" from "in_store_sales"
    ```
	</CodeTab>
    <CodeTab>
    ```ts copy
    import { onlineSales, inStoreSales } from './schema'

    const result = await db
      .select({ transaction: onlineSales.transactionId })
      .from(onlineSales)
      .unionAll(
        db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
      );
    ```
    ```sql
    select "transaction_id" from "online_sales" 
    union all 
    select "transaction_id" from "in_store_sales"
    ```
	</CodeTab>
    <CodeTab>
	```typescript copy
    import { int, sqliteTable } from "drizzle-orm/sqlite-core";

    const onlineSales = sqliteTable('online_sales', {
        transactionId: int('transaction_id').primaryKey(),
        productId: int('product_id').unique(),
        quantitySold: int('quantity_sold'),
        saleDate: int('sale_date', { mode: 'timestamp' }),
    });
    
    const inStoreSales = sqliteTable('in_store_sales', {
        transactionId: int('transaction_id').primaryKey(),
        productId: int('product_id').unique(),
        quantitySold: int('quantity_sold'),
        saleDate: int('sale_date', { mode: 'timestamp' }),
    });
    ```
    </CodeTab>
  </CodeTabs>
  </Tab> 
  <Tab>
  <Callout type='warning'>
  UNION ALL with ORDER BY behavior inconsistent with MySQL: SingleStore parses UNION ALL followed by ORDER BY commands differently from MySQL. In SingleStore, the following query is valid. In MySQL, it is invalid.
  </Callout>
  <CodeTabs items={["import-pattern", "builder-pattern", "schema.ts"]}>
	<CodeTab>
	```typescript copy
    import { unionAll } from 'drizzle-orm/singlestore-core'
    import { onlineSales, inStoreSales } from './schema'

    const onlineTransactions = db.select({ transaction: onlineSales.transactionId }).from(onlineSales);
    const inStoreTransactions = db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales);

    const result = await unionAll(onlineTransactions, inStoreTransactions);
    ```
    ```sql
    select `transaction_id` from `online_sales`
    union all
    select `transaction_id` from `in_store_sales`
    ```
    </CodeTab>
    <CodeTab>
    ```ts copy
    import { onlineSales, inStoreSales } from './schema'

    const result = await db
      .select({ transaction: onlineSales.transactionId })
      .from(onlineSales)
      .unionAll(
        db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
      );
    ```
    ```sql
    (select `transaction_id` from `online_sales`)
    union all 
    (select `transaction_id` from `in_store_sales`)
    ```
	</CodeTab>
    <CodeTab>
	```typescript copy
    import { int, mysqlTable, text, timestamp, varchar } from "drizzle-orm/singlestore-core";

    const onlineSales = mysqlTable('online_sales', {
        transactionId: int('transaction_id').primaryKey(),
        productId: int('product_id').unique(),
        quantitySold: int('quantity_sold'),
        saleDate: timestamp('sale_date', { mode: 'date' }),
    });
    
    const inStoreSales = mysqlTable('in_store_sales', {
        transactionId: int('transaction_id').primaryKey(),
        productId: int('product_id').unique(),
        quantitySold: int('quantity_sold'),
        saleDate: timestamp('sale_date', { mode: 'date' }),
    });
    ```
    </CodeTab>
  </CodeTabs>
  </Tab> 
</Tabs>

### 交集（Intersect）
仅结合两个查询块的结果中共通的行，省略任何重复项。

假设你有两个表存储有关学生课程注册的信息。
你想找到两个不同系间共同的课程，
但你希望课程名是唯一的，
并且不想计算同一个学生在同一课程下的多个注册。

在此场景中，你希望找到两个系间的共同课程，
但不希望同一课程即使被同一系的多个学生注册也计数多次。

<Tabs items={["PostgreSQL", "MySQL", "SQLite", "SingleStore"]}>
  <Tab>
  <CodeTabs items={["import-pattern", "builder-pattern", "schema.ts"]}>
	<CodeTab>
	```typescript copy
    import { intersect } from 'drizzle-orm/pg-core'
    import { depA, depB } from './schema'

    const departmentACourses = db.select({ courseName: depA.courseName }).from(depA);
    const departmentBCourses = db.select({ courseName: depB.courseName }).from(depB);

    const result = await intersect(departmentACourses, departmentBCourses);
    ```
    ```sql
    select "course_name" from "department_a_courses"
    intersect
    select "course_name" from "department_b_courses"
    ```
	</CodeTab>
    <CodeTab>
    ```typescript copy
    import { depA, depB } from './schema'

    const result = await db
      .select({ courseName: depA.courseName })
      .from(depA)
      .intersect(db.select({ courseName: depB.courseName }).from(depB));
    ```
    ```sql
    select "course_name" from "department_a_courses"
    intersect
    select "course_name" from "department_b_courses"
    ```
    </CodeTab>
    <CodeTab>
	```typescript copy
    import { integer, pgTable, varchar } from "drizzle-orm/pg-core";

    const depA = pgTable('department_a_courses', {
        studentId: integer('student_id'),
        courseName: varchar('course_name').notNull(),
    });
    
    const depB = pgTable('department_b_courses', {
        studentId: integer('student_id'),
        courseName: varchar('course_name').notNull(),
    });
    ```
    </CodeTab>
  </CodeTabs>
  </Tab> 
  <Tab>
    <CodeTabs items={["import-pattern", "builder-pattern", "schema.ts"]}>
	<CodeTab>
	```typescript copy
    import { intersect } from 'drizzle-orm/mysql-core'
    import { depA, depB } from './schema'

    const departmentACourses = db.select({ courseName: depA.courseName }).from(depA);
    const departmentBCourses = db.select({ courseName: depB.courseName }).from(depB);

    const result = await intersect(departmentACourses, departmentBCourses);
    ```
    ```sql
    select `projects_name` from `department_a_projects`
    intersect
    select `projects_name` from `department_b_projects`
    ```
	</CodeTab>
    <CodeTab>
    ```typescript copy
    import { depA, depB } from './schema'

    const result = await db
      .select({ courseName: depA.courseName })
      .from(depA)
      .intersect(db.select({ courseName: depB.courseName }).from(depB));
    ```
    ```sql
    select `projects_name` from `department_a_projects`
    intersect
    select `projects_name` from `department_b_projects`
    ```
    </CodeTab>
    <CodeTab>
	```typescript copy
    import { int, mysqlTable, varchar } from "drizzle-orm/mysql-core";

    const depA = mysqlTable('department_a_courses', {
        studentId: int('student_id'),
        courseName: varchar('course_name', { length: 256 }).notNull(),
    });
    
    const depB = pgTable('department_b_courses', {
        studentId: int('student_id'),
        courseName: varchar('course_name', { length: 256 }).notNull(),
    });
    ```
    </CodeTab>
  </CodeTabs>
  </Tab> 
  <Tab>
      <CodeTabs items={["import-pattern", "builder-pattern", "schema.ts"]}>
	<CodeTab>
	```typescript copy
    import { intersect } from 'drizzle-orm/sqlite-core'
    import { depA, depB } from './schema'

    const departmentACourses = db.select({ courseName: depA.courseName }).from(depA);
    const departmentBCourses = db.select({ courseName: depB.courseName }).from(depB);

    const result = await intersect(departmentACourses, departmentBCourses);
    ```
    ```sql
    select "course_name" from "department_a_courses"
    intersect
    select "course_name" from "department_b_courses"
    ```
	</CodeTab>
    <CodeTab>
    ```typescript copy
    import { depA, depB } from './schema'

    const result = await db
      .select({ courseName: depA.courseName })
      .from(depA)
      .intersect(db.select({ courseName: depB.courseName }).from(depB));
    ```
    ```sql
    select "course_name" from "department_a_courses" 
    intersect 
    select "course_name" from "department_b_courses"
    ```
    </CodeTab>
    <CodeTab>
	```typescript copy
    import { int, sqliteTable, text } from "drizzle-orm/sqlite-core";

    const depA = sqliteTable('department_a_courses', {
        studentId: int('student_id'),
        courseName: text('course_name').notNull(),
    });
    
    const depB = sqliteTable('department_b_courses', {
        studentId: int('student_id'),
        courseName: text('course_name').notNull(),
    });
    ```
    </CodeTab>
  </CodeTabs>
  </Tab> 
  <Tab>
    <CodeTabs items={["import-pattern", "builder-pattern", "schema.ts"]}>
	<CodeTab>
	```typescript copy
    import { intersect } from 'drizzle-orm/singlestore-core'
    import { depA, depB } from './schema'

    const departmentACourses = db.select({ courseName: depA.courseName }).from(depA);
    const departmentBCourses = db.select({ courseName: depB.courseName }).from(depB);

    const result = await intersect(departmentACourses, departmentBCourses);
    ```
    ```sql
    select `projects_name` from `department_a_projects`
    intersect
    select `projects_name` from `department_b_projects`
    ```
	</CodeTab>
    <CodeTab>
    ```typescript copy
    import { depA, depB } from './schema'

    const result = await db
      .select({ courseName: depA.courseName })
      .from(depA)
      .intersect(db.select({ courseName: depB.courseName }).from(depB));
    ```
    ```sql
    select `projects_name` from `department_a_projects`
    intersect
    select `projects_name` from `department_b_projects`
    ```
    </CodeTab>
    <CodeTab>
	```typescript copy
    import { int, mysqlTable, varchar } from "drizzle-orm/singlestore-core";

    const depA = mysqlTable('department_a_courses', {
        studentId: int('student_id'),
        courseName: varchar('course_name', { length: 256 }).notNull(),
    });
    
    const depB = pgTable('department_b_courses', {
        studentId: int('student_id'),
        courseName: varchar('course_name', { length: 256 }).notNull(),
    });
    ```
    </CodeTab>
  </CodeTabs>
  </Tab> 
</Tabs>

### 交集所有（Intersect All）
仅结合两个查询块的结果中共通的行，包括重复项。

让我们考虑一个场景，你有两个表包含有关客户订单的数据，
你想识别普通客户和 VIP 客户都订单的产品。
在这种情况下，你想更好地跟踪每种产品的数量，
即使不同客户多次下单。

在此场景中，你希望找到普通客户和 VIP 客户都下单的产品，
但你希望保留数量信息，
即使同一产品被不同的客户多次下单。

<Tabs items={["PostgreSQL", "MySQL", "SingleStore"]}>
  <Tab>
  <CodeTabs items={["import-pattern", "builder-pattern", "schema.ts"]}>
	<CodeTab>
	```typescript copy
    import { intersectAll } from 'drizzle-orm/pg-core'
    import { regularCustomerOrders, vipCustomerOrders } from './schema'

    const regularOrders = db.select({ 
        productId: regularCustomerOrders.productId,
        quantityOrdered: regularCustomerOrders.quantityOrdered }
    ).from(regularCustomerOrders);

    const vipOrders = db.select({ 
        productId: vipCustomerOrders.productId,
        quantityOrdered: vipCustomerOrders.quantityOrdered }
    ).from(vipCustomerOrders);

    const result = await intersectAll(regularOrders, vipOrders);
    ```
    ```sql
    select "product_id", "quantity_ordered" from "regular_customer_orders"
    intersect all
    select "product_id", "quantity_ordered" from "vip_customer_orders"
    ```
	</CodeTab>
    ```ts copy
    import { regularCustomerOrders, vipCustomerOrders } from './schema'

    const result = await db
        .select({
          productId: regularCustomerOrders.productId,
          quantityOrdered: regularCustomerOrders.quantityOrdered,
        })
        .from(regularCustomerOrders)
        .intersectAll(
          db
            .select({
              productId: vipCustomerOrders.productId,
              quantityOrdered: vipCustomerOrders.quantityOrdered,
            })
            .from(vipCustomerOrders)
        );
    ```
    ```sql
    select "product_id", "quantity_ordered" from "regular_customer_orders"
    intersect all
    select "product_id", "quantity_ordered" from "vip_customer_orders"
    ```
    <CodeTab>
	```typescript copy
    import { integer, pgTable } from "drizzle-orm/pg-core";

    const regularCustomerOrders = pgTable('regular_customer_orders', {
        customerId: integer('customer_id').primaryKey(),
        productId: integer('product_id').notNull(),
        quantityOrdered: integer('quantity_ordered').notNull(),
    });
    
    const vipCustomerOrders = pgTable('vip_customer_orders', {
        customerId: integer('customer_id').primaryKey(),
        productId: integer('product_id').notNull(),
        quantityOrdered: integer('quantity_ordered').notNull(),
    });
    ```
    </CodeTab>
  </CodeTabs>
  </Tab> 
  <Tab>
  <CodeTabs items={["import-pattern", "builder-pattern", "schema.ts"]}>
	<CodeTab>
	```typescript copy
    import { intersectAll } from 'drizzle-orm/mysql-core'
    import { regularCustomerOrders, vipCustomerOrders } from './schema'

    const regularOrders = db.select({ 
        productId: regularCustomerOrders.productId,
        quantityOrdered: regularCustomerOrders.quantityOrdered }
    ).from(regularCustomerOrders);

    const vipOrders = db.select({ 
        productId: vipCustomerOrders.productId,
        quantityOrdered: vipCustomerOrders.quantityOrdered }
    ).from(vipCustomerOrders);

    const result = await intersectAll(regularOrders, vipOrders);
    ```
    ```sql
    select `product_id`, `quantity_ordered` from `regular_customer_orders`
    intersect all
    select `product_id`, `quantity_ordered` from `vip_customer_orders`
    ```
	</CodeTab>
    <CodeTab>
    ```ts copy
    import { regularCustomerOrders, vipCustomerOrders } from './schema'
 
    const result = await db
        .select({
          productId: regularCustomerOrders.productId,
          quantityOrdered: regularCustomerOrders.quantityOrdered,
        })
        .from(regularCustomerOrders)
        .intersectAll(
          db
            .select({
              productId: vipCustomerOrders.productId,
              quantityOrdered: vipCustomerOrders.quantityOrdered,
            })
            .from(vipCustomerOrders)
        );
    ```
    ```sql
    select `product_id`, `quantity_ordered` from `regular_customer_orders`
    intersect all
    select `product_id`, `quantity_ordered` from `vip_customer_orders`
    ```
    </CodeTab>
	<CodeTab>
	```typescript copy
    import { int, mysqlTable } from "drizzle-orm/mysql-core";

    const regularCustomerOrders = mysqlTable('regular_customer_orders', {
        customerId: int('customer_id').primaryKey(),
        productId: int('product_id').notNull(),
        quantityOrdered: int('quantity_ordered').notNull(),
    });
    
    const vipCustomerOrders = mysqlTable('vip_customer_orders', {
        customerId: int('customer_id').primaryKey(),
        productId: int('product_id').notNull(),
        quantityOrdered: int('quantity_ordered').notNull(),
    });
    ```
    </CodeTab>
  </CodeTabs>
  </Tab>
  <Tab>
  Not supported by SingleStore
  </Tab> 
</Tabs>

### 差集（Except）
对于两个查询块 A 和 B，返回不在 B 中的 A 的所有结果，省略任何重复项。

假设你有两个表存储有关员工项目分配的信息。
你想找到唯一属于一个部门并且不与另一个部门共享的项目，
排除重复项。

在此场景中，你想识别唯一属于一个部门而不与另一个部门共享的项目。
你不希望同一项目计数多次，
即使同一部门的多个员工都被分配给该项目。

<Tabs items={["PostgreSQL", "MySQL", "SQLite", "SingleStore"]}>
  <Tab>
  <CodeTabs items={["import-pattern", "builder-pattern", "schema.ts"]}>
	<CodeTab>
	```typescript copy
    import { except } from 'drizzle-orm/pg-core'
    import { depA, depB } from './schema'

    const departmentACourses = db.select({ courseName: depA.projectsName }).from(depA);
    const departmentBCourses = db.select({ courseName: depB.projectsName }).from(depB);

    const result = await except(departmentACourses, departmentBCourses);
    ```
    ```sql
    select "projects_name" from "department_a_projects"
    except
    select "projects_name" from "department_b_projects"
    ```
	</CodeTab>
    <CodeTab>
    ```ts copy
    import { depA, depB } from './schema'

    const result = await db
        .select({ courseName: depA.projectsName })
        .from(depA)
        .except(db.select({ courseName: depB.projectsName }).from(depB));
    ```
    ```sql
    select "projects_name" from "department_a_projects"
    except
    select "projects_name" from "department_b_projects"
    ```
    </CodeTab>
    <CodeTab>
	```typescript copy
    import { integer, pgTable, varchar } from "drizzle-orm/pg-core";

    const depA = pgTable('department_a_projects', {
        employeeId: integer('employee_id'),
        projectsName: varchar('projects_name').notNull(),
    });
    
    const depB = pgTable('department_b_projects', {
        employeeId: integer('employee_id'),
        projectsName: varchar('projects_name').notNull(),
    });
    ```
    </CodeTab>
  </CodeTabs>
  </Tab> 
  <Tab>
  <CodeTabs items={["import-pattern", "builder-pattern", "schema.ts"]}>
	<CodeTab>
	```typescript copy
    import { except } from 'drizzle-orm/mysql-core'
    import { depA, depB } from './schema'

    const departmentACourses = db.select({ courseName: depA.projectsName }).from(depA);
    const departmentBCourses = db.select({ courseName: depB.projectsName }).from(depB);

    const result = await except(departmentACourses, departmentBCourses);
    ```
    ```sql
    select `projects_name` from `department_a_projects`
    except
    select `projects_name` from `department_b_projects`
    ```
	</CodeTab>
    <CodeTab>
    ```ts copy
    import { depA, depB } from './schema'

    const result = await db
        .select({ courseName: depA.projectsName })
        .from(depA)
        .except(db.select({ courseName: depB.projectsName }).from(depB));
    ```
    ```sql
    select `projects_name` from `department_a_projects`
    except
    select `projects_name` from `department_b_projects`
    ```
    </CodeTab>
    <CodeTab>
	```typescript 
    import { int, mysqlTable, varchar } from "drizzle-orm/mysql-core";

    const depA = mysqlTable('department_a_projects', {
        employeeId: int('employee_id'),
        projectsName: varchar('projects_name', { length: 256 }).notNull(),
    });
    
    const depB = mysqlTable('department_b_projects', {
        employeeId: int('employee_id'),
        projectsName: varchar('projects_name', { length: 256 }).notNull(),
    });
    ```
    </CodeTab>
  </CodeTabs>
  </Tab> 
  <Tab>
  <CodeTabs items={["import-pattern", "builder-pattern", "schema.ts"]}>
	<CodeTab>
	```typescript copy
    import { except } from 'drizzle-orm/sqlite-core'
    import { depA, depB } from './schema'

    const departmentACourses = db.select({ courseName: depA.projectsName }).from(depA);
    const departmentBCourses = db.select({ courseName: depB.projectsName }).from(depB);

    const result = await except(departmentACourses, departmentBCourses);
    ```
    ```sql
    select "projects_name" from "department_a_projects" 
    except 
    select "projects_name" from "department_b_projects"
    ```
	</CodeTab>
    <CodeTab>
    ```ts copy
    import { depA, depB } from './schema'

    const result = await db
        .select({ courseName: depA.projectsName })
        .from(depA)
        .except(db.select({ courseName: depB.projectsName }).from(depB));
    ```
    ```sql
    select "projects_name" from "department_a_projects" 
    except 
    select "projects_name" from "department_b_projects"
    ```
    </CodeTab>
    <CodeTab>
	```typescript copy
    import { int, sqliteTable, text } from "drizzle-orm/sqlite-core";

    const depA = sqliteTable('department_a_projects', {
        employeeId: int('employee_id'),
        projectsName: text('projects_name').notNull(),
    });
    
    const depB = sqliteTable('department_b_projects', {
        employeeId: int('employee_id'),
        projectsName: text('projects_name').notNull(),
    });
    ```
    </CodeTab>
  </CodeTabs>
  </Tab> 
  <Tab>
  <CodeTabs items={["import-pattern", "builder-pattern", "schema.ts"]}>
	<CodeTab>
	```typescript copy
    import { except } from 'drizzle-orm/singlestore-core'
    import { depA, depB } from './schema'

    const departmentACourses = db.select({ courseName: depA.projectsName }).from(depA);
    const departmentBCourses = db.select({ courseName: depB.projectsName }).from(depB);

    const result = await except(departmentACourses, departmentBCourses);
    ```
    ```sql
    select `projects_name` from `department_a_projects`
    except
    select `projects_name` from `department_b_projects`
    ```
	</CodeTab>
    <CodeTab>
    ```ts copy
    import { depA, depB } from './schema'

    const result = await db
        .select({ courseName: depA.projectsName })
        .from(depA)
        .except(db.select({ courseName: depB.projectsName }).from(depB));
    ```
    ```sql
    select `projects_name` from `department_a_projects`
    except
    select `projects_name` from `department_b_projects`
    ```
    </CodeTab>
    <CodeTab>
	```typescript 
    import { int, mysqlTable, varchar } from "drizzle-orm/singlestore-core";

    const depA = mysqlTable('department_a_projects', {
        employeeId: int('employee_id'),
        projectsName: varchar('projects_name', { length: 256 }).notNull(),
    });
    
    const depB = mysqlTable('department_b_projects', {
        employeeId: int('employee_id'),
        projectsName: varchar('projects_name', { length: 256 }).notNull(),
    });
    ```
    </CodeTab>
  </CodeTabs>
  </Tab> 
</Tabs>

### 差集所有（Except All）
对于两个查询块 A 和 B，返回不在 B 中的 A 的所有结果，包括重复项。

让我们考虑一个场景，你有两个表包含有关客户订单的数据，
你想识别仅普通客户（没有 VIP 客户）下单的产品。
在这种情况下，你希望保留每种产品的数量信息，即使不同的普通客户多次下单。

在此场景中，你希望找到仅由普通客户下单的产品，并且不由 VIP 客户下单。
你希望保留数量信息，即使同一产品被不同的普通客户多次下单。

<Tabs items={["PostgreSQL", "MySQL", "SingleStore"]}>
  <Tab>
  <CodeTabs items={["import-pattern", "builder-pattern", "schema.ts"]}>
	<CodeTab>
	```typescript copy
    import { exceptAll } from 'drizzle-orm/pg-core'
    import { regularCustomerOrders, vipCustomerOrders } from './schema'

    const regularOrders = db.select({ 
        productId: regularCustomerOrders.productId,
        quantityOrdered: regularCustomerOrders.quantityOrdered }
    ).from(regularCustomerOrders);

    const vipOrders = db.select({ 
        productId: vipCustomerOrders.productId,
        quantityOrdered: vipCustomerOrders.quantityOrdered }
    ).from(vipCustomerOrders);

    const result = await exceptAll(regularOrders, vipOrders);
    ```
    ```sql
    select "product_id", "quantity_ordered" from "regular_customer_orders"
    except all
    select "product_id", "quantity_ordered" from "vip_customer_orders"
    ```
	</CodeTab>
    <CodeTab>
    ```ts copy
    import { regularCustomerOrders, vipCustomerOrders } from './schema'
 
    const result = await db
        .select({
          productId: regularCustomerOrders.productId,
          quantityOrdered: regularCustomerOrders.quantityOrdered,
        })
        .from(regularCustomerOrders)
        .exceptAll(
          db
            .select({
              productId: vipCustomerOrders.productId,
              quantityOrdered: vipCustomerOrders.quantityOrdered,
            })
            .from(vipCustomerOrders)
        );
    ```
    ```sql
    select "product_id", "quantity_ordered" from "regular_customer_orders"
    except all
    select "product_id", "quantity_ordered" from "vip_customer_orders"
    ```
    </CodeTab>
	<CodeTab>
	```typescript copy
    import { integer, pgTable } from "drizzle-orm/pg-core";

    const regularCustomerOrders = pgTable('regular_customer_orders', {
        customerId: integer('customer_id').primaryKey(),
        productId: integer('product_id').notNull(),
        quantityOrdered: integer('quantity_ordered').notNull(),
    });
    
    const vipCustomerOrders = pgTable('vip_customer_orders', {
        customerId: integer('customer_id').primaryKey(),
        productId: integer('product_id').notNull(),
        quantityOrdered: integer('quantity_ordered').notNull(),
    });
    ```
    </CodeTab>
  </CodeTabs>
  </Tab> 
  <Tab>
  <CodeTabs items={["import-pattern", "builder-pattern", "schema.ts"]}>
	<CodeTab>
	```typescript copy
    import { exceptAll } from 'drizzle-orm/mysql-core'
    import { regularCustomerOrders, vipCustomerOrders } from './schema'

    const regularOrders = db.select({ 
        productId: regularCustomerOrders.productId,
        quantityOrdered: regularCustomerOrders.quantityOrdered }
    ).from(regularCustomerOrders);

    const vipOrders = db.select({ 
        productId: vipCustomerOrders.productId,
        quantityOrdered: vipCustomerOrders.quantityOrdered }
    ).from(vipCustomerOrders);

    const result = await exceptAll(regularOrders, vipOrders);
    ```
    ```sql
    select `product_id`, `quantity_ordered` from `regular_customer_orders`
    except all
    select `product_id`, `quantity_ordered` from `vip_customer_orders`
    ```
	</CodeTab>
    <CodeTab>
    ```ts copy
    import { regularCustomerOrders, vipCustomerOrders } from './schema'
 
    const result = await db
        .select({
          productId: regularCustomerOrders.productId,
          quantityOrdered: regularCustomerOrders.quantityOrdered,
        })
        .from(regularCustomerOrders)
        .exceptAll(
          db
            .select({
              productId: vipCustomerOrders.productId,
              quantityOrdered: vipCustomerOrders.quantityOrdered,
            })
            .from(vipCustomerOrders)
        );
    ```
    ```sql
    select `product_id`, `quantity_ordered` from `regular_customer_orders`
    except all
    select `product_id`, `quantity_ordered` from `vip_customer_orders`
    ```
    </CodeTab>
	<CodeTab>
	```typescript copy
    const regularCustomerOrders = mysqlTable('regular_customer_orders', {
        customerId: int('customer_id').primaryKey(),
        productId: int('product_id').notNull(),
        quantityOrdered: int('quantity_ordered').notNull(),
    });
    
    const vipCustomerOrders = mysqlTable('vip_customer_orders', {
        customerId: int('customer_id').primaryKey(),
        productId: int('product_id').notNull(),
        quantityOrdered: int('quantity_ordered').notNull(),
    });
    ```
    </CodeTab>
  </CodeTabs>
  </Tab> 
  <Tab>
  Not supported by SingleStore
  </Tab>
</Tabs>


Source: https://drizzle.zhcndoc.com/docs/sql-schema-declaration

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import Callout from '@mdx/Callout.astro';
import SimpleLinkCards from '@mdx/SimpleLinkCards.astro';
import CodeTabs from "@mdx/CodeTabs.astro";
import Section from '@mdx/Section.astro';
import Flex from "@mdx/Flex.astro"
import LinksList from "@mdx/LinksList.astro"

# Drizzle 模式

Drizzle 允许您使用 TypeScript 定义模式，支持底层数据库的各种模型和属性。
当您定义模式时，它将作为未来查询（使用 Drizzle-ORM）和迁移（使用 Drizzle-Kit）
修改的真实性源。

<Callout> 
如果您使用 Drizzle-Kit 进行迁移过程，请确保从您模式文件中导出所有定义的模型，以便 Drizzle-Kit 可以导入它们并在迁移差异过程中使用。
</Callout>

## 组织您的模式文件
您可以将 SQL 模式直接在 TypeScript 中声明，或者将所有内容放在一个 `schema.ts` 文件中，
或者您可以分散它们——随您所愿，完全没有限制！

#### 单文件中的模式
使用 Drizzle 声明模式的最常见方法是将所有表放在一个 `schema.ts` 文件中。

> 注意：您可以将模式文件命名为您喜欢的任何名称。例如，可以是 `models.ts` 或其他名称。

如果您没有定义太多表模型，或者您认为将它们放在一个文件中没有问题，这种方法效果很好。

示例：
```plaintext
📦 <项目根目录>
 └ 📂 src
    └ 📂 db
       └ 📜 schema.ts
```

在 `drizzle.config.ts` 文件中，您需要指定模式文件的路径。
通过此配置，Drizzle 将从 `schema.ts` 文件读取并在迁移生成过程中使用此信息。
有关 `drizzle.config.ts` 文件和使用 Drizzle 进行迁移的更多信息，请查看：[链接](/docs/drizzle-config-file)
```ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: 'postgresql', // 'mysql' | 'sqlite' | 'turso'
  schema: './src/db/schema.ts'
})
```

#### 多文件中的模式

您可以将 Drizzle 模型（例如表、枚举、序列等）放置在一个文件中，也可以放在任何您想要的文件中。 
您需要确保从这些文件中导出所有模型，
以便 Drizzle kit 可以导入并在迁移中使用它们。

一个常见的用例是将每个表分开到自己的文件中。
```plaintext
📦 <项目根目录>
 └ 📂 src
    └ 📂 db
       └ 📂 schema
          ├ 📜 users.ts
          ├ 📜 countries.ts
          ├ 📜 cities.ts
          ├ 📜 products.ts
          ├ 📜 clients.ts
          └ 📜 etc.ts
```

在 `drizzle.config.ts` 文件中，您需要指定模式文件夹的路径。
通过此配置，Drizzle 将从 `schema` 文件夹读取并递归查找所有文件，并从中获取所有 drizzle 表。
有关 `drizzle.config.ts` 文件和使用 Drizzle 进行迁移的更多信息，请查看：[链接](/docs/drizzle-config-file)

```ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: 'postgresql', // 'mysql' | 'sqlite' | 'turso'
  schema: './src/db/schema'
})
```

您还可以以任何您喜欢的方式对它们进行分组，例如为用户相关表、消息相关表、产品相关表等创建组。
```plaintext
📦 <项目根目录>
 └ 📂 src
    └ 📂 db
       └ 📂 schema
          ├ 📜 users.ts
          ├ 📜 messaging.ts
          └ 📜 products.ts
```

## 塑造您的数据模式

Drizzle 模式由您正在使用的数据库中的几种模型类型构成。使用 Drizzle，您可以指定：
- 含有列、约束等的表。
- 模式（仅适用于 PostgreSQL）
- 枚举
- 序列（仅适用于 PostgreSQL）
- 视图
- 材料化视图
- 等等。

让我们逐个检查模式如何使用 Drizzle 定义。

#### **表和列声明**

在 Drizzle 中，表应至少定义 1 列，正如在数据库中应做的那样。有一件重要的事需要知道，
Drizzle 中没有通用的表对象。您需要选择使用的方言：PostgreSQL、MySQL 或 SQLite。

![](@/assets/images/table-structure.svg)

<CodeTabs items={["PostgreSQL 表", "MySQL 表", "SQLite 表"]}>
```ts copy
import { pgTable, integer } from "drizzle-orm/pg-core"

export const users = pgTable('users', {
  id: integer()
});
```
```ts copy
import { mysqlTable, int } from "drizzle-orm/mysql-core"

export const users = mysqlTable('users', {
  id: int()
});
```
```ts copy
import { sqliteTable, integer } from "drizzle-orm/sqlite-core"

export const users = sqliteTable('users', {
  id: integer()
});
```
</CodeTabs>

默认情况下，Drizzle 将在数据库查询中使用 TypeScript 键名作为列名。
因此，来自示例的模式和查询将生成如下 SQL 查询。

<Callout>
此示例使用一个 db 对象，但其初始化未在本部分文档中覆盖。要了解如何连接到数据库，请参阅 [连接文档](/docs/get-started-postgresql)
</Callout>

\
**TypeScript 键 = 数据库键**
<Section>
```ts
// schema.ts
import { integer, pgTable, varchar } from "drizzle-orm/pg-core";

export const users = pgTable('users', {
  id: integer(),
  first_name: varchar()
})
```
```ts
// query.ts
await db.select().from(users);
```
```sql
SELECT "id", "first_name" from users;
```
</Section>

如果您想在 TypeScript 代码中和数据库中使用不同的名称，您可以使用列别名。

<Section>
```ts
// schema.ts
import { integer, pgTable, varchar } from "drizzle-orm/pg-core";

export const users = pgTable('users', {
  id: integer(),
  firstName: varchar('first_name')
})
```
```ts
// query.ts
await db.select().from(users);
```
```sql
SELECT "id", "first_name" from users;
```
</Section>

### 驼峰和蛇形命名

数据库模型名称通常使用 `snake_case` 约定，而在 TypeScript 中，常用 `camelCase` 进行命名。
这可能会导致模式中有很多别名定义。为了解决这个问题，
Drizzle 提供了一种方法来自动将 TypeScript 中的 `camelCase` 映射到数据库中的 `snake_case`，通过在 Drizzle 数据库初始化时包含一个可选参数。

对于这种映射，您可以在 Drizzle DB 声明中使用 `casing` 选项。
此参数将帮助您指定数据库模型命名约定，并将尝试相应地映射所有 JavaScript 键。

<Section>
```ts
// schema.ts
import { drizzle } from "drizzle-orm/node-postgres";
import { integer, pgTable, varchar } from "drizzle-orm/pg-core";

export const users = pgTable('users', {
  id: integer(),
  firstName: varchar()
})
```
```ts
// db.ts
const db = drizzle({ connection: process.env.DATABASE_URL, casing: 'snake_case' })
```
```ts
// query.ts
await db.select().from(users);
```
```sql
SELECT "id", "first_name" from users;
```
</Section>

### 高级

使用 Drizzle ORM 您可以使用一些技巧。只要 Drizzle 完全在 TypeScript 文件中，
您就可以像在简单的 TypeScript 项目中一样进行任何编码。

一个常见的特性是将列分离到不同的位置，然后重复使用它们。
例如，考虑字段 `updated_at`、`created_at` 和 `deleted_at`。
许多表/模型可能需要这三个字段来跟踪和分析系统中实体的创建、删除和更新。

我们可以在一个单独的文件中定义这些列，然后在所有表对象中导入并展开它们。

<Section>
```ts
// columns.helpers.ts
const timestamps = {
  updated_at: timestamp(),
  created_at: timestamp().defaultNow().notNull(),
  deleted_at: timestamp(),
}
```
```ts
// users.sql.ts
export const users = pgTable('users', {
  id: integer(),
  ...timestamps
})
```
```ts
// posts.sql.ts
export const posts = pgTable('posts', {
  id: integer(),
  ...timestamps
})
```
</Section>

#### **模式**

<Tabs items={['PostgreSQL', 'MySQL', 'SQLite']}>
<Tab>
\
在 PostgreSQL 中，有一个实体称为 `schema`（我们认为应该称为 `folders`）。这在 PostgreSQL 中创建了一个结构：

![](@/assets/images/postgresql-db-structure.png)

您可以使用 `pgSchema` 管理 PostgreSQL 模式，并将任何其他模型放入其中。

使用 Drizzle 定义您想要管理的模式
```ts
import { pgSchema } from "drizzle-orm/pg-core"

export const customSchema = pgSchema('custom');
```

然后将表放入模式对象中
```ts {5-7}
import { integer, pgSchema } from "drizzle-orm/pg-core";

export const customSchema = pgSchema('custom');

export const users = customSchema.table('users', {
  id: integer()
})
```
</Tab>
<Tab>
\
在 MySQL 中，有一个实体称为 `Schema`，但在 MySQL 术语中，相当于 `Database`。

您可以使用 `drizzle-orm` 定义它们并在查询中使用，但它们不会被 `drizzle-kit` 检测到或包含在迁移流中。

![](@/assets/images/mysql-db-structure.png)

使用 Drizzle 定义您想要管理的模式
```ts
import { mysqlSchema } from "drizzle-orm/mysql-core"

export const customSchema = mysqlSchema('custom');
```

然后将表放入模式对象中
```ts {5-7}
import { int, mysqlSchema } from "drizzle-orm/mysql-core";

export const customSchema = mysqlSchema('custom');

export const users = customSchema.table('users', {
  id: int()
})
```
</Tab>
<Tab>
\
在 SQLite 中，没有模式的概念，因此您只能在单个 SQLite 文件上下文中定义表。

![](@/assets/images/sqlite-db-structure.png)
</Tab>
</Tabs>

### 示例

一旦您掌握了基础知识，让我们为一个实际项目定义一个模式示例，以获得更好的视图和理解。

> 所有示例将使用 `generateUniqueString`。其实现将在所有模式示例之后提供。

<CodeTabs items={['PostgreSQL', 'MySQL', 'SQLite']}>
```ts copy
import { AnyPgColumn } from "drizzle-orm/pg-core";
import { pgEnum, pgTable as table } from "drizzle-orm/pg-core";
import * as t from "drizzle-orm/pg-core";

export const rolesEnum = pgEnum("roles", ["guest", "user", "admin"]);

export const users = table(
  "users",
  {
    id: t.integer().primaryKey().generatedAlwaysAsIdentity(),
    firstName: t.varchar("first_name", { length: 256 }),
    lastName: t.varchar("last_name", { length: 256 }),
    email: t.varchar().notNull(),
    invitee: t.integer().references((): AnyPgColumn => users.id),
    role: rolesEnum().default("guest"),
  },
  (table) => [
    t.uniqueIndex("email_idx").on(table.email)
  ]
);

export const posts = table(
  "posts",
  {
    id: t.integer().primaryKey().generatedAlwaysAsIdentity(),
    slug: t.varchar().$default(() => generateUniqueString(16)),
    title: t.varchar({ length: 256 }),
    ownerId: t.integer("owner_id").references(() => users.id),
  },
  (table) => [
    t.uniqueIndex("slug_idx").on(table.slug),
    t.index("title_idx").on(table.title),
  ]
);

export const comments = table("comments", {
  id: t.integer().primaryKey().generatedAlwaysAsIdentity(),
  text: t.varchar({ length: 256 }),
  postId: t.integer("post_id").references(() => posts.id),
  ownerId: t.integer("owner_id").references(() => users.id),
});
```
```ts copy
import { mysqlTable as table } from "drizzle-orm/mysql-core";
import * as t from "drizzle-orm/mysql-core";
import { AnyMySqlColumn } from "drizzle-orm/mysql-core";

export const users = table(
  "users",
  {
    id: t.int().primaryKey().autoincrement(),
    firstName: t.varchar("first_name", { length: 256 }),
    lastName: t.varchar("last_name", { length: 256 }),
    email: t.varchar({ length: 256 }).notNull(),
    invitee: t.int().references((): AnyMySqlColumn => users.id),
    role: t.mysqlEnum(["guest", "user", "admin"]).default("guest"),
  },
  (table) => [
    t.uniqueIndex("email_idx").on(table.email)
  ]
);

export const posts = table(
  "posts",
  {
    id: t.int().primaryKey().autoincrement(),
    slug: t.varchar({ length: 256 }).$default(() => generateUniqueString(16)),
    title: t.varchar({ length: 256 }),
    ownerId: t.int("owner_id").references(() => users.id),
  },
  (table) => [
    t.uniqueIndex("slug_idx").on(table.slug),
    t.index("title_idx").on(table.title),
  ]
);

export const comments = table("comments", {
  id: t.int().primaryKey().autoincrement(),
  text: t.varchar({ length: 256 }),
  postId: t.int("post_id").references(() => posts.id),
  ownerId: t.int("owner_id").references(() => users.id),
});
```
```ts copy
import { sqliteTable as table } from "drizzle-orm/sqlite-core";
import * as t from "drizzle-orm/sqlite-core";
import { AnySQLiteColumn } from "drizzle-orm/sqlite-core";

export const users = table(
  "users",
  {
    id: t.int().primaryKey({ autoIncrement: true }),
    firstName: t.text("first_name"),
    lastName: t.text("last_name"),
    email: t.text().notNull(),
    invitee: t.int().references((): AnySQLiteColumn => users.id),
    role: t.text().$type<"guest" | "user" | "admin">().default("guest"),
  },
  (table) => [
    t.uniqueIndex("email_idx").on(table.email)
  ]
);

export const posts = table(
  "posts",
  {
    id: t.int().primaryKey({ autoIncrement: true }),
    slug: t.text().$default(() => generateUniqueString(16)),
    title: t.text(),
    ownerId: t.int("owner_id").references(() => users.id),
  },
  (table) => [
    t.uniqueIndex("slug_idx").on(table.slug),
    t.index("title_idx").on(table.title),
  ]
);

export const comments = table("comments", {
  id: t.int().primaryKey({ autoIncrement: true }),
  text: t.text({ length: 256 }),
  postId: t.int("post_id").references(() => posts.id),
  ownerId: t.int("owner_id").references(() => users.id),
});
```
</CodeTabs>

**`generateUniqueString` 实现：**
```ts
function generateUniqueString(length: number = 12): string {
  const characters =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let uniqueString = "";

  for (let i = 0; i < length; i++) {
    const randomIndex = Math.floor(Math.random() * characters.length);
    uniqueString += characters[randomIndex];
  }

  return uniqueString;
}
```


#### 接下来做什么？
<br/>
<Flex>
  <LinksList 
    title='管理模式'
    links={[
        ["列类型", "/docs/column-types/pg"], 
        ["索引和约束", "/docs/indexes-constraints"],
        ["数据库视图", "/docs/views"],
        ["数据库模式", "/docs/schemas"],
        ["序列", "/docs/sequences"],
        ["扩展", "/docs/extensions/pg"],
      ]}
  />
  <LinksList 
    title='从零到英雄'
    links={[
        ["数据库连接", "/docs/connect-overview"], 
        ["数据查询", "/docs/data-querying"], 
        ["迁移", "/docs/migrations"], 
      ]}
  />
</Flex>


Source: https://drizzle.zhcndoc.com/docs/sql

import Callout from '@mdx/Callout.astro';
import CodeTabs from '@mdx/CodeTabs.astro';
import CodeTab from '@mdx/CodeTab.astro';
import Section from '@mdx/Section.astro';

# 神奇的 `sql` 操作符 🪄

在使用 ORM 库时，你可能会遇到某些情况下，使用提供的 ORM 语法编写特定查询会感到困难。
在这种情况下，你可以选择使用原始查询，
这意味着构造一个原始字符串形式的查询。
然而，原始查询往往缺乏类型安全和查询参数化的好处。

为了解决这个问题，许多库引入了 `sql` 模板的概念。
这个模板允许你编写更加类型安全和参数化的查询，增强代码的整体安全性和灵活性。
Drizzle 作为一个强大的 ORM 库，也支持 SQL 模板。

通过 Drizzle 的 `sql` 模板，你可以在构建查询时更进一步。
如果在使用库的查询构建器编写整个查询时遇到困难，
你可以在 Drizzle 查询的特定部分选择性使用 `sql` 模板。
这种灵活性使你能够在部分 SELECT 语句、WHERE 子句、ORDER BY 子句、HAVING 子句、GROUP BY 子句，
甚至关系查询构建器中使用 SQL 模板。

利用 Drizzle 中 SQL 模板的能力，你可以维持类型安全和查询参数化的优点，
同时实现所需的查询结构和复杂性。
这使你能够在应用程序中创建更健壮和可维护的代码。

## sql`` 模板

在其他 ORM 中，
你可能会遇到的一个最常见的用法是能够直接使用 `sql` 查询进行原始查询。

```typescript copy
import { sql } from 'drizzle-orm' 

const id = 69;
await db.execute(sql`select * from ${usersTable} where ${usersTable.id} = ${id}`)
```

它将生成当前查询

```sql
select * from "users" where "users"."id" = $1; --> [69]
```

任何提供给 sql 参数的表和列都会自动映射到相应的 SQL 语法，
表名会进行转义，并且转义的表名会附加到列名上。

此外，任何动态参数例如 `${id}` 将映射到 $1 占位符，
并且相应的值将被移动到一个单独传递给数据库的值数组中。

这种方法有效地防止了任何潜在的 SQL 注入漏洞。

## `sql<T>`

<Callout type="info" emoji="ℹ️">
    请注意，`sql<T>` 不进行任何运行时映射。
    你使用 `sql<T>` 定义的类型仅仅是 Drizzle 的辅助工具。
    理解没有可行的方法动态确定确切类型是很重要的，因为 SQL 查询可以非常多样且可定制。
</Callout>

你可以在 Drizzle 中定义一个自定义类型，用于字段要求特定类型而不是 `unknown` 的地方。

此功能在部分选择查询中尤其有用，确保所选字段的一致类型：

```typescript
// 未定义 sql<T> 类型
const response: { lowerName: unknown }[] = await db.select({
    lowerName: sql`lower(${usersTable.id})`
}).from(usersTable);

// 定义了 sql<T> 类型
const response: { lowerName: string }[] = await db.select({
    lowerName: sql<string>`lower(${usersTable.id})`
}).from(usersTable);
```

## `sql``.mapWith()`

对于需要对从数据库驱动传递给 Drizzle 的值进行运行时映射的情况，你可以使用 `.mapWith()`

此函数接受不同的值，将在运行时映射响应。

您可以复制特定的列映射策略，
只要 mapWith 内部的接口与 Column 实现的接口相同。

```typescript
const usersTable = pgTable('users', {
    id: serial('id').primaryKey(),
    name: text('name').notNull(),
});

// 在运行时，这些值将与 Drizzle 中的 `text` 列映射相同
sql`...`.mapWith(usersTable.name);
```

你还可以为 `DriverValueDecoder` 接口传递自己的实现：

```ts 
sql``.mapWith({
	mapFromDriverValue: (value: any) => {
		const mappedValue = value;
		// 你想要应用的映射
		return mappedValue;
	},
});
    
// 或者
sql``.mapWith(Number);
```

## `sql``.as<T>()`

在不同场景中，有时确定希望使用的自定义字段的名称可能很具挑战性。
你可能会遇到需要明确为要被选择的字段指定别名的情况。
这在处理复杂查询时特别有用。

为了解决这些情况，我们引入了一个有用的 `.as('alias_name')` 助手，
允许你明确地定义别名。利用这个特性，你可以为字段提供清晰有意义的名称，
使你的查询更加直观可读。

<Section>
```typescript
sql`lower(usersTable.name)`.as('lower_name')
```
```sql
... "usersTable"."name" as lower_name ...
```
</Section>

## `sql.raw()`

在某些情况下，你可能不需要根据输入创建参数化值或将表/列映射为转义的。
相反，你可能只想生成原始查询。对于这种情况，我们提供了 `sql.raw()` 函数。

`sql.raw()` 函数允许你在查询中包含原始 SQL 语句，
而不需要任何额外的处理或转义。
此功能在你有预构造的 SQL 语句或当你需要直接将复杂或动态 SQL 代码纳入查询时非常有用。

<Section>
```typescript
sql.raw(`select * from users where id = ${12}`);
// 与
sql`select * from users where id = ${12}`;
```
```sql
select * from users where id = 12;
--> 与
select * from users where id = $1; --> [12]
```
</Section>

你还可以在 sql 函数中利用 `sql.raw()`，使你能够直接包含任何原始字符串，
而无需通过主 `sql` 模板函数进行转义。

通过在 `sql` 函数内部使用 `sql.raw()`，你可以将未经转义的原始字符串直接并入你的查询。
这在你有特定的 SQL 代码或表达式时非常有用，
需要保持不被模板函数的自动转义或修改。

<Section>
```typescript
sql`select * from ${usersTable} where id = ${12}`;
// 与
sql`select * from ${usersTable} where id = ${sql.raw(12)}`;
```
```sql
select * from "users" where id = $1; --> [12]
--> 与
select * from "users" where id = 12;
```
</Section>

## sql.fromList()

`sql` 模板生成 SQL 块，它们是 SQL 部分的数组，
在将 SQL 应用到数据库或 Drizzle 的查询后，将被连接到查询和参数中。

在某些场景中，你可能需要使用自定义业务逻辑将这些块聚合到一个数组中，
然后将它们连接成一个可以传递给数据库或查询的单一 SQL 语句。
对于这种情况，fromList 函数非常有用。

fromList 函数允许你将多个 SQL 块组合成一个单一的 SQL 语句。
你可以根据特定要求聚合并连接个别 SQL 部分，
然后获得一个统一的 SQL 查询，可以执行。

<Section>
```typescript
const sqlChunks: SQL[] = [];

sqlChunks.push(sql`select * from users`);

// 一些逻辑

sqlChunks.push(sql` where `);

// 一些逻辑

for (let i = 0; i < 5; i++) {
	sqlChunks.push(sql`id = ${i}`);

	if (i === 4) continue;
	sqlChunks.push(sql` or `);
}

const finalSql: SQL = sql.fromList(sqlChunks)
```
```sql
select * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]
```
</Section>

## sql.join()

事实上，`sql.join` 函数的作用与 fromList 助手相似。
然而，在处理两者之间的空间时，它提供了额外的灵活性
SQL 块或指定用于连接 SQL 块的自定义分隔符。

使用 `sql.join`，你可以使用指定的分隔符连接 SQL 块。
此分隔符可以是任何你希望在块之间插入的字符串或字符。

当你对 SQL 块的格式或分隔有特定要求时，这特别有用。
通过指定自定义分隔符，
你可以在最终的 SQL 查询中实现所需的结构和格式。

<Section>
```typescript
const sqlChunks: SQL[] = [];

sqlChunks.push(sql`select * from users`);

// 一些逻辑

sqlChunks.push(sql`where`);

// 一些逻辑

for (let i = 0; i < 5; i++) {
	sqlChunks.push(sql`id = ${i}`);

	if (i === 4) continue;
    sqlChunks.push(sql`or`);
}

const finalSql: SQL = sql.join(sqlChunks, sql.raw(' '));
```
```sql
select * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]
```
</Section>

## sql.append()

如果你已经使用 `sql` 模板生成了 SQL，
你可以通过使用 append 函数直接将新块添加到生成的 SQL 来实现与 fromList 相同的行为。

通过使用 append 函数，你可以动态地向现有的 SQL 字符串添加额外的 SQL 块，
有效地将它们连接在一起。
这使你能够将自定义逻辑或业务规则并入最终的 SQL 查询。

<Section>
```typescript 
const finalSql = sql`select * from users`;

// 一些逻辑

finalSql.append(sql` where `);

// 一些逻辑

for (let i = 0; i < 5; i++) {
	finalSql.append(sql`id = ${i}`);

	if (i === 4) continue;
	finalSql.append(sql` or `);
}
```
```sql
select * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]
```
</Section>

## sql.empty()

通过使用 sql.empty()，你可以从一个空的 SQL 对象开始，然后根据需要动态地将 SQL 块附加到它上。这使你能够逐步构建 SQL 查询，应用自定义逻辑或条件来确定每个块的内容。

一旦你使用 sql.empty() 初始化了 SQL 对象，
你可以利用 sql 模板的完整功能，如参数化、组合和转义。
这使你能够以灵活和可控的方式构建 SQL 查询，
适应特定的要求。

```typescript 
const finalSql = sql.empty();

// 一些逻辑

finalSql.append(sql`select * from users`);

// 一些逻辑

finalSql.append(sql` where `);

// 一些逻辑

for (let i = 0; i < 5; i++) {
	finalSql.append(sql`id = ${i}`);

	if (i === 4) continue;
	finalSql.append(sql` or `);
}
```
```sql
select * from users where id = $1 or id = $2 or id = $3 or id = $4 or id = $5; --> [0, 1, 2, 3, 4]
```

## 将 `sql` 转换为字符串和参数

在所有之前的示例中，你观察到了 SQL 模板语法在 TypeScript
中的使用以及生成的 SQL 输出。

如果你需要获取从 SQL 模板生成的查询字符串和相应的参数，
你必须指定希望为其生成查询的数据库方言。
不同的数据库在参数化和转义的语法上有所不同，因此选择适当的方言至关重要。

一旦选择了方言，
你可以利用相应实现的功能将 SQL 模板转换为所需的查询字符串和参数格式。
这确保了与特定数据库系统的兼容性。

<CodeTabs items={["PostgreSQL", "MySQL", "SQLite"]}>
<CodeTab>
<Section>
```typescript copy
import { PgDialect } from 'drizzle-orm/pg-core';

const pgDialect = new PgDialect();
pgDialect.sqlToQuery(sql`select * from ${usersTable} where ${usersTable.id} = ${12}`);
```
```sql
select * from "users" where "users"."id" = $1; --> [ 12 ]
```
</Section>

</CodeTab>
<CodeTab>
<Section>
```typescript copy
import { MySqlDialect } from 'drizzle-orm/mysql-core';

const mysqlDialect = new MySqlDialect();
mysqlDialect.sqlToQuery(sql`select * from ${usersTable} where ${usersTable.id} = ${12}`);
```
```sql
select * from `users` where `users`.`id` = ?; --> [ 12 ]
```
</Section>
</CodeTab>
<CodeTab>
<Section>
```typescript copy
import { SQLiteSyncDialect } from 'drizzle-orm/sqlite-core';

const sqliteDialect = new SQLiteSyncDialect();
sqliteDialect.sqlToQuery(sql`select * from ${usersTable} where ${usersTable.id} = ${12}`);
```
```sql
select * from "users" where "users"."id" = ?; --> [ 12 ]
```
</Section>
</CodeTab>
</CodeTabs>

## `sql` select

你也可以在部分选择查询中使用 sql 功能。
部分选择查询允许你从一个表中检索特定的字段或列，而不是获取完整行。

有关部分选择查询的更多详细信息，
可以参考 **[核心 API 文档](/docs/select#basic-and-partial-select)**。

**从表中选择不同的自定义字段**

在这里，你可以看到 **[`sql<T>`](/docs/sql#sqlt)**, **[`sql``.mapWith()`](/docs/sql#sqlmapwith)**, **[`sql``.as<T>()`](/docs/sql#sqlast)** 的用法。

<Section>
```typescript copy
import { sql } from 'drizzle-orm'
import { usersTable } from 'schema'

await db.select({
    id: usersTable.id,
    lowerName: sql<string>`lower(${usersTable.name})`,
    aliasedName: sql<string>`lower(${usersTable.name})`.as('aliased_column'),
    count: sql<number>`count(*)`.mapWith(Number) 
}).from(usersTable)
```
```sql
select `id`, lower(`name`), lower(`name`) as `aliased_column`, count(*) from `users`;
```
</Section>

## `sql` in where

确实，Drizzle 提供了一组可用的表达式，你可以在 sql 模板中使用。
然而，数据库通常有更多可用的表达式，
包括通过扩展或其他手段提供的。

为确保灵活性，并使你能够利用任何在 Drizzle 中未原生支持的表达式，
你可以直接使用 sql 函数编写 SQL 模板。
这使你能够充分发挥 SQL 的能力，
结合特定于目标数据库的任何表达式或功能。

使用 sql 模板时，你不会局限于 Drizzle 中预定义的表达式。
相反，你可以表达复杂查询，
并结合底层数据库系统提供的任何支持的表达式。


**按 `id` 过滤，但使用 sql**
<Section>
```typescript copy
import { sql } from 'drizzle-orm'
import { usersTable } from 'schema'

const id = 77

await db.select()
        .from(usersTable)
        .where(sql`${usersTable.id} = ${id}`)
```
```sql
select * from "users" where "users"."id" = $1; --> [ 77 ]
```
</Section>

**高级的全文搜索 where 语句**
<Section>
```typescript copy
import { sql } from 'drizzle-orm'
import { usersTable } from 'schema'

const searchParam = "Ale"

await db.select()
        .from(usersTable)
        .where(sql`to_tsvector('simple', ${usersTable.name}) @@ to_tsquery('simple', ${searchParam})`)
```
```sql
select * from "users" where to_tsvector('simple', "users"."name") @@ to_tsquery('simple', '$1'); --> [ "Ale" ]
```
</Section>

## `sql` in orderBy

`sql` 模板确实可以在 ORDER BY 子句中使用，
当你需要某种特定功能进行排序而 Drizzle 中没有时，但又不想诉诸原始 SQL。

<Section>
```typescript copy
import { sql } from 'drizzle-orm'
import { usersTable } from 'schema'

await db.select().from(usersTable).orderBy(sql`${usersTable.id} desc nulls first`)
```
```sql
select * from "users" order by "users"."id" desc nulls first;
```
</Section>

## `sql` in having 和 groupBy

`sql` 模板确实可以在 HAVING 和 GROUP BY 子句中使用，当你需要某种特定功能进行分组，
而 Drizzle 中没有，但又不想诉诸原始 SQL。

<Section>
```typescript copy
import { sql } from 'drizzle-orm'
import { usersTable } from 'schema'

await db.select({ 
    projectId: usersTable.projectId,
    count: sql<number>`count(${usersTable.id})`.mapWith(Number)
}).from(usersTable)
    .groupBy(sql`${usersTable.projectId}`)
    .having(sql`count(${usersTable.id}) > 300`)
```
```sql
select "project_id", count("users"."id") from users group by "users"."project_id" having count("users"."id") > 300; 
```
</Section>


Source: https://drizzle.zhcndoc.com/docs/transactions

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';

# 事务

SQL 事务是一个或多个与数据库交互的 SQL 语句的组合。
一个事务可以作为一个单一的逻辑单元提交到数据库，
或者作为一个单一的逻辑单元回滚（撤销）。

Drizzle ORM 提供了在事务中运行 SQL 语句的 API：

```ts copy
const db = drizzle(...)

await db.transaction(async (tx) => {
  await tx.update(accounts).set({ balance: sql`${accounts.balance} - 100.00` }).where(eq(users.name, 'Dan'));
  await tx.update(accounts).set({ balance: sql`${accounts.balance} + 100.00` }).where(eq(users.name, 'Andrew'));
});
```

Drizzle ORM 支持 `savepoints` 以及嵌套事务 API：

```ts copy {7-9}
const db = drizzle(...)

await db.transaction(async (tx) => {
  await tx.update(accounts).set({ balance: sql`${accounts.balance} - 100.00` }).where(eq(users.name, 'Dan'));
  await tx.update(accounts).set({ balance: sql`${accounts.balance} + 100.00` }).where(eq(users.name, 'Andrew'));

  await tx.transaction(async (tx2) => {
    await tx2.update(users).set({ name: "Mr. Dan" }).where(eq(users.name, "Dan"));
  });
});
```

您可以将业务逻辑嵌入到事务中，并在需要时回滚：

```ts copy {7}
const db = drizzle(...)

await db.transaction(async (tx) => {
  const [account] = await tx.select({ balance: accounts.balance }).from(accounts).where(eq(users.name, 'Dan'));
  if (account.balance < 100) {
    // 这将抛出一个异常，从而回滚事务。
    tx.rollback()
  }

  await tx.update(accounts).set({ balance: sql`${accounts.balance} - 100.00` }).where(eq(users.name, 'Dan'));
  await tx.update(accounts).set({ balance: sql`${accounts.balance} + 100.00` }).where(eq(users.name, 'Andrew'));
});
```

您可以从事务中返回值：

```ts copy {8}
const db = drizzle(...)

const newBalance: number = await db.transaction(async (tx) => {
  await tx.update(accounts).set({ balance: sql`${accounts.balance} - 100.00` }).where(eq(users.name, 'Dan'));
  await tx.update(accounts).set({ balance: sql`${accounts.balance} + 100.00` }).where(eq(users.name, 'Andrew'));

  const [account] = await tx.select({ balance: accounts.balance }).from(accounts).where(eq(users.name, 'Dan'));
  return account.balance;
});
```

您可以使用事务与 **[关系查询](/docs/rqb)**：

```ts
const db = drizzle({ schema })

await db.transaction(async (tx) => {
  await tx.query.users.findMany({
    with: {
      accounts: true
    }
  });
});
```





我们提供特定于方言的事务配置 API：

<Tabs items={["PostgreSQL", "MySQL", "SQLite", "SingleStore"]}>
<Tab>
```ts copy {6-8}
await db.transaction(
  async (tx) => {
    await tx.update(accounts).set({ balance: sql`${accounts.balance} - 100.00` }).where(eq(users.name, "Dan"));
    await tx.update(accounts).set({ balance: sql`${accounts.balance} + 100.00` }).where(eq(users.name, "Andrew"));
  }, {
    isolationLevel: "read committed",
    accessMode: "read write",
    deferrable: true,
  }
);

interface PgTransactionConfig {
  isolationLevel?:
    | "read uncommitted"
    | "read committed"
    | "repeatable read"
    | "serializable";
  accessMode?: "read only" | "read write";
  deferrable?: boolean;
}
```
</Tab>
<Tab>
```ts {6-8}
await db.transaction(
  async (tx) => {
    await tx.update(accounts).set({ balance: sql`${accounts.balance} - 100.00` }).where(eq(users.name, "Dan"));
    await tx.update(accounts).set({ balance: sql`${accounts.balance} + 100.00` }).where(eq(users.name, "Andrew"));
  }, {
    isolationLevel: "read committed",
    accessMode: "read write",
    withConsistentSnapshot: true,
  }
);

interface MySqlTransactionConfig {
  isolationLevel?:
    | "read uncommitted"
    | "read committed"
    | "repeatable read"
    | "serializable";
  accessMode?: "read only" | "read write";
  withConsistentSnapshot?: boolean;
}
```
</Tab>
<Tab>
```ts {6}
await db.transaction(
  async (tx) => {
    await tx.update(accounts).set({ balance: sql`${accounts.balance} - 100.00` }).where(eq(users.name, "Dan"));
    await tx.update(accounts).set({ balance: sql`${accounts.balance} + 100.00` }).where(eq(users.name, "Andrew"));
  }, {
    behavior: "deferred",
  }
);

interface SQLiteTransactionConfig {
    behavior?: 'deferred' | 'immediate' | 'exclusive';
}
```
</Tab>
<Tab>
```ts {6-8}
await db.transaction(
  async (tx) => {
    await tx.update(accounts).set({ balance: sql`${accounts.balance} - 100.00` }).where(eq(users.name, "Dan"));
    await tx.update(accounts).set({ balance: sql`${accounts.balance} + 100.00` }).where(eq(users.name, "Andrew"));
  }, {
    isolationLevel: "read committed",
    accessMode: "read write",
    withConsistentSnapshot: true,
  }
);

interface SingleStoreTransactionConfig {
  isolationLevel?:
    | "read uncommitted"
    | "read committed"
    | "repeatable read"
    | "serializable";
  accessMode?: "read only" | "read write";
  withConsistentSnapshot?: boolean;
}
```
</Tab>
</Tabs>



Source: https://drizzle.zhcndoc.com/docs/tutorials

import Tutorials from "@components/Tutorials.astro";

<Tutorials/>

Source: https://drizzle.zhcndoc.com/docs/tutorials/drizzle-with-netlify-edge-functions-neon


import Prerequisites from "@mdx/Prerequisites.astro";
import Npm from '@mdx/Npm.astro';
import Steps from '@mdx/Steps.astro';
import Section from "@mdx/Section.astro";
import Callout from "@mdx/Callout.astro";

本教程演示了如何使用 Drizzle ORM 和 [Netlify Edge Functions](https://docs.netlify.com/edge-functions/overview/) 及 [Neon Postgres](https://neon.tech/) 数据库。

<Prerequisites>
- 您应该安装了最新版本的 [Netlify CLI](https://docs.netlify.com/cli/get-started/#installation)。
- 您应该已安装 Drizzle ORM 和 [Drizzle kit](/docs/kit-overview)。您可以通过运行以下命令来完成此操作：
<Npm>
drizzle-orm
-D drizzle-kit
</Npm>

- 您应该已安装 `dotenv` 包以管理环境变量。如果您使用 Node.js `v20.6.0` 或更高版本，则无需安装，因为 Node.js 原生支持 `.env` 文件。详细了解 [这里](https://nodejs.org/en/blog/release/v20.6.0#built-in-env-file-support)。
<Npm>
  dotenv
</Npm>

- 可选地，您可以安装 `@netlify/edge-functions` 包，以导入稍后将使用的 `Context` 对象的类型。
<Npm>
  @netlify/edge-functions
</Npm>
</Prerequisites>

<Callout type="warning">
这些安装的包仅用于在 [创建表](#create-a-table)、[设置 Drizzle 配置文件](#setup-drizzle-config-file) 和 [将更改应用到数据库](#apply-changes-to-the-database) 步骤中创建数据库中的表。这些包不会影响在 Netlify Edge Functions 内部运行的代码。我们将使用 `import_map.json` 导入 Edge Functions 所需的包。
</Callout>

<Steps>
#### 设置 Neon Postgres

登录到 [Neon 控制台](https://console.neon.tech/app/projects) 并导航到项目部分。选择一个项目或单击 `新建项目` 按钮以创建一个新项目。

您的 Neon 项目附带一个可直接使用的名为 `neondb` 的 Postgres 数据库。我们将在本教程中使用它。

#### 设置连接字符串变量

在 **项目仪表板** 部分单击 `连接` 按钮并复制您的数据库连接字符串。它应该看起来类似于：

```bash
postgres://username:password@ep-cool-darkness-123456.us-east-2.aws.neon.tech/neondb?sslmode=require
```

在 `.env` 文件中添加 `DATABASE_URL` 环境变量，用于连接 Neon 数据库。

```text copy
DATABASE_URL=NEON_DATABASE_CONNECTION_STRING
```

#### 设置 Netlify Edge Functions

在项目根目录下创建 `netlify/edge-functions` 目录。这是您将存储 Edge Functions 的地方。

在 `netlify/edge-functions` 目录中创建一个函数 `user.ts`。

```typescript copy filename="netlify/edge-functions/user.ts"
import type { Context } from "@netlify/edge-functions";

export default async (request: Request, context: Context) => {
  return new Response("用户数据");
};
```

<Callout type="warning">
`Request` 和 `Response` 对象的类型处于全局作用域中。
</Callout>

#### 设置导入

在项目根目录中创建一个 `import_map.json` 文件并添加以下内容：

```json copy filename="import_map.json"
{
  "imports": {
    "drizzle-orm/": "https://esm.sh/drizzle-orm/",
    "@neondatabase/serverless": "https://esm.sh/@neondatabase/serverless"
  }
}
```

在 Netlify Edge Functions 中详细了解 `import_map.json` [这里](https://docs.netlify.com/edge-functions/api/#import-maps)。

#### 创建 Netlify 配置文件

在项目根目录中创建一个 `netlify.toml` 文件并添加以下内容：

```toml copy filename="netlify.toml"
[functions]
  deno_import_map = "./import_map.json"

[[edge_functions]]
  path = "/user"
  function = "user"
```

此配置告诉 Netlify 使用 `import_map.json` 文件进行 Deno 导入，并将对 `/user` 路径的请求路由到 `user.ts` 函数。
在 [这里](https://docs.netlify.com/configure-builds/file-based-configuration/) 了解更多关于 `netlify.toml` 的内容。

#### 创建表

在 `netlify/edge-functions/common` 目录中创建一个 `schema.ts` 文件并声明一个表模式：

```typescript copy filename="netlify/edge-functions/common/schema.ts"
import { pgTable, serial, text, integer } from "drizzle-orm/pg-core";

export const usersTable = pgTable('users_table', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  age: integer('age').notNull(),
  email: text('email').notNull().unique(),
})
```

#### 设置 Drizzle 配置文件

**Drizzle 配置** - 用于 [Drizzle Kit](/docs/kit-overview) 的配置文件，包含有关您的数据库连接、迁移文件夹和模式文件的所有信息。

在项目根目录中创建一个 `drizzle.config.ts` 文件并添加以下内容：

```typescript copy filename="drizzle.config.ts"
import 'dotenv/config'; // 如果使用 Node.js v20.6.0 或更高版本，则删除此行
import type { Config } from "drizzle-kit";

export default {
  schema: './netlify/edge-functions/common/schema.ts',
  out: './drizzle',
  dialect: 'postgresql',
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
} satisfies Config;
```

在本教程中，我们将使用 Drizzle kit 将更改推送到 Neon 数据库。

#### 将更改应用到数据库

```bash copy
npx drizzle-kit push
```
<Callout type="warning">推送命令适用于需要快速测试新架构设计或在本地开发环境中进行更改的情况，允许快速迭代而无需管理迁移文件的开销。</Callout>

或者，您可以使用迁移工作流程。关于它的更多信息请查看这里： [迁移](/docs/migrations)。

#### 将 Drizzle ORM 连接到您的数据库

更新您的 `netlify/edge-functions/user.ts` 文件并设置您的数据库配置：

```typescript copy filename="netlify/edge-functions/user.ts"
import type { Context } from "@netlify/edge-functions";
import { usersTable } from "./common/schema.ts";
import { neon } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-http';

export default async (request: Request, context: Context) => {
  const sql = neon(Netlify.env.get("DATABASE_URL")!);
  const db = drizzle({ client: sql });

  const users = await db.select().from(usersTable);

  return new Response(JSON.stringify(users));
};
```

<Callout type="warning">
如果您在使用 VS Code，导入可能会看到红色下划线。Edge Function 仍将执行。要消除红色下划线，您可以在下一步中配置 VS Code 使用 Edge Functions。
</Callout>

#### 在本地测试您的代码

运行以下命令以启动 Netlify 开发服务器：

```bash copy
netlify dev
```

当您第一次运行该命令时，它会建议配置 VS Code 使用 Edge Functions。单击 `是` 进行配置。在 `.vscode` 目录中将创建 `settings.json` 文件。
如果您仍然看到红色下划线，可以重新启动 Deno 语言服务器。

在浏览器中打开并导航到 `/user` 路由。您应该会看到从 Neon 数据库返回的用户数据：

```plaintext
[]
```

如果您尚未向 `users_table` 表中添加数据，则可能会看到一个空数组。

#### 初始化一个新的 Netlify 项目

运行以下命令以初始化一个新的 Netlify 项目：

```bash copy
netlify init
```

在 CLI 中回答问题以创建一个新的 Netlify 项目。在本教程中，我们将选择 `是，手动创建和部署网站` -> `<YOUR_TEAM>` -> `<SITE_NAME>`。

#### 设置 Netlify 环境变量

运行以下命令以将您的环境变量导入到 Netlify：

```bash copy
netlify env:import .env
```

在 [这里](https://docs.netlify.com/environment-variables/get-started/) 了解有关 Netlify 环境变量的更多信息。

#### 部署您的项目

运行以下命令以部署您的项目：

```bash copy
netlify deploy
```

按照 CLI 中的说明将您的项目部署到 Netlify。在本教程中，我们的发布目录是 `'.'`。

默认情况下这是一个 [草稿部署](https://docs.netlify.com/cli/get-started/#draft-deploys)。
要进行生产部署，请运行以下命令：

```bash copy
netlify deploy --prod
```

</Steps>

最后，您可以使用已部署网站的 URL 并导航到您创建的路由（例如 `/user`）以访问您的 Edge Function。


Source: https://drizzle.zhcndoc.com/docs/tutorials/drizzle-with-netlify-edge-functions-supabase


import Prerequisites from "@mdx/Prerequisites.astro";
import Npm from '@mdx/Npm.astro';
import Steps from '@mdx/Steps.astro';
import Section from "@mdx/Section.astro";
import Callout from "@mdx/Callout.astro";

本教程演示了如何使用 Drizzle ORM 与 [Netlify Edge 函数](https://docs.netlify.com/edge-functions/overview/) 和 [Supabase 数据库](https://supabase.com/docs/guides/database/overview) 数据库。

<Prerequisites>
- 你应该安装最新版本的 [Netlify CLI](https://docs.netlify.com/cli/get-started/#installation)。
- 你应该已经安装了 Drizzle ORM 和 [Drizzle kit](/docs/kit-overview)。你可以通过运行以下命令来完成这一步：
<Npm>
drizzle-orm
-D drizzle-kit
</Npm>

- 你应该已经安装了用于管理环境变量的 `dotenv` 包。如果你使用的是 Node.js `v20.6.0` 或更高版本，则不需要安装它，因为 Node.js 原生支持 `.env` 文件。有关更多信息，请阅读 [这里](https://nodejs.org/en/blog/release/v20.6.0#built-in-env-file-support)。
<Npm>
  dotenv
</Npm>

- 可选地，你可以安装 `@netlify/edge-functions` 包，以导入稍后将使用的 `Context` 对象的类型。
<Npm>
  @netlify/edge-functions
</Npm>
</Prerequisites>

<Callout type="warning">
这些安装的包仅用于在 [创建表](#create-a-table)、[设置 Drizzle 配置文件](#setup-drizzle-config-file) 和 [将更改应用于数据库](#apply-changes-to-the-database) 步骤中在数据库中创建表。这些包不会影响在 Netlify Edge 函数内部运行的代码。我们将使用 `import_map.json` 导入 Edge 函数所需的包。
</Callout>

<Steps>
#### 创建一个新的 Supabase 项目

你可以在 [仪表板](https://supabase.com/dashboard) 中创建新的 Supabase 项目，也可以通过此 [链接](https://database.new/) 进行创建。

#### 设置连接字符串变量

你可以通过点击仪表板顶部的 **连接** 以查找 `项目连接详细信息`，并从 `交易池` 部分复制 URI。记得用你的实际数据库密码替换密码占位符。

将 `DATABASE_URL` 变量添加到你的 `.env` 文件中。

```plaintext copy
DATABASE_URL=<YOUR_DATABASE_URL>
```

有关连接 Supabase 数据库的更多信息，请查看 [文档](https://supabase.com/docs/guides/database/connecting-to-postgres#connection-pooler)。

#### 设置 Netlify Edge 函数

在你的项目根目录中创建 `netlify/edge-functions` 目录。这是你将存储 Edge 函数的地方。

在 `netlify/edge-functions` 目录中创建一个函数 `user.ts`。

```typescript copy filename="netlify/edge-functions/user.ts"
import type { Context } from "@netlify/edge-functions";

export default async (request: Request, context: Context) => {
  return new Response("用户数据");
};
```

<Callout type="warning">
`Request` 和 `Response` 对象的类型在全局范围内。
</Callout>

#### 设置导入

在你的项目根目录中创建一个 `import_map.json` 文件，并添加以下内容：

```json copy filename="import_map.json"
{
  "imports": {
    "drizzle-orm/": "https://esm.sh/drizzle-orm/",
    "postgres": "https://esm.sh/postgres"
  }
}
```

有关 `import_map.json` 的更多信息，请查看 Netlify Edge 函数的 [文档](https://docs.netlify.com/edge-functions/api/#import-maps)。

#### 创建 Netlify 配置文件

在你的项目根目录中创建一个 `netlify.toml` 文件，并添加以下内容：

```toml copy filename="netlify.toml"
[functions]
  deno_import_map = "./import_map.json"

[[edge_functions]]
  path = "/user"
  function = "user"
```

此配置告诉 Netlify 使用 `import_map.json` 文件进行 Deno 导入，并将对 `/user` 路径的请求路由到 `user.ts` 函数。
有关 `netlify.toml` 的更多信息，请查看 [文档](https://docs.netlify.com/configure-builds/file-based-configuration/)。

#### 创建一个表

在 `netlify/edge-functions/common` 目录中创建一个 `schema.ts` 文件，并声明一个表模式：

```typescript copy filename="netlify/edge-functions/common/schema.ts"
import { pgTable, serial, text, integer } from "drizzle-orm/pg-core";

export const usersTable = pgTable('users_table', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  age: integer('age').notNull(),
  email: text('email').notNull().unique(),
})
```

#### 设置 Drizzle 配置文件

**Drizzle 配置** - 一个被 [Drizzle Kit](/docs/kit-overview) 使用的配置文件，包含关于数据库连接、迁移文件夹和模式文件的所有信息。

在你的项目根目录中创建一个 `drizzle.config.ts` 文件，并添加以下内容：

```typescript copy filename="drizzle.config.ts"
import 'dotenv/config'; // 如果你使用 Node.js v20.6.0 或更高版本，请移除此行
import type { Config } from "drizzle-kit";

export default {
  schema: './netlify/edge-functions/common/schema.ts',
  out: './drizzle',
  dialect: 'postgresql',
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
} satisfies Config;
```

在本教程中，我们将使用 Drizzle kit 将更改推送到 Neon 数据库。

#### 将更改应用于数据库

```bash copy
npx drizzle-kit push
```
<Callout type="warning">推送命令适合于需要快速测试新模式设计或在本地开发环境中进行快速迭代的情况，无需管理迁移文件的开销。</Callout>

另外，你可以使用迁移工作流。有关更多信息，请阅读 [迁移文档](/docs/migrations)。

#### 将 Drizzle ORM 连接到你的数据库

更新你的 `netlify/edge-functions/user.ts` 文件并设置数据库配置：

```typescript copy filename="netlify/edge-functions/user.ts"
import type { Context } from "@netlify/edge-functions";
import { usersTable } from "./common/schema.ts";
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';

export default async (request: Request, context: Context) => {
  const queryClient = postgres(Netlify.env.get("DATABASE_URL")!);
  const db = drizzle({ client: queryClient });

  const users = await db.select().from(usersTable);

  return new Response(JSON.stringify(users));
};
```

<Callout type="warning">
如果你在使用 VS Code，你可能会看到导入部分下面有红色下划线。Edge 函数仍然会执行。要消除红色下划线，可以在下一步中配置 VS Code 使用 Edge 函数。
</Callout>

#### 在本地测试你的代码

运行以下命令以启动 Netlify 开发服务器：

```bash copy
netlify dev
```

首次运行该命令时，它会建议你配置 VS Code 以使用 Edge 函数。点击 `是` 进行配置。一个 `settings.json` 文件将会在 `.vscode` 目录中创建。
如果你仍然看到红色下划线，可以重新启动 Deno 语言服务器。

打开你的浏览器并导航到路由 `/user`。你应该能从 Neon 数据库中看到返回的用户数据：

```plaintext
[]
```

如果你没有向 `users_table` 表中添加任何数据，它可能是一个空数组。

#### 初始化一个新的 Netlify 项目

运行以下命令以初始化一个新的 Netlify 项目：

```bash copy
netlify init
```

在 CLI 中回答问题以创建一个新的 Netlify 项目。在本教程中，我们将选择 `是，手动创建和部署站点` -> `<YOUR_TEAM>` -> `<SITE_NAME>`。

#### 设置 Netlify 环境变量

运行以下命令将你的环境变量导入到 Netlify：

```bash copy
netlify env:import .env
```

有关 Netlify 环境变量的更多信息，请查看 [文档](https://docs.netlify.com/environment-variables/get-started/)。

#### 部署你的项目

运行以下命令以部署你的项目：

```bash copy
netlify deploy
```

按照 CLI 中的说明将你的项目部署到 Netlify。在本教程中，我们的发布目录为 `'.'`。

默认情况下，这是一个 [草稿部署](https://docs.netlify.com/cli/get-started/#draft-deploys)。
要进行生产部署，请运行以下命令：

```bash copy
netlify deploy --prod
```

</Steps>

最后，你可以使用部署网站的 URL，导航到你创建的路由 `(例如 /user)` 以访问你的 Edge 函数。


Source: https://drizzle.zhcndoc.com/docs/tutorials/drizzle-with-supabase-edge-functions


import Prerequisites from "@mdx/Prerequisites.astro";
import Npm from '@mdx/Npm.astro';
import Steps from '@mdx/Steps.astro';
import Section from "@mdx/Section.astro";
import Callout from '@mdx/Callout.astro';

本教程演示了如何使用 Drizzle ORM 与 [Supabase Edge Functions](https://supabase.com/docs/guides/functions)。

<Prerequisites>
- 你应该安装最新版本的 [Supabase CLI](https://supabase.com/docs/guides/cli/getting-started#installing-the-supabase-cli)。
- 你应该已经安装了 Drizzle ORM 和 [Drizzle kit](https://orm.drizzle.team/kit-docs/overview)。你可以通过运行以下命令来完成：
<Npm>
drizzle-orm
-D drizzle-kit
</Npm>
- 你应该安装 Docker Desktop。它是本地开发的前提条件。请按照官方 [文档](https://docs.docker.com/desktop) 进行安装。
</Prerequisites>

要了解如何在本地计算机上创建基本的 Edge Function 并进行部署，请参阅 [Edge Functions 快速入门](https://supabase.com/docs/guides/functions/quickstart)。

<Steps>
#### 创建表

在 `src` 目录中创建一个 `schema.ts` 文件，并声明一个表架构：

```typescript copy filename="src/schema.ts"
import { pgTable, serial, text, integer } from "drizzle-orm/pg-core";

export const usersTable = pgTable('users_table', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  age: integer('age').notNull()
})
```

此文件将用于为你的数据库生成迁移。

#### 设置 Drizzle 配置文件

**Drizzle 配置** - 是一个由 [Drizzle Kit](https://orm.drizzle.team/kit-docs/overview) 使用的配置文件，其中包含关于数据库连接、迁移文件夹和架构文件的所有信息。

在项目根目录中创建一个 `drizzle.config.ts` 文件，并添加以下内容：

```typescript copy filename="drizzle.config.ts"
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  schema: "./src/schema.ts",
  out: "./supabase/migrations",
  dialect: "postgresql",
});
```

在本教程中，我们将使用 Drizzle kit 为我们的架构生成迁移。

#### 初始化新的 Supabase 项目

在本地计算机的文件夹中创建一个新的 Supabase 项目：

```bash copy
supabase init
```

这将创建一个 `supabase` 文件夹和 `config.toml` 文件：

```text
└── supabase
    └── config.toml
```

如果你在使用 Visual Studio Code，请按照 [Supabase 文档](https://supabase.com/docs/guides/functions/local-development#deno-with-visual-studio-code) 设置 Deno 的配置。

#### 生成迁移

运行 `drizzle-kit generate` 命令生成迁移：

```bash copy
npx drizzle-kit generate
```

这将在 `supabase/migrations` 目录中创建一个新的迁移文件：

#### 应用迁移

要启动 Supabase 本地开发栈，请运行以下命令：

```bash copy
supabase start
```

要应用迁移，请运行以下命令：

```bash copy
supabase migration up
```

你可以在 [文档](https://supabase.com/docs/guides/deployment/database-migrations) 中阅读更多关于 Supabase 迁移的信息。

<Callout type="warning">别忘了运行 Docker</Callout>

另外，你也可以使用 `drizzle-kit migrate` 命令来应用迁移。了解更多关于此迁移过程的信息，请查看 [文档](https://orm.drizzle.team/docs/migrations)。

#### 创建新的 Edge Function

运行 `supabase functions new [FUNCTION_NAME]` 命令创建新的 Edge Function：

```bash copy
supabase functions new drizzle-tutorial
```

这将在 `supabase/functions` 目录下创建一个新的函数名称文件夹：

```text
└── supabase
    └── functions
    │   └── drizzle-tutorial
    │   │   ├── .npmrc ## 函数特定的 npm 配置（如果需要）
    │   │   ├── deno.json ## 函数特定的 Deno 配置
    │   │   └── index.ts ## 你的函数代码
```

创建新的 Edge Function 时，默认情况下将使用 TypeScript。但是，也可以使用 JavaScript 编写 Edge Function。了解更多信息请参阅 [文档](https://supabase.com/docs/guides/functions/quickstart#not-using-typescript)。

#### 设置导入

将以下导入添加到 `supabase/functions/drizzle-tutorial/deno.json` 文件中：

```json copy filename="supabase/functions/drizzle-tutorial/deno.json"
{
  "imports": {
    "drizzle-orm/": "npm:/drizzle-orm/",
    "postgres": "npm:postgres"
  }
}
```

你可以在 [这里](https://supabase.com/docs/guides/functions/dependencies#managing-dependencies) 阅读更多关于管理依赖的信息。

#### 将你的架构复制到函数目录

从 `src/schema.ts` 文件中复制你将在 Edge Function 中使用的代码到 `supabase/functions/drizzle-tutorial/index.ts` 文件：

```typescript copy filename="supabase/functions/drizzle-tutorial/index.ts"
// 设置内置 Supabase Runtime API 的类型定义
import "jsr:@supabase/functions-js/edge-runtime.d.ts"
import { pgTable, serial, text, integer } from "drizzle-orm/pg-core";

const usersTable = pgTable('users_table', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  age: integer('age').notNull()
})

Deno.serve(async (req) => {
  const { name } = await req.json()
  const data = {
    message: `Hello ${name}!`,
  }

  return new Response(
    JSON.stringify(data),
    { headers: { "Content-Type": "application/json" } },
  )
})  
```

<Callout type="warning">
在 Deno 生态系统中，每个函数都应该被视为一个独立的项目，并具有自己的一组依赖和配置。
因此，Supabase 建议在每个函数的目录中维护单独的配置文件（`deno.json`、`.npmrc` 或 `import_map.json`），即使这意味着重复一些配置。更多信息请查阅 [这里](https://supabase.com/docs/guides/functions/dependencies#managing-dependencies)。
</Callout>

#### 将 Drizzle ORM 连接到你的数据库

更新你的 Edge Function 代码以包含数据库配置：

```typescript copy filename="supabase/functions/drizzle-tutorial/index.ts" {14,17,18}
// 设置内置 Supabase Runtime API 的类型定义
import { integer, pgTable, serial, text } from "drizzle-orm/pg-core";
import { drizzle } from "drizzle-orm/postgres-js";
import "jsr:@supabase/functions-js/edge-runtime.d.ts";
import postgres from "postgres";

const usersTable = pgTable('users_table', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  age: integer('age').notNull()
})

Deno.serve(async () => {
  const connectionString = Deno.env.get("SUPABASE_DB_URL")!;

  // 禁用预取，因为它不支持“Transaction”池模式
  const client = postgres(connectionString, { prepare: false });
  const db = drizzle({ client });

  await db.insert(usersTable).values({
    name: "Alice",
    age: 25
  })
  const data = await db.select().from(usersTable);

  return new Response(
    JSON.stringify(data)
  )
})
```

`SUPABASE_DB_URL` 是直接数据库连接的默认环境变量。了解更多关于管理 Supabase Edge Function 中环境变量的信息，请查阅 [文档](https://supabase.com/docs/guides/functions/secrets)。

#### 在本地测试你的代码

运行以下命令在本地测试你的函数：

```bash copy
supabase functions serve --no-verify-jwt
```

在浏览器中导航到创建的路由 `(e.g. /drizzle-tutorial)`：

```plaintext
[
  {
    "id": 1,
    "name": "Alice",
    "age": 25
  }
]
```

#### 将本地项目链接到托管的 Supabase 项目

你可以在 [仪表板](https://supabase.com/dashboard) 中创建新的 Supabase 项目或通过此 [链接](https://database.new/)。

从项目设置中复制 `Reference ID`，并使用它通过运行以下命令将你的本地开发项目链接到托管的 Supabase 项目：

```bash copy
supabase link --project-ref=<REFERENCE_ID>
```

通过运行以下命令将模式更改推送到托管的 Supabase 项目：

```bash copy
supabase db push
```

#### 设置环境变量

你可以通过点击仪表板顶部栏中的 **Connect** 找到 `Project connect details`，并从 `Transaction pooler` 部分复制 URI。记得将密码占位符替换为你的实际数据库密码。

了解更多关于连接池的信息，请查阅 [文档](https://supabase.com/docs/guides/database/connecting-to-postgres#connection-pooler)。

更新你的 Edge Function 代码，以使用 `DATABASE_URL` 环境变量而不是 `SUPABASE_DB_URL`：

```typescript copy filename="supabase/functions/drizzle-tutorial/index.ts"
// imports

// const connectionString = Deno.env.get("SUPABASE_DB_URL")!;
const connectionString = Deno.env.get("DATABASE_URL")!;

// code
```

运行以下命令来设置环境变量：

```bash copy
supabase secrets set DATABASE_URL=<CONNECTION_STRING>
```

了解更多关于管理 Supabase Edge Functions 中的环境变量的信息，请查看 [文档](https://supabase.com/docs/guides/functions/secrets)。

#### 部署你的函数

通过运行以下命令部署你的函数：

```bash copy
supabase functions deploy drizzle-tutorial --no-verify-jwt
```
</Steps>

最后，你可以使用部署项目的 URL，导航到你创建的路由 `(e.g. /drizzle-tutorial)` 来访问你的 Edge Function。

Source: https://drizzle.zhcndoc.com/docs/tutorials/drizzle-with-vercel-edge-functions


import Prerequisites from "@mdx/Prerequisites.astro";
import Npm from '@mdx/Npm.astro';
import Steps from '@mdx/Steps.astro';
import Section from "@mdx/Section.astro";
import Callout from "@mdx/Callout.astro";

本教程演示如何在[Edge 运行时](https://vercel.com/docs/functions/runtimes/edge-runtime)中使用 Drizzle ORM 与 [Vercel Functions](https://vercel.com/docs/functions)。

<Prerequisites>
- 您应该安装了最新版本的 [Vercel CLI](https://vercel.com/docs/cli#)。
<Npm>
-g vercel
</Npm>

- 您应该已有一个现有的 Next.js 项目，或使用以下命令创建一个新的项目：

```bash copy
npx create-next-app@latest --typescript
```
- 您应该已安装 Drizzle ORM 和 [Drizzle kit](/docs/kit-overview)。您可以通过运行以下命令来安装它：
<Npm>
drizzle-orm
-D drizzle-kit
</Npm>
</Prerequisites>

<Callout type="warning">
如果您在安装过程中遇到依赖关系解析问题：

如果您不是在使用 React Native，可以通过强制安装 `--force` 或 `--legacy-peer-deps` 来解决此问题。如果您使用的是 React Native，则需要使用与您的 React Native 版本兼容的 React 的精确版本。
</Callout>

## 兼容 Edge 的驱动程序

在使用 Vercel Edge 函数与 Drizzle ORM 时，您必须使用兼容 Edge 的驱动程序，因为函数在 [Edge 运行时](https://vercel.com/docs/functions/runtimes/edge-runtime) 中运行，而不是在 Node.js 运行时，这样标准 Node.js API 存在一些限制。

您可以根据您的数据库方言选择以下驱动程序之一：

- [Neon 无服务器驱动程序](/docs/get-started-postgresql#neon) 允许您通过 HTTP 或 WebSockets 而不是 TCP 从无服务器和边缘环境查询您的 Neon Postgres 数据库。我们推荐使用此驱动程序来连接到 `Neon Postgres`。
- [Vercel Postgres 驱动程序](/docs/get-started-postgresql#vercel-postgres) 构建于 `Neon 无服务器驱动程序` 之上。我们推荐使用此驱动程序来连接到 `Vercel Postgres`。
- [PlanetScale 无服务器驱动程序](/docs/get-started-mysql#planetscale) 允许您访问任何 `MySQL` 客户端并通过 HTTP 连接执行查询，这通常不受云提供商的阻止。
- [libSQL 客户端](/docs/get-started-sqlite#turso) 允许您访问 [Turso](https://docs.turso.tech/introduction) 数据库。

## 导航

- 直接导航至 [Neon Postgres](/docs/tutorials/drizzle-with-vercel-edge-functions#neon-postgres) 部分。
- 直接导航至 [Vercel Postgres](/docs/tutorials/drizzle-with-vercel-edge-functions#vercel-postgres) 部分。
- 直接导航至 [PlanetScale](/docs/tutorials/drizzle-with-vercel-edge-functions#planetscale) 部分。
- 直接导航至 [Turso](/docs/tutorials/drizzle-with-vercel-edge-functions#turso) 部分。

### Neon Postgres

<Steps>
#### 安装 `@neondatabase/serverless` 驱动程序

安装 `@neondatabase/serverless` 驱动程序：

<Npm>
@neondatabase/serverless
</Npm>

#### 创建一个表

在 `src/db` 目录中创建一个 `schema.ts` 文件并声明一个表架构：

```typescript copy filename="src/db/schema.ts"
import { pgTable, serial, text } from "drizzle-orm/pg-core";

export const usersTable = pgTable('users_table', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  age: text('age').notNull(),
  email: text('email').notNull().unique(),
})
```

#### 设置 Drizzle 配置文件

**Drizzle 配置** - 由 [Drizzle Kit](/docs/kit-overview) 使用的配置文件，包含有关您的数据库连接、迁移文件夹和架构文件的所有信息。

在项目根目录创建 `drizzle.config.ts` 文件并添加以下内容：

```typescript copy filename="drizzle.config.ts"
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  schema: "./src/db/schema.ts",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.POSTGRES_URL!,
  },
});
```

在 `.env` 文件中配置您的数据库连接字符串：

```plaintext filename=".env"
POSTGRES_URL="postgres://[user]:[password]@[host]-[region].aws.neon.tech:5432/[db-name]?sslmode=[ssl-mode]"
```

#### 将更改应用到数据库

您可以使用 `drizzle-kit generate` 命令生成迁移，然后使用 `drizzle-kit migrate` 命令运行它们。

生成迁移：

```bash copy
npx drizzle-kit generate
```

这些迁移存储在 `drizzle` 目录中，如您的 `drizzle.config.ts` 中所指定。该目录将包含更新数据库架构所需的 SQL 文件和用于存储不同迁移阶段/schema 快照的 `meta` 文件夹。

生成迁移的示例：

```sql
CREATE TABLE IF NOT EXISTS "users_table" (
	"id" serial PRIMARY KEY NOT NULL,
	"name" text NOT NULL,
	"age" text NOT NULL,
	"email" text NOT NULL,
	CONSTRAINT "users_table_email_unique" UNIQUE("email")
);
```

运行迁移：

```bash copy
npx drizzle-kit migrate
```

或者，您可以使用 [Drizzle kit push 命令](/docs/kit-overview#prototyping-with-db-push) 将更改直接推送到数据库：

```bash copy
npx drizzle-kit push
```

<Callout type="warning">Push 命令适合需要快速测试新架构设计或更改的情况，允许在本地开发环境中快速迭代，而无需管理迁移文件的开销。</Callout>

#### 将 Drizzle ORM 连接到您的数据库

在 `src/db` 目录中创建一个 `index.ts` 文件并设置您的数据库配置：

```typescript copy filename="src/db/index.ts"
import { drizzle } from 'drizzle-orm/neon-serverless';


export const db = drizzle(process.env.POSTGRES_URL!)
```

#### 创建 API 路由

在 `src/app/api/hello` 目录中创建 `route.ts` 文件。有关如何编写函数的更多信息，请参见 [Functions API Reference](https://vercel.com/docs/functions/functions-api-reference) 和 [Vercel Functions Quickstart](https://vercel.com/docs/functions/quickstart)。

```ts copy filename="src/app/api/hello/route.ts"
import { db } from "@/db";
import { usersTable } from "@/db/schema";
import { NextResponse } from "next/server";

export const dynamic = 'force-dynamic'; // 默认为静态，除非读取请求
export const runtime = 'edge' // 指定运行时为边缘

export async function GET(request: Request) {
  const users = await db.select().from(usersTable)

  return NextResponse.json({ users, message: 'success' });
}
```

#### 在本地测试您的代码

运行 `next dev` 命令以启动本地开发服务器：

```bash copy
npx next dev
```

在浏览器中导航至您创建的路由 `(例如 /api/hello)`：

```plaintext
{
  "users": [],
  "message": "success"
}
```

#### 部署您的项目

在 [仪表板](https://vercel.com/new) 中创建一个新项目或运行 `vercel` 命令以部署您的项目：

```bash copy
vercel
```

添加 `POSTGRES_URL` 环境变量：

```bash copy
vercel env add POSTGRES_URL
```

重新部署您的项目以更新环境变量：

```bash copy
vercel
```
</Steps>

最后，您可以使用已部署项目的 URL 并导航至您创建的路由 `(例如 /api/hello)` 以访问您的边缘函数。

### Vercel Postgres

您可以在 [文档](/docs/get-started-postgresql#vercel-postgres) 中查看 Drizzle 与 Vercel Postgres 客户端的快速入门指南。

<Steps>
#### 安装 `@vercel/postgres` 驱动程序

安装 `@vercel/postgres` 驱动程序：

<Npm>
@vercel/postgres
</Npm>

#### 创建一个表

在 `src/db` 目录中创建一个 `schema.ts` 文件并声明一个表架构：

```typescript copy filename="src/db/schema.ts"
import { pgTable, serial, text } from "drizzle-orm/pg-core";

export const usersTable = pgTable('users_table', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  age: text('age').notNull(),
  email: text('email').notNull().unique(),
})
```

#### 设置 Drizzle 配置文件

**Drizzle 配置** - 由 [Drizzle Kit](/docs/kit-overview) 使用的配置文件，包含有关您的数据库连接、迁移文件夹和架构文件的所有信息。

在项目根目录创建 `drizzle.config.ts` 文件并添加以下内容：

```typescript copy filename="drizzle.config.ts"
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  schema: "./src/db/schema.ts",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.POSTGRES_URL!,
  },
});
```

在 `.env` 文件中配置您的数据库连接字符串：

```plaintext filename=".env"
POSTGRES_URL="postgres://[user]:[password]@[host]-[region].aws.neon.tech:5432/[db-name]?sslmode=[ssl-mode]"
```

#### 将更改应用到数据库

您可以使用 `drizzle-kit generate` 命令生成迁移，然后使用 `drizzle-kit migrate` 命令运行它们。

生成迁移：

```bash copy
npx drizzle-kit generate
```

这些迁移存储在 `drizzle` 目录中，如您的 `drizzle.config.ts` 中所指定。该目录将包含更新数据库架构所需的 SQL 文件和用于存储不同迁移阶段/schema 快照的 `meta` 文件夹。

生成迁移的示例：

```sql
CREATE TABLE IF NOT EXISTS "users_table" (
	"id" serial PRIMARY KEY NOT NULL,
	"name" text NOT NULL,
	"age" text NOT NULL,
	"email" text NOT NULL,
	CONSTRAINT "users_table_email_unique" UNIQUE("email")
);
```

运行迁移：

```bash copy
npx drizzle-kit migrate
```

或者，您可以使用 [Drizzle kit push 命令](/docs/kit-overview#prototyping-with-db-push) 将更改直接推送到数据库：

```bash copy
npx drizzle-kit push
```

<Callout type="warning">Push 命令适合需要快速测试新架构设计或更改的情况，允许在本地开发环境中快速迭代，而无需管理迁移文件的开销。</Callout>

#### 将 Drizzle ORM 连接到您的数据库

在 `src/db` 目录中创建一个 `index.ts` 文件并设置您的数据库配置：

```typescript copy filename="src/db/index.ts"
import { drizzle } from 'drizzle-orm/vercel-postgres';

export const db = drizzle()
```

#### 创建 API 路由

在 `src/app/api/hello` 目录中创建 `route.ts` 文件。有关如何编写函数的更多信息，请参见 [Functions API Reference](https://vercel.com/docs/functions/functions-api-reference) 和 [Vercel Functions Quickstart](https://vercel.com/docs/functions/quickstart)。

```ts copy filename="src/app/api/hello/route.ts"

import { db } from "@/db";
import { usersTable } from "@/db/schema";
import { NextResponse } from "next/server";

export const dynamic = 'force-dynamic'; // 默认为静态，除非读取请求
export const runtime = 'edge' // 指定运行时为边缘

export async function GET(request: Request) {
  const users = await db.select().from(usersTable)

  return NextResponse.json({ users, message: 'success' });
}
```

#### 在本地测试您的代码

运行 `next dev` 命令以启动本地开发服务器：

```bash copy
npx next dev
```

在浏览器中导航至您创建的路由 `(例如 /api/hello)`：

```plaintext
{
  "users": [],
  "message": "success"
}
```

#### 部署您的项目

在 [仪表板](https://vercel.com/new) 中创建一个新项目或运行 `vercel` 命令以部署您的项目：

```bash copy
vercel
```

添加 `POSTGRES_URL` 环境变量：

```bash copy
vercel env add POSTGRES_URL
```

重新部署您的项目以更新环境变量：

```bash copy
vercel
```
</Steps>

最后，您可以使用已部署项目的 URL 并导航至您创建的路由 `(例如 /api/hello)` 以访问您的边缘函数。

### PlanetScale

在本教程中我们使用 [PlanetScale MySQL](https://planetscale.com)。

<Steps>
#### 安装 `@planetscale/database` 驱动程序

安装 `@planetscale/database` 驱动程序：

<Npm>
@planetscale/database
</Npm>

#### 创建一个表

在 `src/db` 目录中创建一个 `schema.ts` 文件并声明一个表架构：

```typescript copy filename="src/db/schema.ts"
import { mysqlTable, serial, text } from "drizzle-orm/mysql-core";

export const usersTable = mysqlTable('users_table', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  age: text('age').notNull(),
  email: text('email').notNull().unique(),
})
```

#### 设置 Drizzle 配置文件

**Drizzle 配置** - 由 [Drizzle Kit](/docs/kit-overview) 使用的配置文件，包含有关您的数据库连接、迁移文件夹和架构文件的所有信息。

在项目根目录创建 `drizzle.config.ts` 文件并添加以下内容：

```typescript copy filename="drizzle.config.ts"
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  schema: "./src/db/schema.ts",
  dialect: "mysql",
  dbCredentials: {
    url: process.env.MYSQL_URL!,
  },
});
```

在 `.env` 文件中配置您的数据库连接字符串：

```plaintext filename=".env"
MYSQL_URL="mysql://[user]:[password]@[host].[region].psdb.cloud/[db-name]?ssl={'rejectUnauthorized':[ssl-rejectUnauthorized]}"
```

#### 将更改应用到数据库

您可以使用 `drizzle-kit generate` 命令生成迁移，然后使用 `drizzle-kit migrate` 命令运行它们。

生成迁移：

```bash copy
npx drizzle-kit generate
```

这些迁移存储在 `drizzle` 目录中，如您的 `drizzle.config.ts` 中所指定。该目录将包含更新数据库架构所需的 SQL 文件和用于存储不同迁移阶段/schema 快照的 `meta` 文件夹。

生成迁移的示例：

```sql
CREATE TABLE `users_table` (
	`id` serial AUTO_INCREMENT NOT NULL,
	`name` text NOT NULL,
	`age` text NOT NULL,
	`email` text NOT NULL,
	CONSTRAINT `users_table_id` PRIMARY KEY(`id`),
	CONSTRAINT `users_table_email_unique` UNIQUE(`email`)
);
```

运行迁移：

```bash copy
npx drizzle-kit migrate
```

或者，您可以使用 [Drizzle kit push 命令](/docs/kit-overview#prototyping-with-db-push) 将更改直接推送到数据库：

```bash copy
npx drizzle-kit push
```

<Callout type="warning">Push 命令适合需要快速测试新架构设计或更改的情况，允许在本地开发环境中快速迭代，而无需管理迁移文件的开销。</Callout>

#### 将 Drizzle ORM 连接到您的数据库

在 `src/db` 目录中创建一个 `index.ts` 文件并设置您的数据库配置：

```typescript copy filename="src/db/index.ts"
import { drizzle } from "drizzle-orm/planetscale-serverless";

export const db = drizzle(process.env.MYSQL_URL!)
```

#### 创建 API 路由

在 `src/app/api/hello` 目录中创建 `route.ts` 文件。有关如何编写函数的更多信息，请参见 [Functions API Reference](https://vercel.com/docs/functions/functions-api-reference) 和 [Vercel Functions Quickstart](https://vercel.com/docs/functions/quickstart)。

```ts copy filename="src/app/api/hello/route.ts"
import { db } from "@/app/db/db";
import { usersTable } from "@/app/db/schema";
import { NextResponse } from "next/server";

export const dynamic = 'force-dynamic'; // 默认为静态，除非读取请求
export const runtime = 'edge' // 指定运行时为边缘

export async function GET(request: Request) {
  const users = await db.select().from(usersTable)

  return NextResponse.json({ users, message: 'success' });
}
```

#### 在本地测试您的代码

运行 `next dev` 命令以启动本地开发服务器：

```bash copy
npx next dev
```

在浏览器中导航至您创建的路由 `(例如 /api/hello)`：

```plaintext
{
  "users": [],
  "message": "success"
}
```

#### 部署您的项目

在 [仪表板](https://vercel.com/new) 中创建一个新项目或运行 `vercel` 命令以部署您的项目：

```bash copy
vercel
```

添加 `MYSQL_URL` 环境变量：

```bash copy
vercel env add MYSQL_URL
```

重新部署您的项目以更新环境变量：

```bash copy
vercel
```
</Steps>

最后，您可以使用已部署项目的 URL 并导航至您创建的路由 `(例如 /api/hello)` 以访问您的边缘函数。

### Turso

您可以在文档中查看 Drizzle 与 Turso 的 [快速入门指南](/docs/get-started-sqlite#turso) 或 [教程](/docs/tutorials/drizzle-with-turso)。

<Steps>
#### 安装 `@libsql/client` 驱动程序

安装 `@libsql/client` 驱动程序：

<Npm>
@libsql/client
</Npm>

#### 创建一个表

在 `src/db` 目录中创建一个 `schema.ts` 文件并声明一个表架构：

```typescript copy filename="src/db/schema.ts"
import { integer, sqliteTable, text } from "drizzle-orm/sqlite-core";

export const usersTable = sqliteTable('users_table', {
  id: integer('id').primaryKey(),
  name: text('name').notNull(),
  age: text('age').notNull(),
  email: text('email').notNull().unique(),
})
```

#### 设置 Drizzle 配置文件

**Drizzle 配置** - 由 [Drizzle Kit](/docs/kit-overview) 使用的配置文件，包含有关您的数据库连接、迁移文件夹和架构文件的所有信息。

在项目根目录创建 `drizzle.config.ts` 文件并添加以下内容：

```typescript copy filename="drizzle.config.ts"
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  schema: "./src/db/schema.ts",
  dialect: "turso",
  dbCredentials: {
    url: process.env.TURSO_CONNECTION_URL!,
    authToken: process.env.TURSO_AUTH_TOKEN!,
  },
});
```

在 `.env` 文件中配置您的数据库连接字符串和身份验证令牌：

```plaintext filename=".env"
TURSO_CONNECTION_URL="libsql://[db-name].turso.io"
TURSO_AUTH_TOKEN="[auth-token]"
```

#### 将更改应用到数据库

您可以使用 `drizzle-kit generate` 命令生成迁移，然后使用 `drizzle-kit migrate` 命令运行它们。

生成迁移：

```bash copy
npx drizzle-kit generate
```

这些迁移存储在 `drizzle` 目录中，如您的 `drizzle.config.ts` 中所指定。该目录将包含更新数据库架构所需的 SQL 文件和用于存储不同迁移阶段/schema 快照的 `meta` 文件夹。

生成迁移的示例：

```sql
CREATE TABLE `users_table` (
	`id` integer PRIMARY KEY NOT NULL,
	`name` text NOT NULL,
	`age` text NOT NULL,
	`email` text NOT NULL
);
--> statement-breakpoint
CREATE UNIQUE INDEX `users_table_email_unique` ON `users_table` (`email`);
```

运行迁移：

```bash copy
npx drizzle-kit migrate
```

或者，您可以使用 [Drizzle kit push 命令](/docs/kit-overview#prototyping-with-db-push) 将更改直接推送到数据库：

```bash copy
npx drizzle-kit push
```

<Callout type="warning">Push 命令适合需要快速测试新架构设计或更改的情况，允许在本地开发环境中快速迭代，而无需管理迁移文件的开销。</Callout>

#### 将 Drizzle ORM 连接到您的数据库

在 `src/db` 目录中创建一个 `index.ts` 文件并设置您的数据库配置：

```typescript copy filename="src/db/index.ts"
import { drizzle } from 'drizzle-orm/libsql';

export const db = drizzle({ connection: {
  url: process.env.TURSO_CONNECTION_URL!,
  authToken: process.env.TURSO_AUTH_TOKEN!,
}})
```

#### 创建 API 路由

在 `src/app/api/hello` 目录中创建 `route.ts` 文件。有关如何编写函数的更多信息，请参见 [Functions API Reference](https://vercel.com/docs/functions/functions-api-reference) 和 [Vercel Functions Quickstart](https://vercel.com/docs/functions/quickstart)。

```ts copy filename="src/app/api/hello/route.ts"
import { db } from "@/app/db/db";
import { usersTable } from "@/app/db/schema";
import { NextResponse } from "next/server";

export const dynamic = 'force-dynamic'; // 默认为静态，除非读取请求
export const runtime = 'edge' // 指定运行时为边缘

export async function GET(request: Request) {
  const users = await db.select().from(usersTable)

  return NextResponse.json({ users, message: 'success' });
}
```

#### 在本地测试您的代码

运行 `next dev` 命令以启动本地开发服务器：

```bash copy
npx next dev
```

在浏览器中导航至您创建的路由 `(例如 /api/hello)`：

```plaintext
{
  "users": [],
  "message": "success"
}
```

#### 部署您的项目

在 [仪表板](https://vercel.com/new) 中创建一个新项目或运行 `vercel` 命令以部署您的项目：

```bash copy
vercel
```

添加 `TURSO_CONNECTION_URL` 环境变量：

```bash copy
vercel env add TURSO_CONNECTION_URL
```

添加 `TURSO_AUTH_TOKEN` 环境变量：

```bash copy
vercel env add TURSO_AUTH_TOKEN
```

重新部署您的项目以更新环境变量：

```bash copy
vercel
```
</Steps>

最后，您可以使用已部署项目的 URL 并导航至您创建的路由 `(例如 /api/hello)` 以访问您的边缘函数。


Source: https://drizzle.zhcndoc.com/docs/tutorials/drizzle-with-neon


import Prerequisites from "@mdx/Prerequisites.astro";
import Npm from "@mdx/Npm.astro";
import Steps from "@mdx/Steps.astro";
import Section from "@mdx/Section.astro";
import Callout from "@mdx/Callout.astro";

本教程演示了如何使用 Drizzle ORM 与 [Neon Postgres](https://neon.tech/) 数据库。如果您尚未拥有 Neon 账户，请 [在此处注册](https://neon.tech)。

<Prerequisites>  
  - 您应该已安装 Drizzle ORM 和 [Drizzle kit](/docs/kit-overview)。您可以通过运行以下命令来完成此操作：
  <Npm>
    drizzle-orm 
    -D drizzle-kit
  </Npm>

  - 您还应该安装 [Neon 无服务器驱动](https://neon.tech/docs/serverless/serverless-driver)。 
  <Npm>
    @neondatabase/serverless
  </Npm>
  
  - 您应该已安装 `dotenv` 包来管理环境变量。 
  <Npm>
    dotenv
  </Npm>  
</Prerequisites>

## 设置 Neon 和 Drizzle ORM

<Steps>
#### 创建新 Neon 项目

登录到 [Neon 控制台](https://console.neon.tech/app/projects) 并导航到项目部分。选择一个项目或点击 `新建项目` 按钮以创建一个新项目。

您的 Neon 项目带有一个可即用的 Postgres 数据库，名为 `neondb`。我们将在本教程中使用它。

#### 设置连接字符串变量

导航到项目控制台中的 **连接详细信息** 部分以找到您的数据库连接字符串。它应该类似于以下内容：

```bash
postgres://username:password@ep-cool-darkness-123456.us-east-2.aws.neon.tech/neondb
```

将 `DATABASE_URL` 环境变量添加到您的 `.env` 或 `.env.local` 文件中，您将使用它连接到 Neon 数据库。

```text copy
DATABASE_URL=NEON_DATABASE_CONNECTION_STRING
```

#### 将 Drizzle ORM 连接到您的数据库 

创建一个 `db.ts` 文件并设置您的数据库配置：

```typescript copy filename="src/db.ts"
import { drizzle } from "drizzle-orm/neon-http";
import { neon } from "@neondatabase/serverless";
import { config } from "dotenv";

config({ path: ".env" }); // 或者 .env.local

const sql = neon(process.env.DATABASE_URL!);
export const db = drizzle({ client: sql });
```

#### 创建表

创建一个 `schema.ts` 文件并声明您的表：

```typescript copy filename="src/schema.ts"
import { integer, pgTable, serial, text, timestamp } from 'drizzle-orm/pg-core';

export const usersTable = pgTable('users_table', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  age: integer('age').notNull(),
  email: text('email').notNull().unique(),
});

export const postsTable = pgTable('posts_table', {
  id: serial('id').primaryKey(),
  title: text('title').notNull(),
  content: text('content').notNull(),
  userId: integer('user_id')
    .notNull()
    .references(() => usersTable.id, { onDelete: 'cascade' }),
  createdAt: timestamp('created_at').notNull().defaultNow(),
  updatedAt: timestamp('updated_at')
    .notNull()
    .$onUpdate(() => new Date()),
});

export type InsertUser = typeof usersTable.$inferInsert;
export type SelectUser = typeof usersTable.$inferSelect;

export type InsertPost = typeof postsTable.$inferInsert;
export type SelectPost = typeof postsTable.$inferSelect;
```

#### 设置 Drizzle 配置文件

**Drizzle 配置** - 一个由 [Drizzle Kit](/docs/kit-overview) 使用的配置文件，包含有关您数据库连接、迁移文件夹和模式文件的所有信息。

在项目根目录中创建一个 `drizzle.config.ts` 文件并添加以下内容：

```typescript copy filename="drizzle.config.ts"
import { config } from 'dotenv';
import { defineConfig } from "drizzle-kit";

config({ path: '.env' });

export default defineConfig({
  schema: "./src/schema.ts",
  out: "./migrations",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
});
```

#### 将更改应用到数据库

您可以使用 `drizzle-kit generate` 命令生成迁移，然后使用 `drizzle-kit migrate` 命令运行它们。

生成迁移：

```bash copy
npx drizzle-kit generate
```

这些迁移将存储在您 `drizzle.config.ts` 中指定的 `drizzle/migrations` 目录中。该目录将包含更新您的数据库模式所需的 SQL 文件，并包含一个 `meta` 文件夹，用于存储不同迁移阶段的模式快照。

生成的迁移示例：

```sql
CREATE TABLE IF NOT EXISTS "posts_table" (
	"id" serial PRIMARY KEY NOT NULL,
	"title" text NOT NULL,
	"content" text NOT NULL,
	"user_id" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp NOT NULL
);
--> statement-breakpoint
CREATE TABLE IF NOT EXISTS "users_table" (
	"id" serial PRIMARY KEY NOT NULL,
	"name" text NOT NULL,
	"age" integer NOT NULL,
	"email" text NOT NULL,
	CONSTRAINT "users_table_email_unique" UNIQUE("email")
);
--> statement-breakpoint
DO $$ BEGIN
 ALTER TABLE "posts_table" ADD CONSTRAINT "posts_table_user_id_users_table_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."users_table"("id") ON DELETE cascade ON UPDATE no action;
EXCEPTION
 WHEN duplicate_object THEN null;
END $$;
```

运行迁移：

```bash copy
npx drizzle-kit migrate
```

或者，您可以使用 [Drizzle kit push 命令](/docs/kit-overview#prototyping-with-db-push) 直接将更改推送到数据库：

```bash copy
npx drizzle-kit push
```

<Callout type="warning">推送命令非常适合快速测试新模式设计或在本地开发环境中的更改，允许快速迭代而无需管理迁移文件的开销。</Callout>

</Steps>

### 基本文件结构

这是项目的基本文件结构。在 `src/db` 目录中，我们有与数据库相关的文件，包括在 `db.ts` 中的连接，在 `schema.ts` 中的模式定义，以及在 `migrate.ts` 文件中的迁移脚本，该文件负责应用存储在 `migrations` 目录中的迁移。

```plaintext
📦 <项目根目录>
 ├ 📂 src
 │  ├ 📜 db.ts
 │  └ 📜 schema.ts
 ├ 📂 migrations
 │  ├ 📂 meta
 │  │  ├ 📜 _journal.json
 │  │  └ 📜 0000_snapshot.json
 │  └ 📜 0000_dry_richard_fisk.sql
 ├ 📜 .env
 ├ 📜 drizzle.config.ts
 ├ 📜 package.json
 └ 📜 tsconfig.json
```

## 查询示例

例如，我们可以创建 `src/queries` 文件夹，并为每个操作（插入、选择、更新、删除）创建单独的文件。

#### 插入数据

有关插入查询的更多信息，请参阅 [文档](/docs/insert)。

```typescript copy filename="src/queries/insert.ts" {4, 8}
import { db } from '../db';
import { InsertPost, InsertUser, postsTable, usersTable } from '../schema';

export async function createUser(data: InsertUser) {
  await db.insert(usersTable).values(data);
}

export async function createPost(data: InsertPost) {
  await db.insert(postsTable).values(data);
}
```

#### 选择数据

有关选择查询的更多信息，请参阅 [文档](/docs/select)。

```typescript copy filename="src/queries/select.ts" {5, 16, 41}
import { asc, between, count, eq, getTableColumns, sql } from 'drizzle-orm';
import { db } from '../db';
import { SelectUser, usersTable, postsTable } from '../schema';

export async function getUserById(id: SelectUser['id']): Promise<
  Array<{
    id: number;
    name: string;
    age: number;
    email: string;
  }>
> {
  return db.select().from(usersTable).where(eq(usersTable.id, id));
}

export async function getUsersWithPostsCount(
  page = 1,
  pageSize = 5,
): Promise<
  Array<{
    postsCount: number;
    id: number;
    name: string;
    age: number;
    email: string;
  }>
> {
  return db
    .select({
      ...getTableColumns(usersTable),
      postsCount: count(postsTable.id),
    })
    .from(usersTable)
    .leftJoin(postsTable, eq(usersTable.id, postsTable.userId))
    .groupBy(usersTable.id)
    .orderBy(asc(usersTable.id))
    .limit(pageSize)
    .offset((page - 1) * pageSize);
}

export async function getPostsForLast24Hours(
  page = 1,
  pageSize = 5,
): Promise<
  Array<{
    id: number;
    title: string;
  }>
> {
  return db
    .select({
      id: postsTable.id,
      title: postsTable.title,
    })
    .from(postsTable)
    .where(between(postsTable.createdAt, sql`now() - interval '1 day'`, sql`now()`))
    .orderBy(asc(postsTable.title), asc(postsTable.id))
    .limit(pageSize)
    .offset((page - 1) * pageSize);
}
```

或者，您可以使用 [关系查询语法](/docs/rqb)。

#### 更新数据

有关更新查询的更多信息，请参阅 [文档](/docs/update)。

```typescript copy filename="src/queries/update.ts" {5}
import { eq } from 'drizzle-orm';
import { db } from '../db';
import { SelectPost, postsTable } from '../schema';

export async function updatePost(id: SelectPost['id'], data: Partial<Omit<SelectPost, 'id'>>) {
  await db.update(postsTable).set(data).where(eq(postsTable.id, id));
}
```

#### 删除数据

有关删除查询的更多信息，请参阅 [文档](/docs/delete)。

```typescript copy filename="src/queries/delete.ts" {5}
import { db } from '../db';
import { eq } from 'drizzle-orm';
import { SelectUser, usersTable } from '../schema';

export async function deleteUser(id: SelectUser['id']) {
  await db.delete(usersTable).where(eq(usersTable.id, id));
}
```


Source: https://drizzle.zhcndoc.com/docs/tutorials/drizzle-with-nile


import Prerequisites from "@mdx/Prerequisites.astro";
import Npm from '@mdx/Npm.astro';
import Steps from '@mdx/Steps.astro';
import Section from "@mdx/Section.astro";
import Callout from '@mdx/Callout.astro';
import TransferCode from '@mdx/get-started/TransferCode.mdx';
import ApplyChanges from '@mdx/get-started/ApplyChanges.mdx';
import RunFile from '@mdx/get-started/RunFile.mdx';

本教程演示如何使用 Drizzle ORM 与 [Nile 数据库](https://thenile.dev)。Nile 是为多租户应用程序重新设计的 Postgres。

本教程将展示如何使用 Drizzle 与 Nile 的虚拟租户数据库来开发一个安全、可扩展的多租户应用程序。

我们将逐步构建这个示例应用程序。如果您想查看完整的示例，可以查看它的 [Github 仓库](https://github.com/niledatabase/niledatabase/tree/main/examples/quickstart/drizzle)。

<Prerequisites>
- 您应该已经安装了 Drizzle ORM 和 [Drizzle kit](/docs/kit-overview)。您可以通过运行以下命令来完成安装：
<Npm>
drizzle-orm
-D drizzle-kit
</Npm>
- 您应该安装 `dotenv` 包以管理环境变量。有关此包的更多信息，请阅读 [这里](https://www.npmjs.com/package/dotenv)
<Npm>
  dotenv
</Npm>
- 您应该安装 `node-postgres` 包以连接到 Postgres 数据库。有关此包的更多信息，请阅读 [这里](https://www.npmjs.com/package/node-postgres)
<Npm>
  node-postgres
</Npm>
- 您应该安装 `express` 包以作为 Web 框架。有关 express 的更多信息，请阅读 [这里](https://expressjs.com/)
<Npm>
  express
</Npm>

- 本指南使用 [AsyncLocalStorage](https://nodejs.org/api/async_context.html) 来管理租户上下文。如果您的框架或运行时不支持 `AsyncLocalStorage`，您可以参考 [Drizzle\<\>Nile](../connect-nile) 文档以获取替代选项。
</Prerequisites>

## 设置 Nile 和 Drizzle ORM

<Steps>
#### 注册 Nile 并创建数据库

如果您还没有，请注册 [Nile](https://console.thenile.dev)，并按照应用说明创建一个新数据库。

#### 获取数据库连接字符串

在左侧边栏中，选择“设置”选项，点击 Postgres 徽标，然后点击“生成凭证”。复制连接字符串并将其添加到项目中的 `.env` 文件：

```plaintext copy
NILEDB_URL=postgres://youruser:yourpassword@us-west-2.db.thenile.dev:5432:5432/your_db_name
```

#### 将 Drizzle ORM 连接到您的数据库

在 `src/db` 目录下创建一个 `db.ts` 文件，并设置数据库配置：

```typescript copy filename="src/db/db.ts"
import { drizzle } from 'drizzle-orm/node-postgres';
import dotenv from "dotenv/config";
import { sql } from "drizzle-orm";
import { AsyncLocalStorage } from "async_hooks";

export const db = drizzle(process.env.NILEDB_URL);
export const tenantContext = new AsyncLocalStorage<string | undefined>();

export function tenantDB<T>(cb: (tx: any) => T | Promise<T>): Promise<T> {
  return db.transaction(async (tx) => {
    const tenantId = tenantContext.getStore();
    console.log("执行带租户的查询: " + tenantId);
    // 如果有租户 ID，在事务上下文中设置它
    if (tenantId) {
      await tx.execute(sql`set local nile.tenant_id = '${sql.raw(tenantId)}'`);
    }

    return cb(tx);
  }) as Promise<T>;
}
```

#### 设置 Drizzle 配置文件

**Drizzle 配置** - 此配置文件由 [Drizzle Kit](/docs/kit-overview) 使用，包含有关数据库连接、迁移文件夹和模式文件的所有信息。

在项目的根目录下创建一个 `drizzle.config.ts` 文件，并添加以下内容：

```typescript copy filename="drizzle.config.ts"
import 'dotenv/config';
import { defineConfig } from 'drizzle-kit';
export default defineConfig({
  out: './drizzle',
  schema: './src/db/schema.ts',
  dialect: 'postgresql',
  dbCredentials: {
    url: process.env.NILEDB_URL!,
  },
});
```

#### 解析 Nile 数据库

Nile 数据库具有内置表。其中最重要的是 `tenants` 表，用于创建和管理租户。
为了能在我们的应用程序中使用此表，我们将使用 Drizzle Kit CLI 生成包含此架构的模式文件。

```bash copy
npx drizzle-kit pull
```

解析的结果将是一个 `schema.ts` 文件、一个包含数据库模式快照的 `meta` 文件夹、一个带有迁移的 sql 文件和一个用于 [关系查询](/docs/rqb) 的 `relations.ts` 文件。

<TransferCode/>

这是生成的 `schema.ts` 文件示例：

```typescript copy filename="src/db/schema.ts"
// 通过解析生成的表模式
import { pgTable, uuid, text, timestamp, varchar, vector, boolean } from "drizzle-orm/pg-core"
import { sql } from "drizzle-orm"

export const tenants = pgTable("tenants", {
	id: uuid().default(sql`public.uuid_generate_v7()`).primaryKey().notNull(),
	name: text(),
	created: timestamp({ mode: 'string' }).default(sql`LOCALTIMESTAMP`).notNull(),
	updated: timestamp({ mode: 'string' }).default(sql`LOCALTIMESTAMP`).notNull(),
	deleted: timestamp({ mode: 'string' }),
});
```

#### 创建附加表

除了内置表之外，我们的应用程序还需要一些表来存储数据。我们将它们添加到之前生成的 `src/db/schema.ts` 中，因此该文件将如下所示：

```typescript copy filename="src/db/schema.ts"
// 通过解析生成的表模式
import { pgTable, uuid, text, timestamp, varchar, vector, boolean } from "drizzle-orm/pg-core"
import { sql } from "drizzle-orm"

export const tenants = pgTable("tenants", {
	id: uuid().default(sql`public.uuid_generate_v7()`).primaryKey().notNull(),
	name: text(),
	created: timestamp({ mode: 'string' }).default(sql`LOCALTIMESTAMP`).notNull(),
	updated: timestamp({ mode: 'string' }).default(sql`LOCALTIMESTAMP`).notNull(),
	deleted: timestamp({ mode: 'string' }),
});

export const todos = pgTable("todos", {
	id: uuid().defaultRandom(),
	tenantId: uuid("tenant_id"),
	title: varchar({ length: 256 }),
	estimate: varchar({ length: 256 }),
	embedding: vector({ dimensions: 3 }),
	complete: boolean(),
});
```

#### 将更改应用到数据库

<ApplyChanges />

#### 初始化 web 应用

现在我们已经设置 Drizzle 连接到 Nile，并且我们的模式已就绪，我们可以在多租户 Web 应用程序中使用它们。
在此示例中，我们使用 Express 作为 Web 框架，尽管 Nile 和 Drizzle 可以与任何 Web 框架一起使用。

为了保持示例简单，我们将在单个文件 `src/app.ts` 中实现 Web 应用。我们将通过初始化 Web 应用开始：

```typescript copy filename="src/app.ts"
import express from "express";
import { tenantDB, tenantContext, db } from "./db/db";
import {
  tenants as tenantSchema,
  todos as todoSchema,
} from "./db/schema";
import { eq } from "drizzle-orm";

const PORT = process.env.PORT || 3001;

const app = express();
app.listen(PORT, () => console.log(`服务器正在端口 ${PORT} 上运行`));
app.use(express.json());
```

#### 初始化租户感知中间件

接下来，我们将在示例中添加中间件。此中间件从路径参数中获取租户 ID，并将其存储在 `AsyncLocalStorage` 中。
我们在 `src/db/index.ts` 中创建的 `tenantDB` 包装器使用该租户 ID 在执行查询时设置 `nile.tenant_id`，这确保了一旦查询将针对该租户的虚拟数据库执行。

```typescript copy filename="src/app.ts"
// 根据 URL 参数在上下文中设置租户 ID
app.use('/api/tenants/:tenantId/*', (req, res, next) => {
  const tenantId = req.params.tenantId;
  console.log("设置上下文为租户: " + tenantId);
  tenantContext.run(tenantId, next);
});
```

<Callout>
该示例从路径参数获取租户 ID，但也可以通过 `x-tenant-id` 的标头或 cookie 来设置租户 ID。
</Callout>

#### 添加路由

最后，我们需要添加一些路由，用于创建和列出租户及待办事项。注意我们如何使用 `tenantDB` 包装器来连接租户的虚拟数据库。
同样注意，在 `app.get("/api/tenants/:tenantId/todos"` 中，我们不需要在查询中指定 `where tenant_id=...`。
这恰恰是因为我们路由到该租户的数据库，且查询不能返回其他租户的数据。

```typescript copy filename="src/app.ts" {6,20,39,58,62,75,83}
// 创建新租户
app.post("/api/tenants", async (req, res) => {
  try {
    const name = req.body.name;
    var tenants: any = null;
    tenants = await tenantDB(async (tx) => {
        return await tx.insert(tenantSchema).values({ name }).returning();
    });
    res.json(tenants);
  } catch (error: any) {
    console.log("创建租户时出错: " + error.message);
    res.status(500).json({message: "内部服务器错误",});
  }
});

// 返回租户列表
app.get("/api/tenants", async (req, res) => {
  let tenants: any = [];
  try {
      tenants = await tenantDB(async (tx) => {
        return await tx.select().from(tenantSchema);
      });
    res.json(tenants);
  } catch (error: any) {
    console.log("列出租户时出错: " + error.message);
    res.status(500).json({message: "内部服务器错误",});
  }
});

// 为租户添加新任务
app.post("/api/tenants/:tenantId/todos", async (req, res) => {
  try {
    const { title, complete } = req.body;
    if (!title) {
      res.status(400).json({message: "未提供任务标题",});
    }
    const tenantId = req.params.tenantId;

    const newTodo = await tenantDB(async (tx) => {
      return await tx
        .insert(todoSchema)
        .values({ tenantId, title, complete })
        .returning();
    });
    // 返回时不包括 embedding 向量，因为它很大且无用
    res.json(newTodo);
  } catch (error: any) {
    console.log("添加任务时出错: " + error.message);
    res.status(500).json({message: "内部服务器错误",});
  }
});

// 更新租户的任务
// 因为我们在上下文中有租户，所以不需要 where 子句
app.put("/api/tenants/:tenantId/todos", async (req, res) => {
  try {
    const { id, complete } = req.body;
    await tenantDB(async (tx) => {
      return await tx
        .update(todoSchema)
        .set({ complete })
        .where(eq(todoSchema.id, id));
    });
    res.sendStatus(200);
  } catch (error: any) {
    console.log("更新任务时出错: " + error.message);
    res.status(500).json({message: "内部服务器错误",});
  }
});

// 获取租户的所有任务
app.get("/api/tenants/:tenantId/todos", async (req, res) => {
  try {
    // 这里不需要“where”子句，因为我们在上下文中设置了租户 ID
    const todos = await tenantDB(async (tx) => {
      return await tx
        .select({
          id: todoSchema.id,
          tenant_id: todoSchema.tenantId,
          title: todoSchema.title,
          estimate: todoSchema.estimate,
        })
        .from(todoSchema);
    });
    res.json(todos);
  } catch (error: any) {
    console.log("列出任务时出错: " + error.message);
    res.status(500).json({message: error.message,});
  }
});
```

#### 尝试一下！

您现在可以运行您的新 Web 应用：

```bash copy
npx tsx src/app.ts
```

并使用 `curl` 尝试您刚刚创建的路由：

```bash
# 创建一个租户
curl --location --request POST 'localhost:3001/api/tenants' \
--header 'Content-Type: application/json' \
--data-raw '{"name":"我的第一个客户"}'

# 获取租户列表
curl  -X GET 'http://localhost:3001/api/tenants'

# 创建待办事项（请务必在 URL 中使用真实的租户 ID）
curl  -X POST \
  'http://localhost:3001/api/tenants/108124a5-2e34-418a-9735-b93082e9fbf2/todos' \
  --header 'Content-Type: application/json' \
  --data-raw '{"title": "喂猫", "complete": false}'

# 列出租户的待办事项（请务必在 URL 中使用真实的租户 ID）
curl  -X GET \
  'http://localhost:3001/api/tenants/108124a5-2e34-418a-9735-b93082e9fbf2/todos'
```
</Steps>

## 项目文件结构

这是项目的文件结构。在 `src/db` 目录下，我们有与数据库相关的文件，包括 `db.ts` 中的连接和 `schema.ts` 中的模式定义。
由迁移和解析生成的文件位于 `./drizzle` 中。

```plaintext
📦 <项目根目录>
 ├ 📂 src
 │   ├ 📂 db
 │   │  ├ 📜 db.ts
 │   │  └ 📜 schema.ts
 │   └ 📜 app.ts
 ├ 📂 drizzle
 │   ├ 📂 meta
 │   │  ├ 📜 _journal.json
 │   │  └ 📜 0000_snapshot.json
 │   ├ 📜 relations.ts
 │   ├ 📜 schema.ts
 │   └ 📜 0000_watery_spencer_smythe.sql
 ├ 📜 .env
 ├ 📜 drizzle.config.ts
 └ 📜 package.json
```

Source: https://drizzle.zhcndoc.com/docs/tutorials/drizzle-with-supabase


import Prerequisites from "@mdx/Prerequisites.astro";
import Npm from '@mdx/Npm.astro';
import Steps from '@mdx/Steps.astro';
import Section from "@mdx/Section.astro";
import Callout from '@mdx/Callout.astro';

本教程演示了如何使用 Drizzle ORM 连接 [Supabase 数据库](https://supabase.com/docs/guides/database/overview)。每个 Supabase 项目都附带一个完整的 [Postgres](https://www.postgresql.org/) 数据库。

<Prerequisites>
- 您应该已安装 Drizzle ORM 和 [Drizzle kit](/docs/kit-overview)。您可以通过运行以下命令来完成此操作：
<Npm>
drizzle-orm
-D drizzle-kit
</Npm>
- 您应该已安装 `dotenv` 包以管理环境变量。有关该包的更多信息，请[点击此处](https://www.npmjs.com/package/dotenv)。
<Npm>
  dotenv
</Npm>

- 您应该已安装 `postgres` 包以连接到 Postgres 数据库。有关该包的更多信息，请[点击此处](https://www.npmjs.com/package/postgres)。
<Npm>
  postgres
</Npm>

- 您还应安装最新版本的 [Supabase CLI](https://supabase.com/docs/guides/cli/getting-started#installing-the-supabase-cli)（仅在您想使用 Supabase CLI 进行迁移时）。
</Prerequisites>

请查看 [Supabase 文档](https://supabase.com/docs/guides/database/connecting-to-postgres#connecting-with-drizzle)，了解如何使用 Drizzle ORM 连接到数据库。

## 设置 Supabase 和 Drizzle ORM

<Steps>
#### 创建一个新的 Supabase 项目

您可以在 [仪表板](https://supabase.com/dashboard) 中创建新的 Supabase 项目，或通过此 [链接](https://database.new/) 创建。

#### 设置连接字符串变量

导航到 [数据库设置](https://supabase.com/dashboard/project/_/settings/database)，并从 `连接字符串` 部分复制 URI。确保使用 `连接池`。请记得用您的实际数据库密码替换密码占位符。

将 `DATABASE_URL` 变量添加到您的 `.env` 或 `.env.local` 文件中。

```plaintext copy
DATABASE_URL=<YOUR_DATABASE_URL>
```

有关连接池和池模式的更多信息，请查看 [文档](https://supabase.com/docs/guides/database/connecting-to-postgres#connection-pooler)。

#### 将 Drizzle ORM 连接到您的数据库

在 `src/db` 目录中创建一个 `index.ts` 文件，并设置您的数据库配置：

```typescript copy filename="src/db/index.ts"
import { config } from 'dotenv';
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';

config({ path: '.env' }); // 或 .env.local

const client = postgres(process.env.DATABASE_URL!);
export const db = drizzle({ client });
```

#### 创建表

在 `src/db` 目录中创建一个 `schema.ts` 文件，并声明您的表：

```typescript copy filename="src/db/schema.ts"
import { integer, pgTable, serial, text, timestamp } from 'drizzle-orm/pg-core';

export const usersTable = pgTable('users_table', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  age: integer('age').notNull(),
  email: text('email').notNull().unique(),
});

export const postsTable = pgTable('posts_table', {
  id: serial('id').primaryKey(),
  title: text('title').notNull(),
  content: text('content').notNull(),
  userId: integer('user_id')
    .notNull()
    .references(() => usersTable.id, { onDelete: 'cascade' }),
  createdAt: timestamp('created_at').notNull().defaultNow(),
  updatedAt: timestamp('updated_at')
    .notNull()
    .$onUpdate(() => new Date()),
});

export type InsertUser = typeof usersTable.$inferInsert;
export type SelectUser = typeof usersTable.$inferSelect;

export type InsertPost = typeof postsTable.$inferInsert;
export type SelectPost = typeof postsTable.$inferSelect;
```

#### 设置 Drizzle 配置文件

**Drizzle 配置** - 一个由 [Drizzle Kit](/docs/kit-overview) 使用的配置文件，包含有关您的数据库连接、迁移文件夹和架构文件的所有信息。

在项目根目录下创建一个 `drizzle.config.ts` 文件，并添加以下内容：

```typescript copy filename="drizzle.config.ts"
import { config } from 'dotenv';
import { defineConfig } from 'drizzle-kit';

config({ path: '.env' });

export default defineConfig({
  schema: './src/db/schema.ts',
  out: './supabase/migrations',
  dialect: 'postgresql',
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
});
```

#### 将更改应用于数据库

您可以使用 `drizzle-kit generate` 命令生成迁移，然后使用 `drizzle-kit migrate` 命令运行它们。

生成迁移：

```bash copy
npx drizzle-kit generate
```

这些迁移存储在 `supabase/migrations` 目录中，正如您在 `drizzle.config.ts` 中指定的那样。该目录将包含更新您的数据库架构所需的 SQL 文件，以及一个用于存储不同迁移阶段架构快照的 `meta` 文件夹。

生成迁移的示例：

```sql
CREATE TABLE IF NOT EXISTS "posts_table" (
	"id" serial PRIMARY KEY NOT NULL,
	"title" text NOT NULL,
	"content" text NOT NULL,
	"user_id" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp NOT NULL
);
--> statement-breakpoint
CREATE TABLE IF NOT EXISTS "users_table" (
	"id" serial PRIMARY KEY NOT NULL,
	"name" text NOT NULL,
	"age" integer NOT NULL,
	"email" text NOT NULL,
	CONSTRAINT "users_table_email_unique" UNIQUE("email")
);
--> statement-breakpoint
DO $$ BEGIN
 ALTER TABLE "posts_table" ADD CONSTRAINT "posts_table_user_id_users_table_id_fk" FOREIGN KEY ("user_id") REFERENCES "users_table"("id") ON DELETE cascade ON UPDATE no action;
EXCEPTION
 WHEN duplicate_object THEN null;
END $$;
```

运行迁移：

```bash copy
npx drizzle-kit migrate
```

了解有关 [迁移过程](/docs/migrations) 的更多信息。您还可以使用 [Supabase CLI](https://supabase.com/docs/guides/cli/getting-started) 应用迁移：
- 对于已存在的表，手动审查从 `npx drizzle-kit generate` 生成的迁移文件，并注释或调整任何不安全的纯创建语句（例如，`CREATE SCHEMA "auth";`），确保安全的条件创建（例如，`CREATE TABLE IF NOT EXISTS "auth"."users"`）得到妥善处理。

或者，您可以使用 [Drizzle kit push 命令](/docs/kit-overview#prototyping-with-db-push) 直接将更改推送到数据库：

```bash copy
npx drizzle-kit push
```

<Callout type="warning">Push 命令适用于需要快速测试新架构设计或在本地开发环境中进行更改的情况，使您能够快速迭代，而无需管理迁移文件的开销。</Callout>

要使用 Supabase CLI 应用迁移，您应遵循以下步骤：

使用 Drizzle Kit 生成迁移：

```bash copy
npx drizzle-kit generate
```

初始化本地 Supabase 项目：

```bash copy
supabase init
```

将其链接到您的远程项目：

```bash copy
supabase link
```

将更改推送到数据库：

```bash copy
supabase db push
```
</Steps>

## 基本文件结构

这是项目的基本文件结构。在 `src/db` 目录中，我们有与数据库相关的文件，包括在 `index.ts` 中的连接和在 `schema.ts` 中的架构定义。

```plaintext
📦 <项目根目录>
 ├ 📂 src
 │   ├ 📂 db
 │   │  ├ 📜 index.ts
 │   │  └ 📜 schema.ts
 ├ 📂 supabase
 │   ├ 📂 migrations
 │   │  ├ 📂 meta
 │   │  │  ├ 📜 _journal.json
 │   │  │  └ 📜 0000_snapshot.json
 │   │  └ 📜 0000_watery_spencer_smythe.sql
 │   └ 📜 config.toml
 ├ 📜 .env
 ├ 📜 drizzle.config.ts
 ├ 📜 package.json
 └ 📜 tsconfig.json
```

## 查询示例

例如，我们可以创建 `src/db/queries` 文件夹，并为每个操作（插入、选择、更新、删除）单独创建文件。

#### 插入数据

有关插入查询的更多信息，请参阅 [文档](/docs/insert)。

```typescript copy filename="src/db/queries/insert.ts" {4, 8}
import { db } from '../index';
import { InsertPost, InsertUser, postsTable, usersTable } from '../schema';

export async function createUser(data: InsertUser) {
  await db.insert(usersTable).values(data);
}

export async function createPost(data: InsertPost) {
  await db.insert(postsTable).values(data);
}
```

#### 选择数据

有关选择查询的更多信息，请参阅 [文档](/docs/select)。

```typescript copy filename="src/db/queries/select.ts" {5, 16, 41}
import { asc, between, count, eq, getTableColumns, sql } from 'drizzle-orm';
import { db } from '../index';
import { SelectUser, postsTable, usersTable } from '../schema';

export async function getUserById(id: SelectUser['id']): Promise<
  Array<{
    id: number;
    name: string;
    age: number;
    email: string;
  }>
> {
  return db.select().from(usersTable).where(eq(usersTable.id, id));
}

export async function getUsersWithPostsCount(
  page = 1,
  pageSize = 5,
): Promise<
  Array<{
    postsCount: number;
    id: number;
    name: string;
    age: number;
    email: string;
  }>
> {
  return db
    .select({
      ...getTableColumns(usersTable),
      postsCount: count(postsTable.id),
    })
    .from(usersTable)
    .leftJoin(postsTable, eq(usersTable.id, postsTable.userId))
    .groupBy(usersTable.id)
    .orderBy(asc(usersTable.id))
    .limit(pageSize)
    .offset((page - 1) * pageSize);
}

export async function getPostsForLast24Hours(
  page = 1,
  pageSize = 5,
): Promise<
  Array<{
    id: number;
    title: string;
  }>
> {
  return db
    .select({
      id: postsTable.id,
      title: postsTable.title,
    })
    .from(postsTable)
    .where(between(postsTable.createdAt, sql`now() - interval '1 day'`, sql`now()`))
    .orderBy(asc(postsTable.title), asc(postsTable.id))
    .limit(pageSize)
    .offset((page - 1) * pageSize);
}
```

或者，您可以使用 [关系查询语法](/docs/rqb)。
#### 更新数据

有关更新查询的更多信息，请参阅 [文档](/docs/update)。

```typescript copy filename="src/db/queries/update.ts" {5}
import { eq } from 'drizzle-orm';
import { db } from '../index';
import { SelectPost, postsTable } from '../schema';

export async function updatePost(id: SelectPost['id'], data: Partial<Omit<SelectPost, 'id'>>) {
  await db.update(postsTable).set(data).where(eq(postsTable.id, id));
}
```

#### 删除数据

有关删除查询的更多信息，请参阅 [文档](/docs/delete)。

```typescript copy filename="src/db/queries/delete.ts" {5}
import { eq } from 'drizzle-orm';
import { db } from '../index';
import { SelectUser, usersTable } from '../schema';

export async function deleteUser(id: SelectUser['id']) {
  await db.delete(usersTable).where(eq(usersTable.id, id));
}
```

Source: https://drizzle.zhcndoc.com/docs/tutorials/drizzle-with-turso


import Prerequisites from "@mdx/Prerequisites.astro";
import Npm from '@mdx/Npm.astro';
import Steps from '@mdx/Steps.astro';
import Section from "@mdx/Section.astro";
import Callout from '@mdx/Callout.astro';

本教程演示了如何将 Drizzle ORM 与 [Turso](https://docs.turso.tech/introduction) 一起使用。

<Prerequisites>
- 您应该已经安装了 Drizzle ORM 和 [Drizzle kit](/docs/kit-overview)。您可以通过运行以下命令来实现：
<Npm>
drizzle-orm
-D drizzle-kit
</Npm>
- 您应该已经安装了 `dotenv` 包以管理环境变量。有关该包的更多信息，请阅读 [这里](https://www.npmjs.com/package/dotenv)
<Npm>
  dotenv
</Npm>
- 您应该已经安装了 `@libsql/client` 包。有关该包的更多信息，请阅读 [这里](https://www.npmjs.com/package/@libsql/client)。
<Npm>
  @libsql/client
</Npm>
- 您应该已经安装了 Turso CLI。有关更多信息，请查看 [文档](https://docs.turso.tech/cli/introduction)
</Prerequisites>

[Turso](https://docs.turso.tech/concepts) 是一个兼容 SQLite 的数据库，建立在 [libSQL](https://docs.turso.tech/libsql) 上，这是 SQLite 的开放贡献分支。它允许每个组织扩展到数十万个数据库，并支持将数据复制到任何位置，包括您自己的服务器，从而实现微秒级延迟访问。您可以在 [这里](https://docs.turso.tech/concepts) 阅读有关 Turso 概念的更多内容。

Drizzle ORM 本身支持 libSQL 驱动程序，我们拥抱 SQL 方言及方言特定的驱动程序和语法，并反映大多数流行的类似 SQLite 的 `all`、`get`、`values` 和 `run` 查询方法语法。

请查看 [官方文档](https://docs.turso.tech/quickstart) 以设置 Turso 数据库。

## 设置 Turso 和 Drizzle ORM

<Steps>
#### 注册或登录到 Turso

注册：

```bash copy
turso auth signup
```

登录：

```bash copy
turso auth login
```

#### 创建新数据库

通过运行 `turso db create <DATABASE_NAME>` 命令创建新数据库：

```bash copy
turso db create drizzle-turso-db
```

要查看有关数据库的信息，运行以下命令：

```bash copy
turso db show drizzle-turso-db
```

#### 创建身份验证令牌

要为您的数据库创建身份验证令牌，请运行以下命令：

```bash copy
turso db tokens create drizzle-turso-db
```

在 [文档](https://docs.turso.tech/cli/db/tokens/create) 中了解有关此命令及其选项的更多信息。

#### 更新环境变量

用连接 URL 和身份验证令牌更新您的 `.env` 或 `.env.local` 文件。

```text copy
TURSO_CONNECTION_URL=
TURSO_AUTH_TOKEN=
```

#### 将 Drizzle ORM 连接到您的数据库

在 `src/db` 目录中创建一个 `index.ts` 文件，并设置您的数据库配置：

```typescript copy filename="src/db/index.ts"
import { config } from 'dotenv';
import { drizzle } from 'drizzle-orm/libsql';

config({ path: '.env' }); // 或 .env.local

export const db = drizzle({ connection: {
  url: process.env.TURSO_CONNECTION_URL!,
  authToken: process.env.TURSO_AUTH_TOKEN!,
}});
```

#### 创建表

在 `src/db` 目录中创建一个 `schema.ts` 文件并声明您的表：

```typescript copy filename="src/db/schema.ts"
import { sql } from 'drizzle-orm';
import { integer, sqliteTable, text } from 'drizzle-orm/sqlite-core';

export const usersTable = sqliteTable('users', {
  id: integer('id').primaryKey(),
  name: text('name').notNull(),
  age: integer('age').notNull(),
  email: text('email').unique().notNull(),
});

export const postsTable = sqliteTable('posts', {
  id: integer('id').primaryKey(),
  title: text('title').notNull(),
  content: text('content').notNull(),
  userId: integer('user_id')
    .notNull()
    .references(() => usersTable.id, { onDelete: 'cascade' }),
  createdAt: text('created_at')
    .default(sql`(CURRENT_TIMESTAMP)`)
    .notNull(),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).$onUpdate(() => new Date()),
});

export type InsertUser = typeof usersTable.$inferInsert;
export type SelectUser = typeof usersTable.$inferSelect;

export type InsertPost = typeof postsTable.$inferInsert;
export type SelectPost = typeof postsTable.$inferSelect;
```

#### 设置 Drizzle 配置文件

**Drizzle 配置** - 用于 [Drizzle Kit](/docs/kit-overview) 的配置文件，包含有关您的数据库连接、迁移文件夹和模式文件的所有信息。

在项目根目录中创建一个 `drizzle.config.ts` 文件并添加以下内容：

```typescript copy filename="drizzle.config.ts"
import { config } from 'dotenv';
import { defineConfig } from 'drizzle-kit';

config({ path: '.env' });

export default defineConfig({
  schema: './src/db/schema.ts',
  out: './migrations',
  dialect: 'turso',
  dbCredentials: {
    url: process.env.TURSO_CONNECTION_URL!,
    authToken: process.env.TURSO_AUTH_TOKEN!,
  },
});
```

#### 将更改应用到数据库

您可以使用 `drizzle-kit generate` 命令生成迁移，然后使用 `drizzle-kit migrate` 命令运行它们。

生成迁移：

```bash copy
npx drizzle-kit generate
```

这些迁移存储在 `migrations` 目录中，如您的 `drizzle.config.ts` 中所指定。该目录将包含更新数据库模式所需的 SQL 文件，以及一个 `meta` 文件夹，用于存储不同迁移阶段的模式快照。

生成的迁移示例：

```sql
CREATE TABLE `posts` (
	`id` integer PRIMARY KEY NOT NULL,
	`title` text NOT NULL,
	`content` text NOT NULL,
	`user_id` integer NOT NULL,
	`created_at` text DEFAULT (CURRENT_TIMESTAMP) NOT NULL,
	`updated_at` integer,
	FOREIGN KEY (`user_id`) REFERENCES `users`(`id`) ON UPDATE no action ON DELETE cascade
);
--> statement-breakpoint
CREATE TABLE `users` (
	`id` integer PRIMARY KEY NOT NULL,
	`name` text NOT NULL,
	`age` integer NOT NULL,
	`email` text NOT NULL
);
--> statement-breakpoint
CREATE UNIQUE INDEX `users_email_unique` ON `users` (`email`);
```

运行迁移：

```bash copy
npx drizzle-kit migrate
```

或者，您可以使用 [Drizzle kit push 命令](/docs/kit-overview#prototyping-with-db-push) 将更改直接推送到数据库：

```bash copy
npx drizzle-kit push
```

<Callout type="warning">Push 命令适用于您需要在本地开发环境中快速测试新模式设计或更改的情况，允许快速迭代而无需管理迁移文件的负担。</Callout>
</Steps>

### 基本文件结构

这是项目的基本文件结构。在 `src/db` 目录中，我们有与数据库相关的文件，包括在 `index.ts` 中的连接和在 `schema.ts` 中的模式定义。

```plaintext
📦 <项目根目录>
 ├ 📂 src
 │   ├ 📂 db
 │   │  ├ 📜 index.ts
 │   │  └ 📜 schema.ts
 ├ 📂 migrations
 │  ├ 📂 meta
 │  │  ├ 📜 _journal.json
 │  │  └ 📜 0000_snapshot.json
 │  └ 📜 0000_watery_spencer_smythe.sql
 ├ 📜 .env
 ├ 📜 drizzle.config.ts
 ├ 📜 package.json
 └ 📜 tsconfig.json
```

## 查询示例

例如，我们可以创建 `src/db/queries` 文件夹，并为每个操作：插入、选择、更新、删除分别创建文件。

#### 插入数据

有关插入查询的更多信息，请阅读 [文档](/docs/insert)。

```typescript copy filename="src/db/queries/insert.ts" {4, 8}
import { db } from '../index';
import { InsertPost, InsertUser, postsTable, usersTable } from '../schema';

export async function createUser(data: InsertUser) {
  await db.insert(usersTable).values(data);
}

export async function createPost(data: InsertPost) {
  await db.insert(postsTable).values(data);
}
```

#### 选择数据

有关选择查询的更多信息，请阅读 [文档](/docs/select)。

```typescript copy filename="src/db/queries/select.ts" {5, 16, 41}
import { asc, count, eq, getTableColumns, gt, sql } from 'drizzle-orm';
import { db } from '../index';
import { SelectUser, postsTable, usersTable } from '../schema';

export async function getUserById(id: SelectUser['id']): Promise<
  Array<{
    id: number;
    name: string;
    age: number;
    email: string;
  }>
> {
  return db.select().from(usersTable).where(eq(usersTable.id, id));
}

export async function getUsersWithPostsCount(
  page = 1,
  pageSize = 5,
): Promise<
  Array<{
    postsCount: number;
    id: number;
    name: string;
    age: number;
    email: string;
  }>
> {
  return db
    .select({
      ...getTableColumns(usersTable),
      postsCount: count(postsTable.id),
    })
    .from(usersTable)
    .leftJoin(postsTable, eq(usersTable.id, postsTable.userId))
    .groupBy(usersTable.id)
    .orderBy(asc(usersTable.id))
    .limit(pageSize)
    .offset((page - 1) * pageSize);
}

export async function getPostsForLast24Hours(
  page = 1,
  pageSize = 5,
): Promise<
  Array<{
    id: number;
    title: string;
  }>
> {
  return db
    .select({
      id: postsTable.id,
      title: postsTable.title,
    })
    .from(postsTable)
    .where(gt(postsTable.createdAt, sql`(datetime('now','-24 hour'))`))
    .orderBy(asc(postsTable.title), asc(postsTable.id))
    .limit(pageSize)
    .offset((page - 1) * pageSize);
}
```

另外，您可以使用 [关系查询语法](/docs/rqb)。

#### 更新数据

有关更新查询的更多信息，请阅读 [文档](/docs/update)。

```typescript copy filename="src/db/queries/update.ts" {5}
import { eq } from 'drizzle-orm';
import { db } from '../index';
import { SelectPost, postsTable } from '../schema';

export async function updatePost(id: SelectPost['id'], data: Partial<Omit<SelectPost, 'id'>>) {
  await db.update(postsTable).set(data).where(eq(postsTable.id, id));
}
```

#### 删除数据

有关删除查询的更多信息，请阅读 [文档](/docs/delete)。

```typescript copy filename="src/db/queries/delete.ts" {5}
import { eq } from 'drizzle-orm';
import { db } from '../index';
import { SelectUser, usersTable } from '../schema';

export async function deleteUser(id: SelectUser['id']) {
  await db.delete(usersTable).where(eq(usersTable.id, id));
}
```


Source: https://drizzle.zhcndoc.com/docs/tutorials/drizzle-with-vercel


import Prerequisites from "@mdx/Prerequisites.astro";
import Npm from '@mdx/Npm.astro';
import Steps from '@mdx/Steps.astro';
import Section from "@mdx/Section.astro";
import Callout from '@mdx/Callout.astro';

本教程演示如何使用 Drizzle ORM 结合 [Vercel Postgres](https://vercel.com/docs/storage/vercel-postgres)。Vercel Postgres 是一个无服务器 SQL 数据库，旨在与 Vercel Functions 和您的前端框架集成。

<Prerequisites>
- 您应该已安装 Drizzle ORM 和 [Drizzle kit](/docs/kit-overview)。您可以通过运行以下命令来做到这一点：
<Npm>
drizzle-orm
-D drizzle-kit
</Npm>

- 您应该已安装 `dotenv` 包以管理环境变量。有关此包的更多信息，请阅读 [这里](https://www.npmjs.com/package/dotenv)
<Npm>
  dotenv
</Npm>

- 您应该已安装 `@vercel/postgres` 包。有关此包的更多信息，请阅读 [这里](https://www.npmjs.com/package/@vercel/postgres)
<Npm>
  @vercel/postgres
</Npm>  
</Prerequisites>

查看 [Vercel 文档](https://vercel.com/docs/storage/vercel-postgres/using-an-orm#drizzle)，了解如何使用 Drizzle ORM 连接到数据库。

## 设置 Vercel Postgres 和 Drizzle ORM

<Steps>
#### 创建新的 Vercel Postgres 数据库

您可以在 [控制面板](https://vercel.com/dashboard) 中创建新的 Vercel Postgres 数据库。

请查阅 Vercel Postgres [文档](https://vercel.com/docs/storage/vercel-postgres/quickstart) 以了解如何创建新的数据库。

#### 设置连接字符串变量

导航至您的 Vercel Postgres 数据库并从 `.env.local` 部分复制 `POSTGRES_URL`。

将 `POSTGRES_URL` 添加到您的 `.env.local` 或 `.env` 文件中。

```plaintext copy
POSTGRES_URL=<YOUR_DATABASE_URL>
```

#### 将 Drizzle ORM 连接到您的数据库

在 `src/db` 目录中创建一个 `index.ts` 文件，并设置您的数据库配置：

```typescript copy filename="src/db/index.ts"
import { drizzle } from 'drizzle-orm/vercel-postgres';
import { config } from 'dotenv';

config({ path: '.env.local' }); // 或 .env

export const db = drizzle();

```

#### 创建表

在 `src/db` 目录中创建一个 `schema.ts` 文件，并声明您的表：

```typescript copy filename="src/db/schema.ts"
import { integer, pgTable, serial, text, timestamp } from 'drizzle-orm/pg-core';

export const usersTable = pgTable('users_table', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  age: integer('age').notNull(),
  email: text('email').notNull().unique(),
});

export const postsTable = pgTable('posts_table', {
  id: serial('id').primaryKey(),
  title: text('title').notNull(),
  content: text('content').notNull(),
  userId: integer('user_id')
    .notNull()
    .references(() => usersTable.id, { onDelete: 'cascade' }),
  createdAt: timestamp('created_at').notNull().defaultNow(),
  updatedAt: timestamp('updated_at')
    .notNull()
    .$onUpdate(() => new Date()),
});

export type InsertUser = typeof usersTable.$inferInsert;
export type SelectUser = typeof usersTable.$inferSelect;

export type InsertPost = typeof postsTable.$inferInsert;
export type SelectPost = typeof postsTable.$inferSelect;
```

#### 设置 Drizzle 配置文件

**Drizzle 配置** - 这是由 [Drizzle Kit](/docs/kit-overview) 使用的配置文件，包含有关您的数据库连接、迁移文件夹和模式文件的所有信息。

在项目根目录中创建一个 `drizzle.config.ts` 文件，并添加以下内容：

```typescript copy filename="drizzle.config.ts"
import { config } from 'dotenv';
import { defineConfig } from 'drizzle-kit';

config({ path: '.env.local' });

export default defineConfig({
  schema: './src/db/schema.ts',
  out: './migrations',
  dialect: 'postgresql',
  dbCredentials: {
    url: process.env.POSTGRES_URL!,
  },
});
```

#### 将更改应用于数据库

您可以使用 `drizzle-kit generate` 命令生成迁移，然后使用 `drizzle-kit migrate` 命令运行它们。

生成迁移：

```bash copy
npx drizzle-kit generate
```

这些迁移存储在 `drizzle/migrations` 目录中，如您在 `drizzle.config.ts` 中指定的那样。该目录将包含更新您的数据库架构所需的 SQL 文件以及一个 `meta` 文件夹，用于存储不同迁移阶段的架构快照。

生成迁移的示例：

```sql
CREATE TABLE IF NOT EXISTS "posts_table" (
	"id" serial PRIMARY KEY NOT NULL,
	"title" text NOT NULL,
	"content" text NOT NULL,
	"user_id" integer NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp NOT NULL
);
--> statement-breakpoint
CREATE TABLE IF NOT EXISTS "users_table" (
	"id" serial PRIMARY KEY NOT NULL,
	"name" text NOT NULL,
	"age" integer NOT NULL,
	"email" text NOT NULL,
	CONSTRAINT "users_table_email_unique" UNIQUE("email")
);
--> statement-breakpoint
DO $$ BEGIN
 ALTER TABLE "posts_table" ADD CONSTRAINT "posts_table_user_id_users_table_id_fk" FOREIGN KEY ("user_id") REFERENCES "users_table"("id") ON DELETE cascade ON UPDATE no action;
EXCEPTION
 WHEN duplicate_object THEN null;
END $$;
```

运行迁移：

```bash copy
npx drizzle-kit migrate
```

或者，您可以使用 [Drizzle kit push 命令](/docs/kit-overview#prototyping-with-db-push) 直接将更改推送到数据库：

```bash copy
npx drizzle-kit push
```

<Callout type="warning">Push 命令适用于需要快速测试新架构设计或在本地开发环境中进行更改的情况，允许快速迭代，而无需管理迁移文件的开销。</Callout>

</Steps>

## 基本文件结构

这是项目的基本文件结构。在 `src/db` 目录中，我们有与数据库相关的文件，包括在 `index.ts` 中的连接和在 `schema.ts` 中的模式定义。

```plaintext
📦 <project root>
 ├ 📂 src
 │   ├ 📂 db
 │   │  ├ 📜 index.ts
 │   │  └ 📜 schema.ts
 ├ 📂 migrations
 │   ├ 📂 meta
 │   │  ├ 📜 _journal.json
 │   │  └ 📜 0000_snapshot.json
 │   └ 📜 0000_watery_spencer_smythe.sql
 ├ 📜 .env.local
 ├ 📜 drizzle.config.ts
 ├ 📜 package.json
 └ 📜 tsconfig.json
```

## 查询示例

例如，我们创建 `src/db/queries` 文件夹，并为每个操作分开文件：插入、选择、更新、删除。

#### 插入数据

有关插入查询的更多信息，请参阅 [文档](/docs/insert)。

```typescript copy filename="src/db/queries/insert.ts" {4, 8}
import { db } from '../index';
import { InsertPost, InsertUser, postsTable, usersTable } from '../schema';

export async function createUser(data: InsertUser) {
  await db.insert(usersTable).values(data);
}

export async function createPost(data: InsertPost) {
  await db.insert(postsTable).values(data);
}
```

#### 选择数据

有关选择查询的更多信息，请参阅 [文档](/docs/select)。

```typescript copy filename="src/db/queries/select.ts" {5, 16, 41}
import { asc, between, count, eq, getTableColumns, sql } from 'drizzle-orm';
import { db } from '../index';
import { SelectUser, postsTable, usersTable } from '../schema';

export async function getUserById(id: SelectUser['id']): Promise<
  Array<{
    id: number;
    name: string;
    age: number;
    email: string;
  }>
> {
  return db.select().from(usersTable).where(eq(usersTable.id, id));
}

export async function getUsersWithPostsCount(
  page = 1,
  pageSize = 5,
): Promise<
  Array<{
    postsCount: number;
    id: number;
    name: string;
    age: number;
    email: string;
  }>
> {
  return db
    .select({
      ...getTableColumns(usersTable),
      postsCount: count(postsTable.id),
    })
    .from(usersTable)
    .leftJoin(postsTable, eq(usersTable.id, postsTable.userId))
    .groupBy(usersTable.id)
    .orderBy(asc(usersTable.id))
    .limit(pageSize)
    .offset((page - 1) * pageSize);
}

export async function getPostsForLast24Hours(
  page = 1,
  pageSize = 5,
): Promise<
  Array<{
    id: number;
    title: string;
  }>
> {
  return db
    .select({
      id: postsTable.id,
      title: postsTable.title,
    })
    .from(postsTable)
    .where(between(postsTable.createdAt, sql`now() - interval '1 day'`, sql`now()`))
    .orderBy(asc(postsTable.title), asc(postsTable.id))
    .limit(pageSize)
    .offset((page - 1) * pageSize);
}
```

或者，您可以使用 [关系查询语法](/docs/rqb)。

#### 更新数据

有关更新查询的更多信息，请参阅 [文档](/docs/update)。

```typescript copy filename="src/db/queries/update.ts" {5}
import { eq } from 'drizzle-orm';
import { db } from '../index';
import { SelectPost, postsTable } from '../schema';

export async function updatePost(id: SelectPost['id'], data: Partial<Omit<SelectPost, 'id'>>) {
  await db.update(postsTable).set(data).where(eq(postsTable.id, id));
}
```

#### 删除数据

有关删除查询的更多信息，请参阅 [文档](/docs/delete)。

```typescript copy filename="src/db/queries/delete.ts" {5}
import { eq } from 'drizzle-orm';
import { db } from '../index';
import { SelectUser, usersTable } from '../schema';

export async function deleteUser(id: SelectUser['id']) {
  await db.delete(usersTable).where(eq(usersTable.id, id));
}
```


Source: https://drizzle.zhcndoc.com/docs/tutorials/drizzle-nextjs-neon


import Steps from "@mdx/Steps.astro";
import Npm from "@mdx/Npm.astro";
import CodeTabs from "@mdx/CodeTabs.astro";
import CodeTab from "@mdx/CodeTab.astro";
import Section from "@mdx/Section.astro";
import Tabs from "@mdx/Tabs.astro";
import Tab from "@mdx/Tab.astro";
import Prerequisites from "@mdx/Prerequisites.astro";
import Callout from "@mdx/Callout.astro";

本教程演示如何使用 **Drizzle ORM** 和 **Neon 数据库** 以及 **Next.js** 构建 `Todo 应用`。

<Prerequisites>  
  - 你应该有一个现有的 Next.js 项目，或者使用以下命令创建一个新项目：
  ```bash
  npx create-next-app@latest --typescript
  ```

  - 你应该已经安装了 Drizzle ORM 和 [Drizzle kit](/docs/kit-overview)。可以通过以下命令来安装：
  <Npm>
    drizzle-orm 
    -D drizzle-kit
  </Npm>

  - 你应该已经安装了 [Neon 无服务器驱动](https://neon.tech/docs/serverless/serverless-driver)。 
  <Npm>
    @neondatabase/serverless
  </Npm>

  - 你应该已经安装了 `dotenv` 包用于管理环境变量。 
  <Npm>
    dotenv
  </Npm>  
</Prerequisites>

<Callout type="warning">
如果在安装过程中遇到依赖项解析问题：

如果你没有使用 React Native，通过强制使用 `--force` 或 `--legacy-peer-deps` 来解决该问题。如果你在使用 React Native，则需要使用与 React Native 版本兼容的确切 React 版本。
</Callout>

## 设置 Neon 和 Drizzle ORM

<Steps>
#### 创建一个新的 Neon 项目

登录到 [Neon 控制台](https://console.neon.tech/app/projects) 并导航到项目部分。选择一个项目或点击 `新建项目` 按钮以创建一个新项目。

你的 Neon 项目自带一个名为 `neondb` 的现成 Postgres 数据库。我们将在本教程中使用它。

#### 设置连接字符串变量

导航到项目控制台中的 **连接详情** 部分以查找你的数据库连接字符串。它应该类似于下面这样：

```bash
postgres://username:password@ep-cool-darkness-123456.us-east-2.aws.neon.tech/neondb
```

将 `DATABASE_URL` 环境变量添加到你的 `.env` 或 `.env.local` 文件中，你将在此用来连接 Neon 数据库。

```bash
DATABASE_URL=NEON_DATABASE_CONNECTION_STRING
```

#### 连接 Drizzle ORM 到你的数据库 

在 `src/db` 文件夹中创建 `drizzle.ts` 文件，并设置你的数据库配置：

```tsx copy filename="src/db/drizzle.ts"
import { config } from "dotenv";
import { drizzle } from 'drizzle-orm/neon-http';

config({ path: ".env" }); // 或 .env.local

export const db = drizzle(process.env.DATABASE_URL!);
```

#### 声明 todo 模式

```tsx copy filename="src/db/schema.ts"
import { integer, text, boolean, pgTable } from "drizzle-orm/pg-core";

export const todo = pgTable("todo", {
  id: integer("id").primaryKey(),
  text: text("text").notNull(),
  done: boolean("done").default(false).notNull(),
});
```

在这里，我们使用来自 Drizzle ORM 的数据类型定义 **`todo`** 表，其中包含字段 **`id`**、**`text`** 和 **`done`**。

#### 设置 Drizzle 配置文件

**Drizzle 配置** - 这是一个用于 [Drizzle Kit](/docs/kit-overview) 的配置文件，包含有关你的数据库连接、迁移文件夹和模式文件的所有信息。

在项目根目录中创建一个 `drizzle.config.ts` 文件，并添加以下内容：

```typescript copy filename="drizzle.config.ts"
import { config } from 'dotenv';
import { defineConfig } from "drizzle-kit";

config({ path: '.env' });

export default defineConfig({
  schema: "./src/db/schema.ts",
  out: "./migrations",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
});
```

#### 将更改应用于数据库

你可以使用 `drizzle-kit generate` 命令生成迁移，然后使用 `drizzle-kit migrate` 命令运行它们。

生成迁移：

```bash
npx drizzle-kit generate
```

这些迁移存储在 `drizzle/migrations` 目录中，如你的 `drizzle.config.ts` 所指定的。这一目录将包含更新数据库模式所需的 SQL 文件以及一个 `meta` 文件夹，用于存储在不同迁移阶段的模式快照。

生成迁移的示例：

```sql
CREATE TABLE IF NOT EXISTS "todo" (
	"id" integer PRIMARY KEY NOT NULL,
	"text" text NOT NULL,
	"done" boolean DEFAULT false NOT NULL
);
```

运行迁移：

```bash
npx drizzle-kit migrate
```

另外，你可以使用 [Drizzle kit push 命令](/docs/kit-overview#prototyping-with-db-push) 直接将更改推送到数据库：

```bash
npx drizzle-kit push
```

<Callout type="warning">Push 命令适合于需要快速测试新模式设计或在本地开发环境中更改的情况，允许快速迭代，而无需管理迁移文件的开销。</Callout>
</Steps>

#### 建立服务器端函数
在本步骤中，我们在 **src/actions/todoAction.ts** 文件中建立服务器端函数，以处理 todo 项目的重要操作：

1. **`getData`:**
    - 从数据库获取所有现存的 todo 项目。
2. **`addTodo`:**
    - 向数据库添加带有提供文本的新 todo 项目。
    - 使用 **`revalidatePath("/")`** 触发主页的重新验证。
3. **`deleteTodo`:**
    - 根据唯一 ID 从数据库中删除一个 todo 项目。
    - 触发主页的重新验证。
4. **`toggleTodo`:**
    - 切换一个 todo 项目的完成状态，相应地更新数据库。
    - 在操作之后重新验证主页。
5. **`editTodo`:**
    - 修改数据库中由 ID 标识的 todo 项目的文本。
    - 启动主页的重新验证。

```tsx collapsable copy filename="src/actions/todoAction.ts"
"use server";
import { eq, not } from "drizzle-orm";
import { revalidatePath } from "next/cache";
import { db } from "@/db/drizzle";
import { todo } from "@/db/schema";

export const getData = async () => {
  const data = await db.select().from(todo);
  return data;
};

export const addTodo = async (id: number, text: string) => {
  await db.insert(todo).values({
    id: id,
    text: text,
  });
};

export const deleteTodo = async (id: number) => {
  await db.delete(todo).where(eq(todo.id, id));

  revalidatePath("/");
};

export const toggleTodo = async (id: number) => {
  await db
    .update(todo)
    .set({
      done: not(todo.done),
    })
    .where(eq(todo.id, id));

  revalidatePath("/");
};

export const editTodo = async (id: number, text: string) => {
  await db
    .update(todo)
    .set({
      text: text,
    })
    .where(eq(todo.id, id));

  revalidatePath("/");
};
```

## 使用 Next.js 设置主页

<Steps>
#### 定义一个 TypeScript 类型

在 `src/types/todoType.ts` 中定义一个表示 todo 项目的 TypeScript 类型，包含三个属性： **`id`** 类型为 **`number`**、 **`text`** 类型为 **`string`** 和 **`done`** 类型为 **`boolean`**。这个类型命名为 **`todoType`**，表示你应用中一个典型 todo 项目的结构。

```ts copy filename="src/types/todoType.ts"
export type todoType = {
  id: number;
  text: string;
  done: boolean;
};
```

#### 为 todo 应用创建主页

1. **`src/components/todo.tsx`:**
    创建一个 `Todo` 组件，表示单个 todo 项目。它包括用于显示和编辑 todo 文本、用复选框标记为完成的功能，以及提供编辑、保存、取消和删除 todo 的操作。
2. **`src/components/addTodo.tsx`:**
    `AddTodo` 组件提供了一个简单的表单，用于向 Todo 应用添加新的 todo 项目。它包括一个输入字段用于输入 todo 文本，以及一个按钮用于触发新 todo 的添加。
3. **`src/components/todos.tsx`:**
    创建 Todos 组件，表示 Todo 应用的主要界面。它管理 todo 项目的状态，提供创建、编辑、切换和删除 todo 的功能，并使用 `Todo` 组件渲染各个 todo 项目。

<CodeTabs items={["todo.tsx", "addTodo.tsx", "todos.tsx"]}>
```tsx collapsable copy
"use client";
import { ChangeEvent, FC, useState } from "react";
import { todoType } from "@/types/todoType";

interface Props {
  todo: todoType;
  changeTodoText: (id: number, text: string) => void;
  toggleIsTodoDone: (id: number, done: boolean) => void;
  deleteTodoItem: (id: number) => void;
}

const Todo: FC<Props> = ({
  todo,
  changeTodoText,
  toggleIsTodoDone,
  deleteTodoItem,
}) => {
  // 处理编辑模式的状态
  const [editing, setEditing] = useState(false);

  // 处理文本输入的状态
  const [text, setText] = useState(todo.text);

  // 处理完成状态的状态
  const [isDone, setIsDone] = useState(todo.done);

  // 文本输入变化的事件处理
  const handleTextChange = (e: ChangeEvent<HTMLInputElement>) => {
    setText(e.target.value);
  };

  // 切换完成状态的事件处理
  const handleIsDone = async () => {
    toggleIsTodoDone(todo.id, !isDone);
    setIsDone((prev) => !prev);
  };

  // 启动编辑模式的事件处理
  const handleEdit = () => {
    setEditing(true);
  };

  // 保存编辑文本的事件处理
  const handleSave = async () => {
    changeTodoText(todo.id, text);
    setEditing(false);
  };

  // 取消编辑模式的事件处理
  const handleCancel = () => {
    setEditing(false);
    setText(todo.text);
  };

  // 删除 todo 项目的事件处理
  const handleDelete = () => {
    if (confirm("你确定要删除这个 todo 吗？")) {
      deleteTodoItem(todo.id);
    }
  };

  // 渲染 Todo 组件
  return (
    <div className="flex items-center gap-2 p-4 border-gray-200 border-solid border rounded-lg">
      {/* 用于标记 todo 为完成的复选框 */}
      <input
        type="checkbox"
        className="text-blue-200 rounded-sm h-4 w-4"
        checked={isDone}
        onChange={handleIsDone}
      />
      {/* todo 文本的输入字段 */}
      <input
        type="text"
        value={text}
        onChange={handleTextChange}
        readOnly={!editing}
        className={`${
          todo.done ? "line-through" : ""
        } outline-none read-only:border-transparent focus:border border-gray-200 rounded px-2 py-1 w-full`}
      />
      {/* 编辑、保存、取消和删除的操作按钮 */}
      <div className="flex gap-1 ml-auto">
        {editing ? (
          <button
            onClick={handleSave}
            className="bg-green-600 text-green-50 rounded px-2 w-14 py-1"
          >
            保存
          </button>
        ) : (
          <button
            onClick={handleEdit}
            className="bg-blue-400 text-blue-50 rounded w-14 px-2 py-1"
          >
            编辑
          </button>
        )}
        {editing ? (
          <button
            onClick={handleCancel}
            className="bg-red-400 w-16 text-red-50 rounded px-2 py-1"
          >
            关闭
          </button>
        ) : (
          <button
            onClick={handleDelete}
            className="bg-red-400 w-16 text-red-50 rounded px-2 py-1"
          >
            删除
          </button>
        )}
      </div>
    </div>
  );
};

export default Todo;
```
```tsx collapsable copy
"use client";
import { ChangeEvent, FC, useState } from "react";

interface Props {
  createTodo: (value: string) => void;
}

const AddTodo: FC<Props> = ({ createTodo }) => {
  // 处理输入值的状态
  const [input, setInput] = useState("");

  // 输入变化的事件处理
  const handleInput = (e: ChangeEvent<HTMLInputElement>) => {
    setInput(e.target.value);
  };

  // 添加新 todo 的事件处理
  const handleAdd = async () => {
    createTodo(input);
    setInput("");
  };

  // 渲染 AddTodo 组件
  return (
    <div className="w-full flex gap-1 mt-2">
      {/* 输入新 todo 文本的输入字段 */}
      <input
        type="text"
        className="w-full px-2 py-1 border border-gray-200 rounded outline-none"
        onChange={handleInput}
        value={input}
      />
      {/* 添加新 todo 的按钮 */}
      <button
        className="flex items-center justify-center bg-green-600 text-green-50 rounded px-2 h-9 w-14 py-1"
        onClick={handleAdd}
      >
        添加
      </button>
    </div>
  );
};

export default AddTodo;
```

	<CodeTab>
```tsx collapsable copy
"use client";
import { FC, useState } from "react";
import { todoType } from "@/types/todoType";
import Todo from "./todo";
import AddTodo from "./addTodo";
import { addTodo, deleteTodo, editTodo, toggleTodo } from "@/actions/todoAction";

interface Props {
  todos: todoType[];
}

const Todos: FC<Props> = ({ todos }) => {
  // 管理 todo 项目列表的状态
  const [todoItems, setTodoItems] = useState<todoType[]>(todos);

  // 创建新 todo 项目的函数
  const createTodo = (text: string) => {
    const id = (todoItems.at(-1)?.id || 0) + 1;
    addTodo(id, text);
    setTodoItems((prev) => [...prev, { id: id, text, done: false }]);
  };

  // 更改 todo 项目文本的函数
  const changeTodoText = (id: number, text: string) => {
    setTodoItems((prev) =>
      prev.map((todo) => (todo.id === id ? { ...todo, text } : todo))
    );
    editTodo(id, text);
  };

  // 切换 todo 项目完成状态的函数
  const toggleIsTodoDone = (id: number) => {
    setTodoItems((prev) =>
      prev.map((todo) => (todo.id === id ? { ...todo, done: !todo.done } : todo))
    );
    toggleTodo(id);
  };

  // 删除 todo 项目的函数
  const deleteTodoItem = (id: number) => {
    setTodoItems((prev) => prev.filter((todo) => todo.id !== id));
    deleteTodo(id);
  };

  // 渲染 Todo 列表组件
  return (
    <main className="flex mx-auto max-w-xl w-full min-h-screen flex-col items-center p-16">
      <div className="text-5xl font-medium">待办事项应用</div>
      <div className="w-full flex flex-col mt-8 gap-2">
        {/* 遍历 todoItems，并为每个 todo 渲染 Todo 组件 */}
        {todoItems.map((todo) => (
          <Todo
            key={todo.id}
            todo={todo}
            changeTodoText={changeTodoText}
            toggleIsTodoDone={toggleIsTodoDone}
            deleteTodoItem={deleteTodoItem}
          />
        ))}
      </div>
      {/* 为创建新 todos 添加 Todo 组件 */}
      <AddTodo createTodo={createTodo} />
    </main>
  );
};

export default Todos;
```

    </CodeTab>
</CodeTabs>

更新 `src/app/page.tsx` 文件以从数据库获取 todo 项目并渲染 `Todos` 组件：

```tsx copy filename="src/app/page.tsx"
import { getData } from "@/actions/todoAction";
import Todos from "@/components/todos";

export default async function Home() {
  const data = await getData();
  return <Todos todos={data} />;
}
```
</Steps>

## 基本文件结构

本指南使用以下文件结构：

```text
📦 <项目根目录>
 ├ 📂 migrations
 │  ├ 📂 meta
 │  └ 📜 0000_heavy_doctor_doom.sql
 ├ 📂 public
 ├ 📂 src
 │  ├ 📂 actions
 │  │  └ 📜 todoActions.ts
 │  ├ 📂 app
 │  │  ├ 📜 favicon.ico
 │  │  ├ 📜 globals.css
 │  │  ├ 📜 layout.tsx
 │  │  └ 📜 page.tsx
 │  ├ 📂 components
 │  │  ├ 📜 addTodo.tsx
 │  │  ├ 📜 todo.tsx
 │  │  └ 📜 todos.tsx
 │  └ 📂 db
 │  │  ├ 📜 drizzle.ts
 │  │  └ 📜 schema.ts
 │  └ 📂 types
 │     └ 📜 todoType.ts
 ├ 📜 .env
 ├ 📜 .eslintrc.json
 ├ 📜 .gitignore
 ├ 📜 drizzle.config.ts
 ├ 📜 next-env.d.ts
 ├ 📜 next.config.mjs
 ├ 📜 package-lock.json
 ├ 📜 package.json
 ├ 📜 postcss.config.mjs
 ├ 📜 README.md
 ├ 📜 tailwind.config.ts
 └ 📜 tsconfig.json
```


Source: https://drizzle.zhcndoc.com/docs/typebox

import Npm from '@mdx/Npm.astro';
import Callout from '@mdx/Callout.astro';

# drizzle-typebox

`drizzle-typebox` 是一个针对 **[Drizzle ORM](https://github.com/drizzle-team/drizzle-orm)** 的插件，允许你从 Drizzle ORM 模式生成 **[Typebox](https://github.com/sinclairzx81/typebox)** 模式。

### 安装依赖

<Npm>
drizzle-typebox
</Npm>

<Callout type="warning">
本文件对于 `drizzle-typebox@0.2.0` 及以上版本的文档

你还必须安装 Drizzle ORM v0.36.0 或更高版本，以及 Typebox v0.34.8 或更高版本。
</Callout>

### 选择模式

定义从数据库查询的数据的结构 - 可用于验证 API 响应。

```ts copy
import { pgTable, text, integer } from 'drizzle-orm/pg-core';
import { createSelectSchema } from 'drizzle-typebox';
import { Value } from '@sinclair/typebox/value';

const users = pgTable('users', {
  id: integer().generatedAlwaysAsIdentity().primaryKey(),
  name: text().notNull(),
  age: integer().notNull()
});

const userSelectSchema = createSelectSchema(users);

const rows = await db.select({ id: users.id, name: users.name }).from(users).limit(1);
const parsed: { id: number; name: string; age: number } = Value.Parse(userSelectSchema, rows[0]); // 错误：`age`在上述查询中未返回

const rows = await db.select().from(users).limit(1);
const parsed: { id: number; name: string; age: number } = Value.Parse(userSelectSchema, rows[0]); // 将成功解析
```

视图和枚举也被支持。

```ts copy
import { pgEnum } from 'drizzle-orm/pg-core';
import { createSelectSchema } from 'drizzle-typebox';
import { Value } from '@sinclair/typebox/value';

const roles = pgEnum('roles', ['admin', 'basic']);
const rolesSchema = createSelectSchema(roles);
const parsed: 'admin' | 'basic' = Value.Parse(rolesSchema, ...);

const usersView = pgView('users_view').as((qb) => qb.select().from(users).where(gt(users.age, 18)));
const usersViewSchema = createSelectSchema(usersView);
const parsed: { id: number; name: string; age: number } = Value.Parse(usersViewSchema, ...);
```

### 插入模式

定义要插入到数据库的数据的结构 - 可用于验证 API 请求。

```ts copy
import { pgTable, text, integer } from 'drizzle-orm/pg-core';
import { createInsertSchema } from 'drizzle-typebox';
import { Value } from '@sinclair/typebox/value';

const users = pgTable('users', {
  id: integer().generatedAlwaysAsIdentity().primaryKey(),
  name: text().notNull(),
  age: integer().notNull()
});

const userInsertSchema = createInsertSchema(users);

const user = { name: 'John' };
const parsed: { name: string, age: number } = Value.Parse(userInsertSchema, user); // 错误：`age`未定义

const user = { name: 'Jane', age: 30 };
const parsed: { name: string, age: number } = Value.Parse(userInsertSchema, user); // 将成功解析
await db.insert(users).values(parsed);
```

### 更新模式

定义要更新到数据库的数据的结构 - 可用于验证 API 请求。

```ts copy
import { pgTable, text, integer } from 'drizzle-orm/pg-core';
import { createUpdateSchema } from 'drizzle-typebox';
import { Value } from '@sinclair/typebox/value';

const users = pgTable('users', {
  id: integer().generatedAlwaysAsIdentity().primaryKey(),
  name: text().notNull(),
  age: integer().notNull()
});

const userUpdateSchema = createUpdateSchema(users);

const user = { id: 5, name: 'John' };
const parsed: { name?: string | undefined, age?: number | undefined } = Value.Parse(userUpdateSchema, user); // 错误：`id`是一个生成列，无法更新

const user = { age: 35 };
const parsed: { name?: string | undefined, age?: number | undefined } = Value.Parse(userUpdateSchema, user); // 将成功解析
await db.update(users).set(parsed).where(eq(users.name, 'Jane'));
```

### 精炼

每个创建模式函数接受一个额外的可选参数，你可以用它来扩展、修改或完全覆盖字段的模式。定义一个回调函数将扩展或修改，而提供一个 Typebox 模式将覆盖它。

```ts copy
import { pgTable, text, integer, json } from 'drizzle-orm/pg-core';
import { createSelectSchema } from 'drizzle-typebox';
import { Type } from '@sinclair/typebox';
import { Value } from '@sinclair/typebox/value';

const users = pgTable('users', {
  id: integer().generatedAlwaysAsIdentity().primaryKey(),
  name: text().notNull(),
  bio: text(),
  preferences: json()
});

const userSelectSchema = createSelectSchema(users, {
  name: (schema) => Type.String({ ...schema, maxLength: 20 }), // 扩展模式
  bio: (schema) => Type.String({ ...schema, maxLength: 1000 }), // 在变为可选/可空之前扩展模式
  preferences: Type.Object({ theme: Type.String() }) // 覆盖字段，包括它的可空性
});

const parsed: {
  id: number;
  name: string,
  bio?: string | undefined;
  preferences: {
    theme: string;
  };
} = Value.Parse(userSelectSchema, ...);
```

### 工厂函数

对于更高级的用例，可以使用 `createSchemaFactory` 函数。

**用例：使用扩展的 Typebox 实例**

```ts copy
import { pgTable, text, integer } from 'drizzle-orm/pg-core';
import { createSchemaFactory } from 'drizzle-typebox';
import { t } from 'elysia'; // 扩展 Typebox 实例

const users = pgTable('users', {
  id: integer().generatedAlwaysAsIdentity().primaryKey(),
  name: text().notNull(),
  age: integer().notNull()
});

const { createInsertSchema } = createSchemaFactory({ typeboxInstance: t });

const userInsertSchema = createInsertSchema(users, {
  // 我们现在可以使用扩展的实例
  name: (schema) => t.Number({ ...schema }, { error: '`name` must be a string' })
});
```

### 数据类型参考

```ts
pg.boolean();

mysql.boolean();

sqlite.integer({ mode: 'boolean' });

// 模式
Type.Boolean();
```

```ts
pg.date({ mode: 'date' });
pg.timestamp({ mode: 'date' });

mysql.date({ mode: 'date' });
mysql.datetime({ mode: 'date' });
mysql.timestamp({ mode: 'date' });

sqlite.integer({ mode: 'timestamp' });
sqlite.integer({ mode: 'timestamp_ms' });

// 模式
Type.Date();
```

```ts
pg.date({ mode: 'string' });
pg.timestamp({ mode: 'string' });
pg.cidr();
pg.inet();
pg.interval();
pg.macaddr();
pg.macaddr8();
pg.numeric();
pg.text();
pg.sparsevec();
pg.time();

mysql.binary();
mysql.date({ mode: 'string' });
mysql.datetime({ mode: 'string' });
mysql.decimal();
mysql.time();
mysql.timestamp({ mode: 'string' });
mysql.varbinary();

sqlite.numeric();
sqlite.text({ mode: 'text' });

// 模式
Type.String();
```

```ts
pg.bit({ dimensions: ... });

// 模式
t.RegExp(/^[01]+$/, { maxLength: dimensions });
```

```ts
pg.uuid();

// 模式
Type.String({ format: 'uuid' });
```

```ts
pg.char({ length: ... });

mysql.char({ length: ... });

// 模式
Type.String({ minLength: length, maxLength: length });
```

```ts
pg.varchar({ length: ... });

mysql.varchar({ length: ... });

sqlite.text({ mode: 'text', length: ... });

// 模式
Type.String({ maxLength: length });
```

```ts
mysql.tinytext();

// 模式
Type.String({ maxLength: 255 }); // 无符号 8 位整数限制
```

```ts
mysql.text();

// 模式
Type.String({ maxLength: 65_535 }); // 无符号 16 位整数限制
```

```ts
mysql.mediumtext();

// 模式
Type.String({ maxLength: 16_777_215 }); // 无符号 24 位整数限制
```

```ts
mysql.longtext();

// 模式
Type.String({ maxLength: 4_294_967_295 }); // 无符号 32 位整数限制
```

```ts
pg.text({ enum: ... });
pg.char({ enum: ... });
pg.varchar({ enum: ... });

mysql.tinytext({ enum: ... });
mysql.mediumtext({ enum: ... });
mysql.text({ enum: ... });
mysql.longtext({ enum: ... });
mysql.char({ enum: ... });
mysql.varchar({ enum: ... });
mysql.mysqlEnum(..., ...);

sqlite.text({ mode: 'text', enum: ... });

// 模式
Type.Enum(enum);
```

```ts
mysql.tinyint();

// 模式
Type.Integer({ minimum: -128, maximum: 127 }); // 8 位整数下限和上限
```

```ts
mysql.tinyint({ unsigned: true });

// 模式
Type.Integer({ minimum: 0, maximum: 255 }); // 无符号 8 位整数下限和上限
```

```ts
pg.smallint();
pg.smallserial();

mysql.smallint();

// 模式
Type.Integer({ minimum: -32_768, maximum: 32_767 }); // 16 位整数下限和上限
```

```ts
mysql.smallint({ unsigned: true });

// 模式
Type.Integer({ minimum: 0, maximum: 65_535 }); // 无符号 16 位整数下限和上限
```

```ts
pg.real();

mysql.float();

// 模式
Type.Number().min(-8_388_608).max(8_388_607); // 24 位整数下限和上限
```

```ts
mysql.mediumint();

// 模式
Type.Integer({ minimum: -8_388_608, maximum: 8_388_607 }); // 24 位整数下限和上限
```

```ts
mysql.float({ unsigned: true });

// 模式
Type.Number({ minimum: 0, maximum: 16_777_215 }); // 无符号 24 位整数下限和上限
```

```ts
mysql.mediumint({ unsigned: true });

// 模式
Type.Integer({ minimum: 0, maximum: 16_777_215 }); // 无符号 24 位整数下限和上限
```

```ts
pg.integer();
pg.serial();

mysql.int();

// 模式
Type.Integer({ minimum: -2_147_483_648, maximum: 2_147_483_647 }); // 32 位整数下限和上限
```

```ts
mysql.int({ unsigned: true });

// 模式
Type.Integer({ minimum: 0, maximum: 4_294_967_295 }); // 无符号 32 位整数下限和上限
```

```ts
pg.doublePrecision();

mysql.double();
mysql.real();

sqlite.real();

// 模式
Type.Number({ minimum: -140_737_488_355_328, maximum: 140_737_488_355_327 }); // 48 位整数下限和上限
```

```ts
mysql.double({ unsigned: true });

// 模式
Type.Numer({ minimum: 0, maximum: 281_474_976_710_655 }); // 无符号 48 位整数下限和上限
```

```ts
pg.bigint({ mode: 'number' });
pg.bigserial({ mode: 'number' });

mysql.bigint({ mode: 'number' });
mysql.bigserial({ mode: 'number' });

sqlite.integer({ mode: 'number' });

// 模式
Type.Integer({ minimum: -9_007_199_254_740_991, maximum: 9_007_199_254_740_991 }); // Javascript 最小和最大安全整数
```

```ts
mysql.serial();

Type.Integer({ minimum: 0, maximum: 9_007_199_254_740_991 }); // Javascript 最大安全整数
```

```ts
pg.bigint({ mode: 'bigint' });
pg.bigserial({ mode: 'bigint' });

mysql.bigint({ mode: 'bigint' });

sqlite.blob({ mode: 'bigint' });

// 模式
Type.BigInt({ minimum: -9_223_372_036_854_775_808n, maximum: 9_223_372_036_854_775_807n }); // 64 位整数下限和上限
```

```ts
mysql.bigint({ mode: 'bigint', unsigned: true });

// 模式
Type.BigInt({ minimum: 0, maximum: 18_446_744_073_709_551_615n }); // 无符号 64 位整数下限和上限
```

```ts
mysql.year();

// 模式
Type.Integer({ minimum: 1_901, maximum: 2_155 });
```

```ts
pg.geometry({ type: 'point', mode: 'tuple' });
pg.point({ mode: 'tuple' });

// 模式
Type.Tuple([Type.Number(), Type.Number()]);
```

```ts
pg.geometry({ type: 'point', mode: 'xy' });
pg.point({ mode: 'xy' });

// 模式
Type.Object({ x: Type.Number(), y: Type.Number() });
```

```ts
pg.halfvec({ dimensions: ... });
pg.vector({ dimensions: ... });

// 模式
Type.Array(Type.Number(), { minItems: dimensions, maxItems: dimensions });
```

```ts
pg.line({ mode: 'abc' });

// 模式
Type.Object({ a: Type.Number(), b: Type.Number(), c: Type.Number() });
```

```ts
pg.line({ mode: 'tuple' });

// 模式
Type.Tuple([Type.Number(), Type.Number(), Type.Number()]);
```

```ts
pg.json();
pg.jsonb();

mysql.json();

sqlite.blob({ mode: 'json' });
sqlite.text({ mode: 'json' });

// 模式
Type.Recursive((self) => Type.Union([Type.Union([Type.String(), Type.Number(), Type.Boolean(), Type.Null()]), Type.Array(self), Type.Record(Type.String(), self)]));
```

```ts
sqlite.blob({ mode: 'buffer' });

// Schema
t.Union([t.Union([t.String(), t.Number(), t.Boolean(), t.Null()]), t.Array(t.Any()), t.Record(t.String(), t.Any())]);
```

```ts
pg.dataType().array(...);

// 模式
Type.Array(baseDataTypeSchema, { minItems: size, maxItems: size });
```

Source: https://drizzle.zhcndoc.com/docs/update

import IsSupportedChipGroup from '@mdx/IsSupportedChipGroup.astro';
import Callout from '@mdx/Callout.astro';
import Section from '@mdx/Section.astro';

# SQL 更新

```typescript copy
await db.update(users)
  .set({ name: 'Mr. Dan' })
  .where(eq(users.name, 'Dan'));
```

传递给 `update` 的对象应具有与数据库架构中的列名相匹配的键。
对象中值为 `undefined` 的键会被忽略：要将列设置为 `null`，请传递 `null`。
您可以将 SQL 作为值传递，以在更新对象中使用，如下所示：

```typescript copy
await db.update(users)
  .set({ updatedAt: sql`NOW()` })
  .where(eq(users.name, 'Dan'));
```

### 限制

<IsSupportedChipGroup chips={{ 'PostgreSQL': false, 'MySQL': true, 'SQLite': true, 'SingleStore': true }} />

使用 `.limit()` 将 `limit` 子句添加到查询中 - 例如：
<Section>
```typescript
await db.update(usersTable).set({ verified: true }).limit(2);
```
```sql
update "users" set "verified" = $1 limit $2;
```
</Section>

### 排序
使用 `.orderBy()` 向查询添加 `order by` 子句，按指定字段对结果进行排序：
<Section>
```typescript
import { asc, desc } from 'drizzle-orm';

await db.update(usersTable).set({ verified: true }).orderBy(usersTable.name);
await db.update(usersTable).set({ verified: true }).orderBy(desc(usersTable.name));

// order by multiple fields
await db.update(usersTable).set({ verified: true }).orderBy(usersTable.name, usersTable.name2);
await db.update(usersTable).set({ verified: true }).orderBy(asc(usersTable.name), desc(usersTable.name2));
```
```sql
update "users" set "verified" = $1 order by "name";
update "users" set "verified" = $1 order by "name" desc;

update "users" set "verified" = $1 order by "name", "name2";
update "users" set "verified" = $1 order by "name" asc, "name2" desc;
```
</Section>

### 带返回值的更新
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'SQLite': true, 'MySQL': false , 'SingleStore': false}} />
您可以在 PostgreSQL 和 SQLite 中更新行并返回它：
```typescript copy
const updatedUserId: { updatedId: number }[] = await db.update(users)
  .set({ name: 'Mr. Dan' })
  .where(eq(users.name, 'Dan'))
  .returning({ updatedId: users.id });
```

## `with update`子句

<Callout>
  查看如何在 [select](/docs/select#with-clause)、[insert](/docs/insert#with-insert-clause)、[delete](/docs/delete#with-delete-clause) 中使用 WITH 语句
</Callout>

使用 `with` 子句可以通过将复杂查询拆分为称为公共表表达式 (CTE) 的较小子查询来简化查询：
<Section>
```typescript copy
const averagePrice = db.$with('average_price').as(
        db.select({ value: sql`avg(${products.price})`.as('value') }).from(products)
);

const result = await db.with(averagePrice)
		.update(products)
		.set({
			cheap: true
		})
		.where(lt(products.price, sql`(select * from ${averagePrice})`))
		.returning({
			id: products.id
		});
```
```sql
with "average_price" as (select avg("price") as "value" from "products") 
update "products" set "cheap" = $1 
where "products"."price" < (select * from "average_price") 
returning "id"
```
</Section>

## Update ... from

<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'MySQL': false, 'SQLite': true, 'SingleStore': false }} />

As the SQLite documentation mentions:

> The UPDATE-FROM idea is an extension to SQL that allows an UPDATE statement to be driven by other tables in the database. 
The "target" table is the specific table that is being updated. With UPDATE-FROM you can join the target table 
against other tables in the database in order to help compute which rows need updating and what 
the new values should be on those rows

Similarly, the PostgreSQL documentation states:

> A table expression allowing columns from other tables to appear in the WHERE condition and update expressions

Drizzle also supports this feature starting from version `drizzle-orm@0.36.3`

<Section>
```ts
await db
  .update(users)
  .set({ cityId: cities.id })
  .from(cities)
  .where(and(eq(cities.name, 'Seattle'), eq(users.name, 'John')))
```
```sql
update "users" set "city_id" = "cities"."id" 
from "cities" 
where ("cities"."name" = $1 and "users"."name" = $2)

-- params: [ 'Seattle', 'John' ]
```
</Section>

You can also alias tables that are joined (in PG, you can also alias the updating table too).
<Section>
```ts
const c = alias(cities, 'c');
await db
  .update(users)
  .set({ cityId: c.id })
  .from(c);
```
```sql
update "users" set "city_id" = "c"."id" 
from "cities" "c"
```
</Section>

<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'MySQL': false, 'SQLite': false, 'SingleStore': false }} />

In Postgres, you can also return columns from the joined tables.
<Section>
```ts
const updatedUsers = await db
  .update(users)
  .set({ cityId: cities.id })
  .from(cities)
  .returning({ id: users.id, cityName: cities.name });
```
```sql
update "users" set "city_id" = "cities"."id" 
from "cities" 
returning "users"."id", "cities"."name"
```
</Section>

Source: https://drizzle.zhcndoc.com/docs/upgrade-21

import Callout from '@mdx/Callout.astro';

## 如何迁移到 `0.21.0`

#### 1. 从你的 drizzle-kit 命令中移除所有 `:dialect` 前缀。
示例：将 `drizzle-kit push:mysql` 改为 `drizzle-kit push`。

#### 2. 更新你的 `drizzle.config.ts` 文件：
 - 在 `drizzle.config.ts` 中添加 `dialect`。这是现在的必需项，可以是 `postgresql`、`mysql` 或 `sqlite`。
 - 仅当你使用 `aws-data-api`、`turso`、`d1-http`（进行中）或 `expo` 时，才在 `drizzle.config.ts` 中添加 `driver`。否则，可以从 `drizzle.config.ts` 中删除 `driver`。
 - 如果你之前在 `dbCredentials` 中使用了 `connectionString` 或 `uri`，现在应改用 `url`。
    
```ts
import { defineConfig } from "drizzle-kit"

export default defineConfig({
    dialect: "sqlite", // "postgresql" | "mysql"
    driver: "turso", // 可选，仅在使用 `aws-data-api`、`turso`、`d1-http`（进行中）或 `expo` 时使用
    dbCredentials: {
        url: ""
    }
})
```

#### 3. 如果你正在使用 PostgreSQL 或 SQLite，并且在你的项目中生成了迁移，请运行 `drizzle-kit up`，以便 Drizzle 可以将所有快照升级到版本 6。

<Callout>
  你可以在这里查看 `0.21.0` 中所有的变更详情
</Callout>

## 更新日志

**❗ 快照升级**

所有由 PostgreSQL 和 SQLite 生成的快照将升级到版本 6。你将被提示通过运行 `drizzle-kit up` 来升级它们。

**❗ 从 `drizzle-kit` CLI 命令中移除 :dialect**

你现在可以只使用命令，例如：

- `drizzle-kit generate`
- `drizzle-kit push`
- 等等。

而无需指定方言。该参数已移至 `drizzle.config.ts`。

**❗ `drizzle.config` 更新**

- `dialect` 现在是必需的；指定你连接的数据库方言。可选项包括 `mysql`、`postgresql` 或 `sqlite`。
- `driver` 已成为可选，并将具有一个特定驱动程序，每个驱动程序都有不同的 `dbCredentials` 配置。可用的驱动程序包括：
  - `aws-data-api`
  - `turso`
  - `d1-http` - 目前进行中
  - `expo`
- `url` - 统一参数，替代之前存在的 `connectionString` 和 `uri`。
- `migrations` - 一个新的对象参数，用于指定迁移命令的自定义表和模式：
  - `table` - drizzle 将存储迁移的自定义表。
  - `schema` - drizzle 将存储迁移的自定义模式（仅限 PostgreSQL）。

所有新和更新命令的使用示例
```ts
import { defineConfig } from "drizzle-kit"

export default defineConfig({
    dialect: "sqlite", // "postgresql" | "mysql"
    driver: "turso"
    dbCredentials: {
        url: ""
    },
    migration: {
        table: "migrations",
        schema: "public"
    }
})
```

Drizzle 驱动程序选择遵循当前策略：

如果指定了 `driver`，则使用该驱动程序进行查询。

如果未指定驱动程序：

- 对于 `postgresql` 方言，Drizzle 将：
  - 检查是否安装了 `pg` 驱动程序并使用它。
  - 如果没有，尝试找到 `postgres` 驱动程序并使用它。
  - 如果仍未找到，尝试找到 `@vercel/postgres`。
  - 然后尝试 `@neondatabase/serverless`。
  - 如果未找到任何内容，将抛出错误。

- 对于 `mysql` 方言，Drizzle 将：
  - 检查是否安装了 `mysql2` 驱动程序并使用它。
  - 如果没有，尝试找到 `@planetscale/database` 并使用它。
  - 如果未找到任何内容，将抛出错误。

- 对于 `sqlite` 方言，Drizzle 将：
  - 检查是否安装了 `@libsql/client` 驱动程序并使用它。
  - 如果没有，尝试找到 `better-sqlite3` 并使用它。
  - 如果未找到任何内容，将抛出错误。

**❗ MySQL 模式/数据库不再被 drizzle-kit 支持**

Drizzle Kit 将不处理你 drizzle 模式文件中其他模式/数据库的任何模式更改。

# 新特性

**🎉 拉取关系**

Drizzle 现在将通过提取外键信息并将其转换为 `relations` 对象，从数据库中拉取 `relations`。你可以在完成反射后查看 `out` 文件夹中的 `relations.ts` 文件。

有关关系的更多信息，请查阅 [文档](/docs/rqb#declaring-relations)。


**🎉 为生成的迁移指定自定义名称**

要为你的迁移指定名称，应使用 `--name <name>`。

用法
```
drizzle-kit generate --name init_db
```

**🎉 新命令 `migrate`**

你现在可以直接从 `drizzle-kit` 将生成的迁移应用到你的数据库中。

用法
```
drizzle-kit migrate
```

默认情况下，drizzle-kit 将在 `__drizzle_migrations` 表中存储迁移数据条目，并在 PostgreSQL 的情况下存储在 `drizzle` 模式中。如果你想更改此设置，则需要在 `drizzle.config.ts` 中指定修改。

```ts
import { defineConfig } from "drizzle-kit"

export default defineConfig({
    migrations: {
        table: "migrations",
        schema: "public"
    }
})
```

Source: https://drizzle.zhcndoc.com/docs/valibot

import Npm from '@mdx/Npm.astro';
import Callout from '@mdx/Callout.astro';

# drizzle-valibot

`drizzle-valibot` 是一个 **[Drizzle ORM](https://github.com/drizzle-team/drizzle-orm)** 的插件，允许你从 Drizzle ORM 方案生成 **[Valibot](https://valibot.dev/)** 方案。

### 安装依赖

<Npm>
drizzle-valibot
</Npm>

<Callout type="warning">
此文档适用于 `drizzle-valibot@0.3.0` 及更高版本

你还必须安装 Drizzle ORM v0.36.0 或更高版本，以及 Valibot v1.0.0-beta.7 或更高版本。
</Callout>

### 选择方案

定义从数据库查询的数据形状 - 可用于验证 API 响应。

```ts copy
import { pgTable, text, integer } from 'drizzle-orm/pg-core';
import { createSelectSchema } from 'drizzle-valibot';
import { parse } from 'valibot';

const users = pgTable('users', {
  id: integer().generatedAlwaysAsIdentity().primaryKey(),
  name: text().notNull(),
  age: integer().notNull()
});

const userSelectSchema = createSelectSchema(users);

const rows = await db.select({ id: users.id, name: users.name }).from(users).limit(1);
const parsed: { id: number; name: string; age: number } = parse(userSelectSchema, rows[0]); // 错误：上述查询中未返回 `age`

const rows = await db.select().from(users).limit(1);
const parsed: { id: number; name: string; age: number } = parse(userSelectSchema, rows[0]); // 将成功解析
```

视图和枚举也受到支持。

```ts copy
import { pgEnum } from 'drizzle-orm/pg-core';
import { createSelectSchema } from 'drizzle-valibot';
import { parse } from 'valibot';

const roles = pgEnum('roles', ['admin', 'basic']);
const rolesSchema = createSelectSchema(roles);
const parsed: 'admin' | 'basic' = parse(rolesSchema, ...);

const usersView = pgView('users_view').as((qb) => qb.select().from(users).where(gt(users.age, 18)));
const usersViewSchema = createSelectSchema(usersView);
const parsed: { id: number; name: string; age: number } = parse(usersViewSchema, ...);
```

### 插入方案

定义要插入到数据库中的数据形状 - 可用于验证 API 请求。

```ts copy
import { pgTable, text, integer } from 'drizzle-orm/pg-core';
import { createInsertSchema } from 'drizzle-valibot';
import { parse } from 'valibot';

const users = pgTable('users', {
  id: integer().generatedAlwaysAsIdentity().primaryKey(),
  name: text().notNull(),
  age: integer().notNull()
});

const userInsertSchema = createInsertSchema(users);

const user = { name: 'John' };
const parsed: { name: string, age: number } = parse(userInsertSchema, user); // 错误：`age` 未定义

const user = { name: 'Jane', age: 30 };
const parsed: { name: string, age: number } = parse(userInsertSchema, user); // 将成功解析
await db.insert(users).values(parsed);
```

### 更新方案

定义要在数据库中更新的数据形状 - 可用于验证 API 请求。

```ts copy
import { pgTable, text, integer } from 'drizzle-orm/pg-core';
import { createUpdateSchema } from 'drizzle-valibot';
import { parse } from 'valibot';

const users = pgTable('users', {
  id: integer().generatedAlwaysAsIdentity().primaryKey(),
  name: text().notNull(),
  age: integer().notNull()
});

const userUpdateSchema = createUpdateSchema(users);

const user = { id: 5, name: 'John' };
const parsed: { name?: string | undefined, age?: number | undefined } = parse(userUpdateSchema, user); // 错误：`id` 是一个生成列，无法更新

const user = { age: 35 };
const parsed: { name?: string | undefined, age?: number | undefined } = parse(userUpdateSchema, user); // 将成功解析
await db.update(users).set(parsed).where(eq(users.name, 'Jane'));
```

### 细化

每个创建模式函数接受一个额外的可选参数，你可以用来扩展、修改或完全覆盖字段的方案。定义一个回调函数将扩展或修改，而提供一个 Valibot 方案将覆盖它。

```ts copy
import { pgTable, text, integer, json } from 'drizzle-orm/pg-core';
import { createSelectSchema } from 'drizzle-valibot';
import { parse, pipe, maxLength, object, string } from 'valibot';

const users = pgTable('users', {
  id: integer().generatedAlwaysAsIdentity().primaryKey(),
  name: text().notNull(),
  bio: text(),
  preferences: json()
});

const userSelectSchema = createSelectSchema(users, {
  name: (schema) => pipe(schema, maxLength(20)), // 扩展方案
  bio: (schema) => pipe(schema, maxLength(1000)), // 在变为可空/可选之前扩展方案
  preferences: object({ theme: string() }) // 覆盖字段，包括其可空性
});

const parsed: {
  id: number;
  name: string,
  bio?: string | undefined;
  preferences: {
    theme: string;
  };
} = parse(userSelectSchema, ...);
```

### 数据类型参考

```ts
pg.boolean();

mysql.boolean();

sqlite.integer({ mode: 'boolean' });

// 方案
boolean();
```

```ts
pg.date({ mode: 'date' });
pg.timestamp({ mode: 'date' });

mysql.date({ mode: 'date' });
mysql.datetime({ mode: 'date' });
mysql.timestamp({ mode: 'date' });

sqlite.integer({ mode: 'timestamp' });
sqlite.integer({ mode: 'timestamp_ms' });

// 方案
date();
```

```ts
pg.date({ mode: 'string' });
pg.timestamp({ mode: 'string' });
pg.cidr();
pg.inet();
pg.interval();
pg.macaddr();
pg.macaddr8();
pg.numeric();
pg.text();
pg.sparsevec();
pg.time();

mysql.binary();
mysql.date({ mode: 'string' });
mysql.datetime({ mode: 'string' });
mysql.decimal();
mysql.time();
mysql.timestamp({ mode: 'string' });
mysql.varbinary();

sqlite.numeric();
sqlite.text({ mode: 'text' });

// 方案
string();
```

```ts
pg.bit({ dimensions: ... });

// 方案
pipe(string(), regex(/^[01]+$/), maxLength(dimensions));
```

```ts
pg.uuid();

// 方案
pipe(string(), uuid());
```

```ts
pg.char({ length: ... });

mysql.char({ length: ... });

// 方案
pipe(string(), length(length));
```

```ts
pg.varchar({ length: ... });

mysql.varchar({ length: ... });

sqlite.text({ mode: 'text', length: ... });

// 方案
pipe(string(), maxLength(length));
```

```ts
mysql.tinytext();

// 方案
pipe(string(), maxLength(255)); // 无符号 8 位整数限制
```

```ts
mysql.text();

// 方案
pipe(string(), maxLength(65_535)); // 无符号 16 位整数限制
```

```ts
mysql.mediumtext();

// 方案
pipe(string(), maxLength(16_777_215)); // 无符号 24 位整数限制
```

```ts
mysql.longtext();

// 方案
pipe(string(), maxLength(4_294_967_295)); // 无符号 32 位整数限制
```

```ts
pg.text({ enum: ... });
pg.char({ enum: ... });
pg.varchar({ enum: ... });

mysql.tinytext({ enum: ... });
mysql.mediumtext({ enum: ... });
mysql.text({ enum: ... });
mysql.longtext({ enum: ... });
mysql.char({ enum: ... });
mysql.varchar({ enum: ... });
mysql.mysqlEnum(..., ...);

sqlite.text({ mode: 'text', enum: ... });

// 方案
enum(enum);
```

```ts
mysql.tinyint();

// 方案
pipe(number(), minValue(-128), maxValue(127), integer()); // 8 位整数上下限
```

```ts
mysql.tinyint({ unsigned: true });

// 方案
pipe(number(), minValue(0), maxValue(255), integer()); // 无符号 8 位整数上下限
```

```ts
pg.smallint();
pg.smallserial();

mysql.smallint();

// 方案
pipe(number(), minValue(-32_768), maxValue(32_767), integer()); // 16 位整数上下限
```

```ts
mysql.smallint({ unsigned: true });

// 方案
pipe(number(), minValue(0), maxValue(65_535), integer()); // 无符号 16 位整数上下限
```

```ts
pg.real();

mysql.float();

// 方案
pipe(number(), minValue(-8_388_608), maxValue(8_388_607)); // 24 位整数上下限
```

```ts
mysql.mediumint();

// 方案
pipe(number(), minValue(-8_388_608), maxValue(8_388_607), integer()); // 24 位整数上下限
```

```ts
mysql.float({ unsigned: true });

// 方案
pipe(number(), minValue(0), maxValue(16_777_215)); // 无符号 24 位整数上下限
```

```ts
mysql.mediumint({ unsigned: true });

// 方案
pipe(number(), minValue(0), maxValue(16_777_215), integer()); // 无符号 24 位整数上下限
```

```ts
pg.integer();
pg.serial();

mysql.int();

// 方案
pipe(number(), minValue(-2_147_483_648), maxValue(2_147_483_647), integer()); // 32 位整数上下限
```

```ts
mysql.int({ unsigned: true });

// 方案
pipe(number(), minValue(0), maxValue(4_294_967_295), integer()); // 无符号 32 位整数上下限
```

```ts
pg.doublePrecision();

mysql.double();
mysql.real();

sqlite.real();

// 方案
pipe(number(), minValue(-140_737_488_355_328), maxValue(140_737_488_355_327)); // 48 位整数上下限
```

```ts
mysql.double({ unsigned: true });

// 方案
pipe(number(), minValue(0), maxValue(281_474_976_710_655)); // 无符号 48 位整数上下限
```

```ts
pg.bigint({ mode: 'number' });
pg.bigserial({ mode: 'number' });

mysql.bigint({ mode: 'number' });
mysql.bigserial({ mode: 'number' });

sqlite.integer({ mode: 'number' });

// 方案
pipe(number(), minValue(-9_007_199_254_740_991), maxValue(9_007_199_254_740_991), integer()); // Javascript 最小和最大安全整数
```

```ts
mysql.serial();

// 方案
pipe(number(), minValue(0), maxValue(9_007_199_254_740_991), integer()); // Javascript 最大安全整数
```

```ts
pg.bigint({ mode: 'bigint' });
pg.bigserial({ mode: 'bigint' });

mysql.bigint({ mode: 'bigint' });

sqlite.blob({ mode: 'bigint' });

// 方案
pipe(bigint(), minValue(-9_223_372_036_854_775_808n), maxValue(9_223_372_036_854_775_807n)); // 64 位整数上下限
```

```ts
mysql.bigint({ mode: 'bigint', unsigned: true });

// 方案
pipe(bigint(), minValue(0n), maxValue(18_446_744_073_709_551_615n)); // 无符号 64 位整数上下限
```

```ts
mysql.year();

// 方案
pipe(number(), minValue(1_901), maxValue(2_155), integer());
```

```ts
pg.geometry({ type: 'point', mode: 'tuple' });
pg.point({ mode: 'tuple' });

// 方案
tuple([number(), number()]);
```

```ts
pg.geometry({ type: 'point', mode: 'xy' });
pg.point({ mode: 'xy' });

// 方案
object({ x: number(), y: number() });
```

```ts
pg.halfvec({ dimensions: ... });
pg.vector({ dimensions: ... });

// 方案
pipe(array(number()), length(dimensions));
```

```ts
pg.line({ mode: 'abc' });

// 方案
object({ a: number(), b: number(), c: number() });
```

```ts
pg.line({ mode: 'tuple' });

// 方案
tuple([number(), number(), number()]);
```

```ts
pg.json();
pg.jsonb();

mysql.json();

sqlite.blob({ mode: 'json' });
sqlite.text({ mode: 'json' });

// 方案
union([union([string(), number(), boolean(), null_()]), array(any()), record(string(), any())]);
```

```ts
sqlite.blob({ mode: 'buffer' });

// 方案
custom<Buffer>((v) => v instanceof Buffer);
```

```ts
pg.dataType().array(...);

// 方案
pipe(array(baseDataTypeSchema), length(size));
``` 

Source: https://drizzle.zhcndoc.com/docs/views

import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';
import IsSupportedChipGroup from '@mdx/IsSupportedChipGroup.astro';
import Callout from '@mdx/Callout.astro';
import Section from '@mdx/Section.astro';

# 视图

<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'SQLite': true, 'MySQL': true, 'SingleStore': false }} />
您可以通过多种方式在 Drizzle ORM 中声明视图。

你可以声明需要创建的视图，或者声明已存在于数据库中的视图。

你可以使用内联 `query builder` 语法、独立的 `query builder` 和原始的 `sql` 操作符来声明视图。

当使用内联或独立的查询构建器创建视图时，视图列的架构将自动推断，
但如果使用 `sql`，则必须显式声明视图列的架构。

### 声明视图
<Tabs items={['PostgreSQL', 'MySQL', 'SQLite']}>
  <Tab>
    <Section>
      ```ts filename="schema.ts" copy {13-14}
      import { pgTable, pgView, serial, text, timestamp } from "drizzle-orm/pg-core";

      export const user = pgTable("user", {
        id: serial(),
        name: text(),
        email: text(),
        password: text(),
        role: text().$type<"admin" | "customer">(),
        createdAt: timestamp("created_at"),
        updatedAt: timestamp("updated_at"),
      });

      export const userView = pgView("user_view").as((qb) => qb.select().from(user));
      export const customersView = pgView("customers_view").as((qb) => qb.select().from(user).where(eq(user.role, "customer")));
      ```
      ```sql
      CREATE VIEW "user_view" AS SELECT * FROM "user";
      CREATE VIEW "customers_view" AS SELECT * FROM "user" WHERE "role" = 'customer';
      ```
    </Section>
  </Tab>
  <Tab>
    <Section>
      ```ts filename="schema.ts" copy {13-14}
      import { text, mysqlTable, mysqlView, int, timestamp } from "drizzle-orm/mysql-core";

      export const user = mysqlTable("user", {
        id: int().primaryKey().autoincrement(),
        name: text(),
        email: text(),
        password: text(),
        role: text().$type<"admin" | "customer">(),
        createdAt: timestamp("created_at"),
        updatedAt: timestamp("updated_at"),
      });

      export const userView = mysqlView("user_view").as((qb) => qb.select().from(user));
      export const customersView = mysqlView("customers_view").as((qb) => qb.select().from(user).where(eq(user.role, "customer")));
      ```
      ```sql
      CREATE VIEW "user_view" AS SELECT * FROM "user";
      CREATE VIEW "customers_view" AS SELECT * FROM "user" WHERE "role" = 'customer';
      ```
    </Section>
  </Tab>
  <Tab>
    <Section>
      ```ts filename="schema.ts" copy {13-14}
      import { integer, text, sqliteView, sqliteTable } from "drizzle-orm/sqlite-core";

      export const user = sqliteTable("user", {
        id: integer().primaryKey({ autoIncrement: true }),
        name: text(),
        email: text(),
        password: text(),
        role: text().$type<"admin" | "customer">(),
        createdAt: integer("created_at"),
        updatedAt: integer("updated_at"),
      });

      export const userView = sqliteView("user_view").as((qb) => qb.select().from(user));
      export const customersView = sqliteView("customers_view").as((qb) => qb.select().from(user).where(eq(user.role, "customer")));
      ```
      ```sql
      CREATE VIEW "user_view" AS SELECT * FROM "user";
      CREATE VIEW "customers_view" AS SELECT * FROM "user" WHERE "role" = 'customer';
      ```
    </Section>
  </Tab>
</Tabs>

如果你需要一个列的子集，你可以在查询构建器中使用 `.select({ ... })` 方法，如下所示：
<Section>
  ```ts {4-6}
  export const customersView = pgView("customers_view").as((qb) => {
    return qb
      .select({
        id: user.id,
        name: user.name,
        email: user.email,
      })
      .from(user);
  });
  ```
  ```sql
  CREATE VIEW "customers_view" AS SELECT "id", "name", "email" FROM "user" WHERE "role" = 'customer';
  ```
</Section>

你也可以使用 `独立的查询构建器` 声明视图，它的工作方式完全相同：
<Tabs items={['PostgreSQL', 'MySQL', 'SQLite']}>
  <Tab>
    <Section>
      ```ts filename="schema.ts" copy {3, 15-16}
      import { pgTable, pgView, serial, text, timestamp, QueryBuilder} from "drizzle-orm/pg-core";
      
      const qb = new QueryBuilder();

      export const user = pgTable("user", {
        id: serial(),
        name: text(),
        email: text(),
        password: text(),
        role: text().$type<"admin" | "customer">(),
        createdAt: timestamp("created_at"),
        updatedAt: timestamp("updated_at"),
      });

      export const userView = pgView("user_view").as(qb.select().from(user));
      export const customersView = pgView("customers_view").as(qb.select().from(user).where(eq(user.role, "customer")));
      ```
      ```sql
      CREATE VIEW "user_view" AS SELECT * FROM "user";
      CREATE VIEW "customers_view" AS SELECT * FROM "user" WHERE "role" = 'customer';
      ```
    </Section>
  </Tab>
  <Tab>
    <Section>
      ```ts filename="schema.ts" copy {3, 15-16}
      import { text, mysqlTable, mysqlView, int, timestamp, QueryBuilder } from "drizzle-orm/mysql-core";

      const qb = new QueryBuilder();

      export const user = mysqlTable("user", {
        id: int().primaryKey().autoincrement(),
        name: text(),
        email: text(),
        password: text(),
        role: text().$type<"admin" | "customer">(),
        createdAt: timestamp("created_at"),
        updatedAt: timestamp("updated_at"),
      });

      export const userView = mysqlView("user_view").as(qb.select().from(user));
      export const customersView = mysqlView("customers_view").as(qb.select().from(user).where(eq(user.role, "customer")));
      ```
      ```sql
      CREATE VIEW "user_view" AS SELECT * FROM "user";
      CREATE VIEW "customers_view" AS SELECT * FROM "user" WHERE "role" = 'customer';
      ```
    </Section>
  </Tab>
  <Tab>
    <Section>
      ```ts filename="schema.ts" copy {3, 15-16}
      import { integer, text, sqliteView, sqliteTable, QueryBuilder } from "drizzle-orm/sqlite-core";

      const qb = new QueryBuilder();

      export const user = sqliteTable("user", {
        id: integer().primaryKey({ autoIncrement: true }),
        name: text(),
        email: text(),
        password: text(),
        role: text().$type<"admin" | "customer">(),
        createdAt: integer("created_at"),
        updatedAt: integer("updated_at"),
      });

      export const userView = sqliteView("user_view").as((qb) => qb.select().from(user));
      export const customerView = sqliteView("customers_view").as((qb) => qb.select().from(user).where(eq(user.role, "customer")));
      ```
      ```sql
      CREATE VIEW "user_view" AS SELECT * FROM "user";
      CREATE VIEW "customers_view" AS SELECT * FROM "user" WHERE "role" = 'customer';
      ```
    </Section>
  </Tab>
</Tabs>

### 使用原始 SQL 声明视图
每当你需要使用查询构建器不支持的语法声明视图时，
你可以直接使用 `sql` 操作符并显式指定视图列的架构。

```ts copy
// 常规视图
const newYorkers = pgView('new_yorkers', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  cityId: integer('city_id').notNull(),
}).as(sql`select * from ${users} where ${eq(users.cityId, 1)}`);

// 物化视图
const newYorkers = pgMaterializedView('new_yorkers', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  cityId: integer('city_id').notNull(),
}).as(sql`select * from ${users} where ${eq(users.cityId, 1)}`);
```

### 声明已存在的视图
当你获得对数据库中现有视图的只读访问权限时，可使用 `.existing()` 视图配置，
`drizzle-kit` 将忽略并不会在生成的迁移中生成 `create view` 语句。
```ts
export const user = pgTable("user", {
  id: serial(),
  name: text(),
  email: text(),
  password: text(),
  role: text().$type<"admin" | "customer">(),
  createdAt: timestamp("created_at"),
  updatedAt: timestamp("updated_at"),
});

// 常规视图
export const trimmedUser = pgView("trimmed_user", {
  id: serial("id"),
  name: text("name"),
  email: text("email"),
}).existing();

// 物化视图不会有任何区别，但你可以为一致性使用它
export const trimmedUser = pgMaterializedView("trimmed_user", {
  id: serial("id"),
  name: text("name"),
  email: text("email"),
}).existing();
```

### 物化视图
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'MySQL': false, 'SQLite': false }} />

根据官方文档，PostgreSQL 具有 **[`常规`](https://www.postgresql.org/docs/current/sql-createview.html)**
和 **[`物化`](https://www.postgresql.org/docs/current/sql-creatematerializedview.html)** 视图。

PostgreSQL 中的物化视图像视图一样使用规则系统，但以表格形式持久化结果。
{/* 这意味着，当对物化视图执行查询时，结果直接来自物化视图，
像来自表格一样，而不是通过在构成视图的基础表上执行查询来重建。 */}

Drizzle ORM 原生支持 PostgreSQL 物化视图：

<Section>
```ts filename="schema.ts" copy
const newYorkers = pgMaterializedView('new_yorkers').as((qb) => qb.select().from(users).where(eq(users.cityId, 1)));
```
```sql
CREATE MATERIALIZED VIEW "new_yorkers" AS SELECT * FROM "users";
```
</Section>

你可以在应用程序运行时刷新物化视图：
```ts copy
await db.refreshMaterializedView(newYorkers);

await db.refreshMaterializedView(newYorkers).concurrently();

await db.refreshMaterializedView(newYorkers).withNoData();
```

### 扩展示例
<Callout type="info" emoji="ℹ️">
查询中的所有参数将被内联，而不是替换为 `$1`、`$2` 等。
</Callout>

```ts copy
// 常规视图
const newYorkers = pgView('new_yorkers')
  .with({
    checkOption: 'cascaded',
    securityBarrier: true,
    securityInvoker: true,
  })
  .as((qb) => {
    const sq = qb
      .$with('sq')
      .as(
        qb.select({ userId: users.id, cityId: cities.id })
          .from(users)
          .leftJoin(cities, eq(cities.id, users.homeCity))
          .where(sql`${users.age1} > 18`),
      );
    return qb.with(sq).select().from(sq).where(sql`${users.homeCity} = 1`);
  });

// 物化视图
const newYorkers2 = pgMaterializedView('new_yorkers')
  .using('btree')
  .with({
    fillfactor: 90,
    toast_tuple_target: 0.5,
    autovacuum_enabled: true,
    ...
  })
  .tablespace('custom_tablespace')
  .withNoData()
  .as((qb) => {
    const sq = qb
      .$with('sq')
      .as(
        qb.select({ userId: users.id, cityId: cities.id })
          .from(users)
          .leftJoin(cities, eq(cities.id, users.homeCity))
          .where(sql`${users.age1} > 18`),
      );
    return qb.with(sq).select().from(sq).where(sql`${users.homeCity} = 1`);
  });
```


Source: https://drizzle.zhcndoc.com/docs/why-drizzle

import Callout from '@mdx/Callout.astro';
import CodeTabs from '@mdx/CodeTabs.astro';
import YoutubeCards from '@mdx/YoutubeCards.astro';

# Drizzle ORM  
> Drizzle 是一个好朋友，在你需要的时候会出现，在你需要空间的时候则不会打扰你。

Drizzle ORM 是一个无头的 TypeScript ORM，带有一个头。 🐲

它看起来简单、感觉简单，在你的项目第 _1000_ 天依然表现优秀，
让你可以用自己的方式进行开发，并随时为你提供帮助。  

**它是唯一一个同时拥有 [关系型](/docs/rqb) 和 [SQL 类似](/docs/select) 查询 API 的 ORM**， 
在访问关系数据时为你提供了两全其美的选择。 
Drizzle 轻量、高效、安全、无乳糖、无麸质、清醒、灵活，并且 **从设计上就支持无服务器**。
Drizzle 不仅仅是一个库，它是一种体验。 🤩

[![Drizzle bestofjs](@/assets/images/bestofjs.jpg)](https://bestofjs.org/projects/drizzle-orm)

## 无头 ORM?
首先，Drizzle 是一个库和一系列可选的工具集合。 

**ORM** 是 _对象关系映射_ 的缩写，开发者往往将 Django 式或 Spring 式工具称为 ORM。 
我们真实地认为这是一种基于遗留命名的误解，我们称它们为 **数据框架**。

<Callout type="error" emoji="️💔">
  使用数据框架，你必须围着它们 **构建项目**，而不是 **与它们共建**。
</Callout>

**Drizzle** 让你可以按照自己的方式构建项目，而不会干扰你的项目或结构。 

使用 Drizzle，你可以用 TypeScript 定义和管理数据库模式，
以 SQL 类似的方式或关系方式访问数据，并利用可选工具 
将你的开发者体验提升到 _极致_。 🤯 

## 为什么选择 SQL 类似?
**如果你知道 SQL，你就会知道 Drizzle。**

其他 ORM 和数据框架往往会让你偏离/抽象掉 SQL，
这导致了双重学习曲线：需要同时了解 SQL 和框架的 API。  

Drizzle 恰恰相反。 
我们拥抱 SQL，并让 Drizzle 在核心上 SQL 类似，这样你就可以实现零学习曲线，
并能够全面使用 SQL 的强大功能。  

我们提供所有熟悉的 **[SQL 模式](/docs/sql-schema-declaration)**、**[查询](/docs/select)**、 
**[自动迁移](/docs/migrations)** 和 **[还有一件事](/docs/rqb)**。 ✨

<CodeTabs items={["index.ts", "schema.ts", "migration.sql"]}>
```typescript copy
// 访问你的数据
await db
	.select()
	.from(countries)
	.leftJoin(cities, eq(cities.countryId, countries.id))
	.where(eq(countries.id, 10))
```
```typescript copy
// 管理你的模式
export const countries = pgTable('countries', {
  id: serial('id').primaryKey(),
  name: varchar('name', { length: 256 }),
});

export const cities = pgTable('cities', {
  id: serial('id').primaryKey(),
  name: varchar('name', { length: 256 }),
  countryId: integer('country_id').references(() => countries.id),
});
```
```sql
-- 生成迁移
CREATE TABLE IF NOT EXISTS "countries" (
	"id" serial PRIMARY KEY NOT NULL,
	"name" varchar(256)
);

CREATE TABLE IF NOT EXISTS "cities" (
	"id" serial PRIMARY KEY NOT NULL,
	"name" varchar(256),
	"country_id" integer
);

ALTER TABLE "cities" ADD CONSTRAINT "cities_country_id_countries_id_fk" FOREIGN KEY ("country_id") REFERENCES "countries"("id") ON DELETE no action ON UPDATE no action;
```
</CodeTabs>

## 为什么不选择 SQL 类似?
我们始终追求一个完美平衡的解决方案，尽管 SQL 类似能够覆盖 100% 的需求，
但在某些常见场景中，你可以更好地查询数据。  

我们为你构建了 **[查询 API](/docs/rqb)**，通过最方便和高效的方式从数据库中提取关系嵌套数据，
而无需考虑连接和数据映射。  

**Drizzle 始终输出恰好 1 条 SQL 查询。** 可以放心与无服务器数据库一起使用，永远不用担心性能或往返费用！

```ts
const result = await db.query.users.findMany({
	with: {
		posts: true
	},
});
```

## 无服务器?
<Callout type="info" emoji="🥳">
  最棒的部分是没有任何部分。 **Drizzle 精确为 0 个依赖项！**
</Callout>


![Drizzle 轻量且支持无服务器](@/assets/images/drizzle31kb.jpg)
  
Drizzle ORM 是方言特定的，轻量、高效，并且 **从设计上支持无服务器**。  

我们花费了大量时间确保你拥有最优质的 SQL 方言支持，包括 PostgreSQL、MySQL 和其他。

Drizzle 通过行业标准数据库驱动程序原生运行。我们支持所有主要的 **[PostgreSQL](/docs/get-started-postgresql)**、**[MySQL](/docs/get-started-mysql)** 或 **[SQLite](/docs/get-started-sqlite)** 驱动程序，并且我们正在 **[快速添加新驱动](https://twitter.com/DrizzleORM/status/1653082492742647811?s=20)**。 


## 欢迎加入！
越来越多的公司在生产中采用 Drizzle，享受开发体验和性能的巨大好处。

**我们始终在这里提供帮助，因此请随时与我们联系。我们将乐意协助你在 Drizzle 的旅程！**

我们有一个出色的 **[Discord 社区](https://driz.link/discord)**，欢迎所有开发者加入我们的 **[Twitter](https://twitter.com/drizzleorm)**。
  
现在开始使用 Drizzle 和你的 **[PostgreSQL](/docs/get-started-postgresql)**、**[MySQL](/docs/get-started-mysql)** 或 **[SQLite](/docs/get-started-sqlite)** 数据库构建一些很棒的东西吧。 🚀

### 视频展示

{/* tRPC + NextJS 应用路由 = 简单的类型安全 API
Jack Herrington 19:17
https://www.youtube.com/watch?v=qCLV0Iaq9zU */}
{/* https://www.youtube.com/watch?v=qDunJ0wVIec */}
{/* https://www.youtube.com/watch?v=NZpPMlSAez0 */}

 {/* https://www.youtube.com/watch?v=-A0kMiJqQRY */}

<YoutubeCards cards={[
	{
		id: "vyU5mJGCJMw",
		title: "初学者的完整 Drizzle 课程",
		description: "Code Genix",
		time: "1:37:39",
	},
	{
		id: "7-NZ0MlPpJA",
		title: "60 分钟学会 Drizzle",
		description: "Web Dev Simplified",
		time: "56:09"
	},
	{
		id: "i_mAHOhpBSA",
		title: "100 秒了解 Drizzle ORM",
		description: "Fireship",
		time: "2:55"
	},
	{
		id: "hIYNOiZXQ7Y",
		title: "13 分钟学会 Drizzle ORM（速成课程）",
		description: "Neon",
		time: "14:00"
	},
	{
		id: "4ZhtoOFKFP8",
		title: "在 Next.js&nbsp;14 中使用 Turso&nbsp;&&nbsp;Drizzle 的最简单数据库设置",
		description: "Sam Meech-Ward",
		time: '38:08'
	}, 
	{
		id: "NfVELsEZFsA",
		title: "使用 Vercel、Neon、Drizzle、TailwindCSS、FlowBite 等的 Next.js 项目！",
		description: "CodingEntrepreneurs",
		time: '5:46:28'
	}, 
	{
		id: "_SLxGYzv6jo",
		title: "我有了新的最爱数据库工具",
		description: "Theo - t3.gg",
		time: '5:46'
	}, 
	{
		id: "Qo-RXkSwOtc",
		title: "Drizzle ORM 初印象 - 迁移、关系、查询！",
		description: "Marius Espejo",
		time: '33:52'
	},
	{
		id: "yXNEqyvA0OY",
		title: "我想学习 Drizzle ORM，所以我在另一个 next14 项目中开始",
		description: "Web Dev Cody",
		time: "9:00"
	},
	{
		id: "h7vVhR-dFYo",
		title: "选择一个 ORM 变得越来越困难...",
		description: "Ben Davis",
		time: "5:18"
	},
	{
		id: "8met6WTk0mQ",
		title: "这个新的数据库工具是一个游戏规则的改变者",
		description: "Josh tried coding",
		time: "8:49"
	},
	{
		id: "woWW1T9DXEY",
		title: "我喜欢的数据库工具变得更好了",
		description: "Josh tried coding",
		time: "4:23"
	},
	{
		id: "A3l6YYkXzzg",
		title: "带实时光标的 SaaS Notion 克隆，Nextjs 13，Stripe，Drizzle ORM，Tailwind，Supabase，Sockets",
		description: "Web Prodigies",
		time: "11:41:46"
	},
	{
		id: "EQfaw5bDE1s",
		title: "SvelteKit + Drizzle 代码解析",
		description: "Ben Davis",
		time: "12:18"
	},
	{
		id: "b6VhN_HHDiQ",
		title: "构建一个多租户、基于角色的访问控制系统",
		description: "TomDoesTech",
		time: "2:01:29"
	},
	{
		id: "3tl9XCiQErA",
		title: "Prisma 杀手终于来了",
		description: "SST",
		time: "5:42"
	},
	{
		id: "VQFjyEa8vGE",
		title: "学习 Drizzle ORM 并在一个 next14 项目中工作",
		description: "Web Dev Cody",
		time: "1:07:41"
	},
	{
		id: "5G0upg4sxgE",
		title: "这个技巧让我的最爱数据库工具变得更好",
		description: "Josh tried coding",
		time: "6:01"
	},
	{
		id: "-JnEuvPmt-Q",
		title: "在 Next.js 14 中轻松实现身份验证：使用 Auth.js 和 Drizzle ORM 进行安全登录",
		description: "Sam Meech-Ward",
		time: "26:29"
	},
]} />


Source: https://drizzle.zhcndoc.com/docs/zod

import Npm from '@mdx/Npm.astro';
import Callout from '@mdx/Callout.astro';

# drizzle-zod

`drizzle-zod` 是一个 **[Drizzle ORM](https://github.com/drizzle-team/drizzle-orm)** 的插件，允许你从 Drizzle ORM 生成 **[Zod](https://github.com/colinhacks/zod)** 模式。

### 安装依赖

<Npm>
drizzle-zod
</Npm>

<Callout type="warning">
该文档适用于 `drizzle-zod@0.6.0` 及更高版本

你还必须安装 Drizzle ORM v0.36.0 或更高版本以及 Zod v3.25.1 或更高版本。
</Callout>

### 选择模式

定义从数据库查询的数据形状 - 可用于验证 API 响应。

```ts copy
import { pgTable, text, integer } from 'drizzle-orm/pg-core';
import { createSelectSchema } from 'drizzle-zod';

const users = pgTable('users', {
  id: integer().generatedAlwaysAsIdentity().primaryKey(),
  name: text().notNull(),
  age: integer().notNull()
});

const userSelectSchema = createSelectSchema(users);

const rows = await db.select({ id: users.id, name: users.name }).from(users).limit(1);
const parsed: { id: number; name: string; age: number } = userSelectSchema.parse(rows[0]); // 错误：`age` 在上面的查询中未返回

const rows = await db.select().from(users).limit(1);
const parsed: { id: number; name: string; age: number } = userSelectSchema.parse(rows[0]); // 将成功解析
```

视图和枚举也受到支持。

```ts copy
import { pgEnum } from 'drizzle-orm/pg-core';
import { createSelectSchema } from 'drizzle-zod';

const roles = pgEnum('roles', ['admin', 'basic']);
const rolesSchema = createSelectSchema(roles);
const parsed: 'admin' | 'basic' = rolesSchema.parse(...);

const usersView = pgView('users_view').as((qb) => qb.select().from(users).where(gt(users.age, 18)));
const usersViewSchema = createSelectSchema(usersView);
const parsed: { id: number; name: string; age: number } = usersViewSchema.parse(...);
```

### 插入模式

定义要插入到数据库中的数据形状 - 可用于验证 API 请求。

```ts copy
import { pgTable, text, integer } from 'drizzle-orm/pg-core';
import { createInsertSchema } from 'drizzle-zod';

const users = pgTable('users', {
  id: integer().generatedAlwaysAsIdentity().primaryKey(),
  name: text().notNull(),
  age: integer().notNull()
});

const userInsertSchema = createInsertSchema(users);

const user = { name: 'John' };
const parsed: { name: string, age: number } = userInsertSchema.parse(user); // 错误：`age` 未定义

const user = { name: 'Jane', age: 30 };
const parsed: { name: string, age: number } = userInsertSchema.parse(user); // 将成功解析
await db.insert(users).values(parsed);
```

### 更新模式

定义要更新的数据库中的数据形状 - 可用于验证 API 请求。

```ts copy
import { pgTable, text, integer } from 'drizzle-orm/pg-core';
import { createUpdateSchema } from 'drizzle-zod';

const users = pgTable('users', {
  id: integer().generatedAlwaysAsIdentity().primaryKey(),
  name: text().notNull(),
  age: integer().notNull()
});

const userUpdateSchema = createUpdateSchema(users);

const user = { id: 5, name: 'John' };
const parsed: { name?: string | undefined, age?: number | undefined } = userUpdateSchema.parse(user); // 错误：`id` 是一个生成列，无法更新

const user = { age: 35 };
const parsed: { name?: string | undefined, age?: number | undefined } = userUpdateSchema.parse(user); // 将成功解析
await db.update(users).set(parsed).where(eq(users.name, 'Jane'));
```

### 精细化

每个创建模式函数接受一个额外的可选参数，你可以用来扩展、修改或完全覆盖字段的模式。定义一个回调函数将扩展或修改，提供一个 Zod 模式将覆盖它。

```ts copy
import { pgTable, text, integer, json } from 'drizzle-orm/pg-core';
import { createSelectSchema } from 'drizzle-zod';
import { z } from 'zod/v4';

const users = pgTable('users', {
  id: integer().primaryKey(),
  name: text().notNull(),
  bio: text(),
  preferences: json()
});

const userSelectSchema = createSelectSchema(users, {
  name: (schema) => schema.max(20), // 扩展模式
  bio: (schema) => schema.max(1000), // 扩展模式，使其可为空/可选
  preferences: z.object({ theme: z.string() }) // 覆盖字段，包括其可空性
});

const parsed: {
  id: number;
  name: string,
  bio?: string | undefined;
  preferences: {
    theme: string;
  };
} = userSelectSchema.parse(...);
```

### 工厂函数

对于更高级的用例，你可以使用 `createSchemaFactory` 函数。

**用例：使用扩展的 Zod 实例**

```ts copy
import { pgTable, text, integer } from 'drizzle-orm/pg-core';
import { createSchemaFactory } from 'drizzle-zod';
import { z } from '@hono/zod-openapi'; // 扩展的 Zod 实例

const users = pgTable('users', {
  id: integer().generatedAlwaysAsIdentity().primaryKey(),
  name: text().notNull(),
  age: integer().notNull()
});

const { createInsertSchema } = createSchemaFactory({ zodInstance: z });

const userInsertSchema = createInsertSchema(users, {
  // 现在我们可以使用扩展的实例
  name: (schema) => schema.openapi({ example: 'John' })
});
```

**用例：类型强制转换**

```ts copy
import { pgTable, timestamp } from 'drizzle-orm/pg-core';
import { createSchemaFactory } from 'drizzle-zod';
import { z } from 'zod/v4';

const users = pgTable('users', {
  ...,
  createdAt: timestamp().notNull()
});

const { createInsertSchema } = createSchemaFactory({
  // This configuration will only coerce dates. Set `coerce` to `true` to coerce all data types or specify others
  coerce: {
    date: true
  }
});

const userInsertSchema = createInsertSchema(users);
// The above is the same as this:
const userInsertSchema = z.object({
  ...,
  createdAt: z.coerce.date()
});
```

### 数据类型参考

```ts
pg.boolean();

mysql.boolean();

sqlite.integer({ mode: 'boolean' });

// 模式
z.boolean();
```

```ts
pg.date({ mode: 'date' });
pg.timestamp({ mode: 'date' });

mysql.date({ mode: 'date' });
mysql.datetime({ mode: 'date' });
mysql.timestamp({ mode: 'date' });

sqlite.integer({ mode: 'timestamp' });
sqlite.integer({ mode: 'timestamp_ms' });

// 模式
z.date();
```

```ts
pg.date({ mode: 'string' });
pg.timestamp({ mode: 'string' });
pg.cidr();
pg.inet();
pg.interval();
pg.macaddr();
pg.macaddr8();
pg.numeric();
pg.text();
pg.sparsevec();
pg.time();

mysql.binary();
mysql.date({ mode: 'string' });
mysql.datetime({ mode: 'string' });
mysql.decimal();
mysql.time();
mysql.timestamp({ mode: 'string' });
mysql.varbinary();

sqlite.numeric();
sqlite.text({ mode: 'text' });

// 模式
z.string();
```

```ts
pg.bit({ dimensions: ... });

// 模式
z.string().regex(/^[01]+$/).max(dimensions);
```

```ts
pg.uuid();

// 模式
z.string().uuid();
```

```ts
pg.char({ length: ... });

mysql.char({ length: ... });

// 模式
z.string().length(length);
```

```ts
pg.varchar({ length: ... });

mysql.varchar({ length: ... });

sqlite.text({ mode: 'text', length: ... });

// 模式
z.string().max(length);
```

```ts
mysql.tinytext();

// 模式
z.string().max(255); // 无符号 8 位整数限制
```

```ts
mysql.text();

// 模式
z.string().max(65_535); // 无符号 16 位整数限制
```

```ts
mysql.mediumtext();

// 模式
z.string().max(16_777_215); // 无符号 24 位整数限制
```

```ts
mysql.longtext();

// 模式
z.string().max(4_294_967_295); // 无符号 32 位整数限制
```

```ts
pg.text({ enum: ... });
pg.char({ enum: ... });
pg.varchar({ enum: ... });

mysql.tinytext({ enum: ... });
mysql.mediumtext({ enum: ... });
mysql.text({ enum: ... });
mysql.longtext({ enum: ... });
mysql.char({ enum: ... });
mysql.varchar({ enum: ... });
mysql.mysqlEnum(..., ...);

sqlite.text({ mode: 'text', enum: ... });

// 模式
z.enum(enum);
```

```ts
mysql.tinyint();

// 模式
z.number().min(-128).max(127).int(); // 8 位整数下限和上限
```

```ts
mysql.tinyint({ unsigned: true });

// 模式
z.number().min(0).max(255).int(); // 无符号 8 位整数下限和上限
```

```ts
pg.smallint();
pg.smallserial();

mysql.smallint();

// 模式
z.number().min(-32_768).max(32_767).int(); // 16 位整数下限和上限
```

```ts
mysql.smallint({ unsigned: true });

// 模式
z.number().min(0).max(65_535).int(); // 无符号 16 位整数下限和上限
```

```ts
pg.real();

mysql.float();

// 模式
z.number().min(-8_388_608).max(8_388_607); // 24 位整数下限和上限
```

```ts
mysql.mediumint();

// 模式
z.number().min(-8_388_608).max(8_388_607).int(); // 24 位整数下限和上限
```

```ts
mysql.float({ unsigned: true });

// 模式
z.number().min(0).max(16_777_215); // 无符号 24 位整数下限和上限
```

```ts
mysql.mediumint({ unsigned: true });

// 模式
z.number().min(0).max(16_777_215).int(); // 无符号 24 位整数下限和上限
```

```ts
pg.integer();
pg.serial();

mysql.int();

// 模式
z.number().min(-2_147_483_648).max(2_147_483_647).int(); // 32 位整数下限和上限
```

```ts
mysql.int({ unsigned: true });

// 模式
z.number().min(0).max(4_294_967_295).int(); // 无符号 32 位整数下限和上限
```

```ts
pg.doublePrecision();

mysql.double();
mysql.real();

sqlite.real();

// 模式
z.number().min(-140_737_488_355_328).max(140_737_488_355_327); // 48 位整数下限和上限
```

```ts
mysql.double({ unsigned: true });

// 模式
z.number().min(0).max(281_474_976_710_655); // 无符号 48 位整数下限和上限
```

```ts
pg.bigint({ mode: 'number' });
pg.bigserial({ mode: 'number' });

mysql.bigint({ mode: 'number' });
mysql.bigserial({ mode: 'number' });

sqlite.integer({ mode: 'number' });

// 模式
z.number().min(-9_007_199_254_740_991).max(9_007_199_254_740_991).int(); // Javascript 最小和最大安全整数
```

```ts
mysql.serial();

// 模式
z.number().min(0).max(9_007_199_254_740_991).int(); // Javascript 最大安全整数
```

```ts
pg.bigint({ mode: 'bigint' });
pg.bigserial({ mode: 'bigint' });

mysql.bigint({ mode: 'bigint' });

sqlite.blob({ mode: 'bigint' });

// 模式
z.bigint().min(-9_223_372_036_854_775_808n).max(9_223_372_036_854_775_807n); // 64 位整数下限和上限
```

```ts
mysql.bigint({ mode: 'bigint', unsigned: true });

// 模式
z.bigint().min(0).max(18_446_744_073_709_551_615n); // 无符号 64 位整数下限和上限
```

```ts
mysql.year();

// 模式
z.number().min(1_901).max(2_155).int();
```

```ts
pg.geometry({ type: 'point', mode: 'tuple' });
pg.point({ mode: 'tuple' });

// 模式
z.tuple([z.number(), z.number()]);
```

```ts
pg.geometry({ type: 'point', mode: 'xy' });
pg.point({ mode: 'xy' });

// 模式
z.object({ x: z.number(), y: z.number() });
```

```ts
pg.halfvec({ dimensions: ... });
pg.vector({ dimensions: ... });

// 模式
z.array(z.number()).length(dimensions);
```

```ts
pg.line({ mode: 'abc' });

// 模式
z.object({ a: z.number(), b: z.number(), c: z.number() });
```

```ts
pg.line({ mode: 'tuple' });

// 模式
z.tuple([z.number(), z.number(), z.number()]);
```

```ts
pg.json();
pg.jsonb();

mysql.json();

sqlite.blob({ mode: 'json' });
sqlite.text({ mode: 'json' });

// 模式
z.union([z.union([z.string(), z.number(), z.boolean(), z.null()]), z.record(z.any()), z.array(z.any())]);
```

```ts
sqlite.blob({ mode: 'buffer' });

// 模式
z.custom<Buffer>((v) => v instanceof Buffer);
```

```ts
pg.dataType().array(...);

// 模式
z.array(baseDataTypeSchema).length(size);
```

