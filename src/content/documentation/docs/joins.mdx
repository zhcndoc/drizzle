import CodeTabs from '@components/markdown/CodeTabs.astro';
import CodeTab from '@components/markdown/CodeTab.astro';
import Section from '@components/markdown/Section.astro';

# 连接 [SQL]
SQL 中的连接子句用于组合 2 个或更多表，基于它们之间的相关列。
Drizzle ORM 的连接语法是在 SQL 类似性与类型安全性之间取得平衡。

## 连接类型
Drizzle ORM 提供了 `INNER JOIN`、`FULL JOIN`、`LEFT JOIN` 和 `RIGHT JOIN` 的 API。
让我们快速浏览一下基于以下表模式的示例：
```typescript copy
export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
});

export const pets = pgTable('pets', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  ownerId: integer('owner_id').notNull().references(() => users.id),
})
```

### 左连接
<Section>
```typescript copy
const result = await db.select().from(users).leftJoin(pets, eq(users.id, pets.ownerId))
```
```sql
select ... from "users" left join "pets" on "users"."id" = "pets"."owner_id"
```
```typescript
// 结果类型
const result: {
    user: {
        id: number;
        name: string;
    };
    pets: {
        id: number;
        name: string;
        ownerId: number;
    } | null;
}[];
```
</Section>

### 右连接
<Section>
```typescript copy
const result = await db.select().from(users).rightJoin(pets, eq(users.id, pets.ownerId))
```
```sql
select ... from "users" right join "pets" on "users"."id" = "pets"."owner_id"
```
```typescript
// 结果类型
const result: {
    user: {
        id: number;
        name: string;
    } | null;
    pets: {
        id: number;
        name: string;
        ownerId: number;
    };
}[];
```
</Section>
### 内连接
<Section>
```typescript copy
const result = await db.select().from(users).innerJoin(pets, eq(users.id, pets.ownerId))
```
```sql
select ... from "users" inner join "pets" on "users"."id" = "pets"."owner_id"
```
```typescript
// 结果类型
const result: {
    user: {
        id: number;
        name: string;
    };
    pets: {
        id: number;
        name: string;
        ownerId: number;
    };
}[];
```
</Section>
### 全连接
<Section>
```typescript copy
const result = await db.select().from(users).fullJoin(pets, eq(users.id, pets.ownerId))
```
```sql
select ... from "users" full join "pets" on "users"."id" = "pets"."owner_id"
```
```typescript
// 结果类型
const result: {
    user: {
        id: number;
        name: string;
    } | null;
    pets: {
        id: number;
        name: string;
        ownerId: number;
    } | null;
}[];
```
</Section>

## 部分选择
如果您需要选择特定字段子集或具有扁平响应类型，
Drizzle ORM 支持部分选择的连接，并将根据 `.select({ ... })` 结构自动推断返回类型。
<Section>
```typescript copy
await db.select({
  userId: users.id,
  petId: pets.id,
}).from(user).leftJoin(pets, eq(users.id, pets.ownerId))
```
```sql
select "users"."id", "pets"."id" from "users" left join "pets" on "users"."id" = "pets"."owner_id"
```
```typescript
// 结果类型
const result: {
  userId: number;
  petId: number | null;
}[];
```
</Section>
您可能注意到 `petId` 现在可以为 null，这是因为我们正在进行左连接，并且可能有没有宠物的用户。

在使用 `sql` 操作符进行字段的部分选择和汇总时，
记住使用 `sql<type | null>` 以正确推断结果类型，这完全取决于您！
<Section>
```typescript copy
const result = await db.select({
  userId: users.id,
  petId: pets.id,
  petName1: sql`upper(${pets.name})`,
  petName2: sql<string | null>`upper(${pets.name})`,
  //˄我们应该在类型中明确指出 'string | null'，因为我们正在左连接该字段
}).from(user).leftJoin(pets, eq(users.id, pets.ownerId))
```
```sql
select "users"."id", "pets"."id", upper("pets"."name")... from "users" left join "pets" on "users"."id" = "pets"."owner_id"
```
```typescript
// 结果类型
const result: {
  userId: number;
  petId: number | null;
  petName1: unknown;
  petName2: string | null;
}[];
```
</Section>
为了避免在连接具有大量列的表时出现大量可为 null 的字段，我们可以利用我们的 **嵌套选择对象语法**，
我们的智能类型推断将使整个对象变为可为 null，而不是将所有表字段都设为可为 null！
<Section>
```typescript copy
await db.select({
  userId: users.id,
  userName: users.name,
  pet: {
    id: pets.id,
    name: pets.name,
    upperName: sql<string>`upper(${pets.name})`
  }
}).from(user).fullJoin(pets, eq(users.id, pets.ownerId))
```
```sql
select ... from "users" full join "pets" on "users"."id" = "pets"."owner_id"
```
```typescript
// 结果类型
const result: {
    userId: number | null;
    userName: string | null;
    pet: {
        id: number;
        name: string;
        upperName: string;
    } | null;
}[];
```
</Section>

## 别名和自连接
Drizzle ORM 支持表别名，这在您需要进行自连接时非常方便。

假设您需要获取带有父母的用户：
<CodeTabs items={["index.ts", "schema.ts"]}>
<CodeTab>
```typescript copy
import { user } from "./schema";

const parent = aliasedTable(user, "parent")
const result = db
  .select()
  .from(user)
  .leftJoin(parent, eq(parent.id, user.parentId));
```
```sql
select ... from "user" left join "user" "parent" on "parent"."id" = "user"."parent_id"
```
```typescript
// 结果类型
const result: {
    user: {
        id: number;
        name: string;
        parentId: number;
    };
    parent: {
        id: number;
        name: string;
        parentId: number;
    } | null;
}[];
```
</CodeTab>

```typescript
export const user = pgTable("user", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  name: text("name").notNull(),
  parentId: integer("parent_id").notNull().references((): AnyPgColumn => user.id)
});
```

</CodeTabs>

## 聚合结果
Drizzle ORM 从驱动程序传递名称映射的结果，而无需更改结构。

您可以自由地操作结果，下面是映射多对一关系数据的示例：
```typescript
type User = typeof users.$inferSelect;
type Pet = typeof pets.$inferSelect;

const rows = db.select({
    user: users,
    pet: pets,
  }).from(users).leftJoin(pets, eq(users.id, pets.ownerId)).all();

const result = rows.reduce<Record<number, { user: User; pets: Pet[] }>>(
  (acc, row) => {
    const user = row.user;
    const pet = row.pet;

    if (!acc[user.id]) {
      acc[user.id] = { user, pets: [] };
    }

    if (pet) {
      acc[user.id].pets.push(pet);
    }

    return acc;
  },
  {}
);

// 结果类型
const result: Record<number, {
    user: User;
    pets: Pet[];
}>;
```

## 一对多示例
```typescript
import { sqliteTable, text, integer } from 'drizzle-orm/sqlite-core';
import { drizzle } from 'drizzle-orm/better-sqlite3';

const cities = sqliteTable('cities', {
  id: integer('id').primaryKey(),
  name: text('name'),
});

const users = sqliteTable('users', {
  id: integer('id').primaryKey(),
  name: text('name'),
  cityId: integer('city_id').references(() => cities.id)
});

const db = drizzle();

const result = db.select().from(cities).leftJoin(users, eq(cities.id, users.cityId)).all();
```
## 多对多示例
```typescript
const users = sqliteTable('users', {
  id: integer('id').primaryKey(),
  name: text('name'),
});

const chatGroups = sqliteTable('chat_groups', {
  id: integer('id').primaryKey(),
  name: text('name'),
});

const usersToChatGroups = sqliteTable('usersToChatGroups', {
  userId: integer('user_id').notNull().references(() => users.id),
  groupId: integer('group_id').notNull().references(() => chatGroups.id),
});


// 查询 ID 为 1 的用户组及所有参与者（用户）
db.select()
  .from(usersToChatGroups)
  .leftJoin(users, eq(usersToChatGroups.userId, users.id))
  .leftJoin(chatGroups, eq(usersToChatGroups.groupId, chatGroups.id))
  .where(eq(chatGroups.id, 1))
  .all();
```
