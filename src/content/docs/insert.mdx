import IsSupportedChipGroup from '@mdx/IsSupportedChipGroup.astro';
import Section from '@mdx/Section.astro';
import Callout from '@mdx/Callout.astro';
import Tab from '@mdx/Tab.astro';
import Tabs from '@mdx/Tabs.astro';

# SQL 插入
Drizzle ORM 为您提供最接近 SQL 的方式将行插入数据库表中。

插入数据使用 Drizzle 极其简单且类似 SQL。您自己看：

<Section>
```typescript copy 
await db.insert(users).values({ name: 'Andrew' });
```
```sql
insert into "users" ("name") values ("Andrew");
```
</Section>

如果您需要某个特定表的插入类型，可以使用 `typeof usersTable.$inferInsert` 语法。
```typescript copy 
type NewUser = typeof users.$inferInsert;

const insertUser = async (user: NewUser) => {
  return db.insert(users).values(user);
}

const newUser: NewUser = { name: "Alef" };
await insertUser(newUser);
```

## returning
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'SQLite': true, 'MySQL': false, 'SingleStore': false, 'MSSQL': false, 'CockroachDB': true }} />
您可以在 PostgreSQL 和 SQLite 中插入一行并获得返回，如下所示：
```typescript copy
await db.insert(users).values({ name: "Dan" }).returning();

// 部分返回
await db.insert(users).values({ name: "Partial Dan" }).returning({ insertedId: users.id });
```

## $returningId
<IsSupportedChipGroup chips={{ 'PostgreSQL': false, 'SQLite': false, 'MySQL': true, 'SingleStore': true, 'MSSQL': false, 'CockroachDB': false }} />

MySQL 本身并不原生支持 `INSERT` 后使用 `RETURNING`。对于 `自增`（或 `序列`）类型的 `主键`，只有一种方式可以做到，您可以访问 `insertId` 和 `affectedRows` 字段。我们为您准备了一种自动处理此类情况的方法，使用 Drizzle 自动接收所有插入的 ID 作为独立对象。

```ts
import { boolean, int, text, mysqlTable } from 'drizzle-orm/mysql-core';

const usersTable = mysqlTable('users', {
  id: int('id').primaryKey(),
  name: text('name').notNull(),
  verified: boolean('verified').notNull().default(false),
});


const result = await db.insert(usersTable).values([{ name: 'John' }, { name: 'John1' }]).$returningId();
//    ^? { id: number }[]
```

使用 Drizzle，您还可以指定一个使用 `$default` 函数的 `主键`，该函数将在运行时生成自定义主键。我们也将在 `$returningId()` 调用中返回这些生成的键。

```ts
import { varchar, text, mysqlTable } from 'drizzle-orm/mysql-core';
import { createId } from '@paralleldrive/cuid2';

const usersTableDefFn = mysqlTable('users_default_fn', {
  customId: varchar('id', { length: 256 }).primaryKey().$defaultFn(createId),
  name: text('name').notNull(),
});


const result = await db.insert(usersTableDefFn).values([{ name: 'John' }, { name: 'John1' }]).$returningId();
//  ^? { customId: string }[]
```

> 如果没有主键 -> 这种查询的类型将是 `{}[]`

## output
<IsSupportedChipGroup chips={{ 'MSSQL': true }} />
您可以在 PostgreSQL 和 SQLite 中插入一行并获得返回，如下所示：
```typescript copy
await db.insert(users).values({ name: "Dan" }).output();

// 部分返回
await db.insert(users).values({ name: "Partial Dan" }).output({ insertedId: users.id });
```

## 插入多行
```typescript copy
await db.insert(users).values([{ name: 'Andrew' }, { name: 'Dan' }]);
```

## 插入或更新及冲突处理
Drizzle ORM 提供了简单的接口来处理插入或更新以及冲突。

### 冲突时不执行任何操作
<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'SQLite': true, 'MySQL': false, 'SingleStore': false, 'CockroachDB': true }} />

`onConflictDoNothing` 会在发生冲突时取消插入：

```typescript copy
await db.insert(users)
  .values({ id: 1, name: 'John' })
  .onConflictDoNothing();

// 显式指定冲突目标
await db.insert(users)
  .values({ id: 1, name: 'John' })
  .onConflictDoNothing({ target: users.id });
```

### 冲突时进行更新

<IsSupportedChipGroup chips={{ 'PostgreSQL': true, 'SQLite': true, 'MySQL': false }} />

`onConflictDoUpdate` 会在发生冲突时更新该行：
```typescript
await db.insert(users)
  .values({ id: 1, name: 'Dan' })
  .onConflictDoUpdate({ target: users.id, set: { name: 'John' } });
```

#### `where` 子句

`冲突时更新` 可以在两个不同位置使用 `where` 子句 ——  
作为冲突目标的一部分（即用于部分索引）或作为 `更新` 子句的一部分：

```sql
insert into employees (employee_id, name)
values (123, 'John Doe')
on conflict (employee_id) where name <> 'John Doe'
do update set name = excluded.name

insert into employees (employee_id, name)
values (123, 'John Doe')
on conflict (employee_id) do update set name = excluded.name
where name <> 'John Doe';
```

要在 Drizzle 中指定这些条件，您可以使用 `setWhere` 和 `targetWhere` 子句：

```typescript
await db.insert(employees)
  .values({ employeeId: 123, name: 'John Doe' })
  .onConflictDoUpdate({
    target: employees.employeeId,
    targetWhere: sql`name <> 'John Doe'`,
    set: { name: sql`excluded.name` }
  });

await db.insert(employees)
  .values({ employeeId: 123, name: 'John Doe' })
  .onConflictDoUpdate({
    target: employees.employeeId,
    set: { name: 'John Doe' },
    setWhere: sql`name <> 'John Doe'`
  });
```

<hr />

使用复合索引或复合主键进行插入或更新及冲突处理：

```typescript
await db.insert(users)
  .values({ firstName: 'John', lastName: 'Doe' })
  .onConflictDoUpdate({
    target: [users.firstName, users.lastName],
    set: { firstName: 'John1' }
  });
```

### 主键重复时更新
<IsSupportedChipGroup chips={{ 'PostgreSQL': false, 'SQLite': false, 'MySQL': true, 'SingleStore': true, 'CockroachDB': false }} />

MySQL 支持 [`ON DUPLICATE KEY UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html) 代替 `ON CONFLICT` 子句。MySQL 会根据主键和唯一索引自动确定冲突目标，如果 *任何* 唯一索引冲突，将更新该行。

Drizzle 通过 `onDuplicateKeyUpdate` 方法支持这一点：

```typescript
// 注意，MySQL 自动根据主键和唯一索引确定目标
await db.insert(users)
  .values({ id: 1, name: 'John' })
  .onDuplicateKeyUpdate({ set: { name: 'John' } });
```

虽然 MySQL 不直接支持冲突时什么都不做，您可以通过将任意列的值设置为自身来执行无操作，从而达到相同的效果：

```typescript
import { sql } from 'drizzle-orm';

await db.insert(users)
  .values({ id: 1, name: 'John' })
  .onDuplicateKeyUpdate({ set: { id: sql`id` } });
```

## `with insert` 子句

<Callout>
  查看如何使用 WITH 语句与 [select](/docs/select#with-clause)、[update](/docs/update#with-update-clause)、[delete](/docs/delete#with-delete-clause)
</Callout>

使用 `with` 子句可以帮助您通过将复杂查询拆分为称为公共表表达式 (CTEs) 的较小子查询来简化复杂查询：
<Section>
```typescript copy
const userCount = db.$with('user_count').as(
	db.select({ value: sql`count(*)`.as('value') }).from(users)
);

const result = await db.with(userCount)
	.insert(users)
	.values([
		{ username: 'user1', admin: sql`((select * from ${userCount}) = 0)` }
	])
	.returning({
		admin: users.admin
	});
```
```sql
with "user_count" as (select count(*) as "value" from "users") 
insert into "users" ("username", "admin") 
values ($1, ((select * from "user_count") = 0)) 
returning "admin"
```
</Section>


## Insert into ... select

正如 SQLite 文档所述：

<Callout>
INSERT 语句的第二种形式包含一个 SELECT 语句代替 VALUES 子句。  
通过执行 SELECT 语句返回的每一行数据都会插入表中一个新条目。  
如果指定了列列表，SELECT 结果中的列数必须与列列表中的项目数相同。  
否则，如果未指定列列表，SELECT 结果中的列数必须与表中的列数相同。  
任何 SELECT 语句，包括联合 SELECT 及包含 ORDER BY 和/或 LIMIT 子句的 SELECT，都可用于此形式的 INSERT 语句中。
</Callout>
<Callout type='warning'>
为避免解析歧义，如果存在 upsert 子句，SELECT 语句应始终包含 WHERE 子句，即使该子句只含“WHERE true”。  
否则，解析器无法确定“ON”是 SELECT 中连接条件的一部分，还是 upsert 子句的开始。
</Callout>

正如 PostgreSQL 文档所述：
<Callout>
一个查询（SELECT 语句）提供要插入的行
</Callout>

正如 MySQL 文档所述：

<Callout>
通过 INSERT ... SELECT，您可以快速地从 SELECT 语句的结果向表中插入多行，该 SELECT 语句可以从一个或多个表中选择数据
</Callout>

Drizzle 支持所有数据库方言当前的语法，且它们共享相同的语法。  
让我们来看看一些常见的场景和 API 用法。  
在 insert 语句中使用 select 有多种方式，您可以选择自己喜欢的方式：

- 您可以在 select 函数中传入查询构建器。
- 您可以在回调中使用查询构建器。
- 您可以传入一个带有任意自定义 select 查询的 SQL 模板标签。

<Tabs items={["Query Builder", "Callback", "SQL template tag"]}>
<Tab>
<Section>
```ts
const insertedEmployees = await db
  .insert(employees)
  .select(
    db.select({ name: users.name }).from(users).where(eq(users.role, 'employee'))
  )
  .returning({
    id: employees.id,
    name: employees.name
  });
```
```ts
const qb = new QueryBuilder();
await db.insert(employees).select(
    qb.select({ name: users.name }).from(users).where(eq(users.role, 'employee'))
);
```
</Section>
</Tab>
<Tab>
<Section>
```ts
await db.insert(employees).select(
    () => db.select({ name: users.name }).from(users).where(eq(users.role, 'employee'))
);
```
```ts
await db.insert(employees).select(
    (qb) => qb.select({ name: users.name }).from(users).where(eq(users.role, 'employee'))
);
```
</Section>
</Tab>
<Tab>
<Section>
```ts
await db.insert(employees).select(
    sql`select "users"."name" as "name" from "users" where "users"."role" = 'employee'`
);
```
```ts
await db.insert(employees).select(
    () => sql`select "users"."name" as "name" from "users" where "users"."role" = 'employee'`
);
```
</Section>
</Tab>
</Tabs>
